<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2017 Scott Morrison. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Scott Morrison</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  import category_theory.opposites</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import category_theory.hom_functor</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/hom_functor.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  /-!</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  # The Yoneda embedding</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  The Yoneda embedding as a functor `yoneda : C ⥤ (Cᵒᵖ ⥤ Type v₁)`,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  along with an instance that it is `fully_faithful`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  Also the Yoneda lemma, `yoneda_lemma : (yoneda_pairing C) ≅ (yoneda_evaluation C)`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  namespace category_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  open opposite</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  universes v₁ u₁ u₂ -- declare the `v`&#x27;s first; see `category_theory.category` for an explanation</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  variables {C : Type u₁} [𝒞 : category.{v₁} C]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  include 𝒞</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  @[simps] def yoneda : C ⥤ (Cᵒᵖ ⥤ Type v₁) :=</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  { obj := λ X,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28    { obj := λ Y, unop Y ⟶ X,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29      map := λ Y Y&#x27; f g, f.unop ≫ g,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30      map_comp&#x27; := λ _ _ _ f g, begin ext, dsimp, erw [category.assoc] end,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31      map_id&#x27; := λ Y, begin ext, dsimp, erw [category.id_comp] end },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32    map := λ X X&#x27; f, { app := λ Y g, g ≫ f } }</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  @[simps] def coyoneda : Cᵒᵖ ⥤ (C ⥤ Type v₁) :=</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  { obj := λ X,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36    { obj := λ Y, unop X ⟶ Y,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37      map := λ Y Y&#x27; f g, g ≫ f,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38      map_comp&#x27; := λ _ _ _ f g, begin ext1, dsimp, erw [category.assoc] end,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='`ext1 id` selects and apply one extensionality lemma (with attribute
`ext`), using `id`, if provided, to name a local constant
introduced by the lemma. If `id` is omitted, the local constant is
named automatically, as per `intro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='teal'><a title='ext1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39      map_id&#x27; := λ Y, begin ext1, dsimp, erw [category.comp_id] end },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 312, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='`ext1 id` selects and apply one extensionality lemma (with attribute
`ext`), using `id`, if provided, to name a local constant
introduced by the lemma. If `id` is omitted, the local constant is
named automatically, as per `intro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='ext1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40    map := λ X X&#x27; f, { app := λ Y g, f.unop ≫ g },</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41    map_comp&#x27; := λ _ _ _ f g, begin ext, dsimp, erw [category.assoc] end,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='opposite.{u₁+1} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{u₁+1} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{u₁+1} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞))) _x _x_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞))) _x _x_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₁) [c : category_theory.category.{v₁ u₁} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W X) (g : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y) (h : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) Y Z), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) W Z) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W Y Z (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) W X Z f (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
_x _x _x : opposite.{u₁+1} C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
    _x
    _x,
g :
  @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
    _x
    _x
⊢ @eq.{(max u₁ v₁)+1}
    (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁)
                category_theory.types.{v₁})))
       (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
          (λ (Y : C),
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C _x)
               Y)
          (λ (Y Y&#x27; : C)
           (f :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               Y
               Y&#x27;)
           (g :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C _x)
               Y),
             @category_theory.category_struct.comp.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               (@opposite.unop.{u₁+1} C _x)
               Y
               Y&#x27;
               g
               f)
          (λ (Y : C),
             @funext.{v₁+1 v₁+1}
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C _x)
                  Y)
               (λ
                (x :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    Y),
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    Y)
               (λ
                (g :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    Y),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C _x)
                    Y
                    Y
                    g
                    (@category_theory.category_struct.id.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       Y))
               (@category_theory.category_struct.id.{v₁ v₁+1} (Type v₁)
                  (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@opposite.unop.{u₁+1} C _x)
                     Y))
               (λ
                (x :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    Y),
                  @id.{0}
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          Y)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C _x)
                          Y
                          Y
                          x
                          (@category_theory.category_struct.id.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             Y))
                       (@category_theory.category_struct.id.{v₁ v₁+1} (Type v₁)
                          (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             Y)
                          x))
                    (@eq.mpr.{0}
                       (@eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             Y)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             Y
                             Y
                             x
                             (@category_theory.category_struct.id.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                Y))
                          x)
                       (@eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             Y)
                          x
                          x)
                       (@id.{0}
                          (@eq.{1} Prop
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C _x)
                                   Y)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   Y
                                   Y
                                   x
                                   (@category_theory.category_struct.id.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      Y))
                                x)
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C _x)
                                   Y)
                                x
                                x))
                          (@eq.rec.{0 v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C _x)
                                Y)
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C _x)
                                Y
                                Y
                                x
                                (@category_theory.category_struct.id.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   Y))
                             (λ
                              (_a :
                                @category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@opposite.unop.{u₁+1} C _x)
                                  Y),
                                @eq.{1} Prop
                                  (@eq.{v₁+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C _x)
                                        Y)
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C _x)
                                        Y
                                        Y
                                        x
                                        (@category_theory.category_struct.id.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           Y))
                                     x)
                                  (@eq.{v₁+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C _x)
                                        Y)
                                     _a
                                     x))
                             (@eq.refl.{1} Prop
                                (@eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      (@opposite.unop.{u₁+1} C _x)
                                      Y)
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C _x)
                                      Y
                                      Y
                                      x
                                      (@category_theory.category_struct.id.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         Y))
                                   x))
                             x
                             (@category_theory.category.comp_id.{v₁ u₁} C 𝒞 (@opposite.unop.{u₁+1} C _x) Y x)))
                       (@eq.refl.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             Y)
                          x))))
          (λ (_x_1 _x_2 _x_3 : C)
           (f :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               _x_1
               _x_2)
           (g :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               _x_2
               _x_3),
             @funext.{v₁+1 v₁+1}
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C _x)
                  _x_1)
               (λ
                (x :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    _x_1),
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    _x_3)
               (λ
                (g_1 :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    _x_1),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C _x)
                    _x_1
                    _x_3
                    g_1
                    (@category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       _x_1
                       _x_2
                       _x_3
                       f
                       g))
               (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                  (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@opposite.unop.{u₁+1} C _x)
                     _x_1)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@opposite.unop.{u₁+1} C _x)
                     _x_2)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@opposite.unop.{u₁+1} C _x)
                     _x_3)
                  (λ
                   (g :
                     @category_theory.has_hom.hom.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       (@opposite.unop.{u₁+1} C _x)
                       _x_1),
                     @category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       (@opposite.unop.{u₁+1} C _x)
                       _x_1
                       _x_2
                       g
                       f)
                  (λ
                   (g_1 :
                     @category_theory.has_hom.hom.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       (@opposite.unop.{u₁+1} C _x)
                       _x_2),
                     @category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       (@opposite.unop.{u₁+1} C _x)
                       _x_2
                       _x_3
                       g_1
                       g))
               (λ
                (x :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    _x_1),
                  @id.{0}
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          _x_3)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C _x)
                          _x_1
                          _x_3
                          x
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             _x_1
                             _x_2
                             _x_3
                             f
                             g))
                       (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                          (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             _x_1)
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             _x_2)
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             _x_3)
                          (λ
                           (g :
                             @category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@opposite.unop.{u₁+1} C _x)
                               _x_1),
                             @category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@opposite.unop.{u₁+1} C _x)
                               _x_1
                               _x_2
                               g
                               f)
                          (λ
                           (g_1 :
                             @category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@opposite.unop.{u₁+1} C _x)
                               _x_2),
                             @category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@opposite.unop.{u₁+1} C _x)
                               _x_2
                               _x_3
                               g_1
                               g)
                          x))
                    (@eq.mpr.{0}
                       (@eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             _x_3)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             _x_1
                             _x_3
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x_1
                                _x_2
                                _x_3
                                f
                                g))
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             _x_2
                             _x_3
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C _x)
                                _x_1
                                _x_2
                                x
                                f)
                             g))
                       (@eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             _x_3)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             _x_1
                             _x_3
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x_1
                                _x_2
                                _x_3
                                f
                                g))
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             _x_1
                             _x_3
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x_1
                                _x_2
                                _x_3
                                f
                                g)))
                       (@id.{0}
                          (@eq.{1} Prop
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_3)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_1
                                   _x_3
                                   x
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      _x_1
                                      _x_2
                                      _x_3
                                      f
                                      g))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_2
                                   _x_3
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C _x)
                                      _x_1
                                      _x_2
                                      x
                                      f)
                                   g))
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_3)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_1
                                   _x_3
                                   x
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      _x_1
                                      _x_2
                                      _x_3
                                      f
                                      g))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_1
                                   _x_3
                                   x
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      _x_1
                                      _x_2
                                      _x_3
                                      f
                                      g))))
                          (@eq.rec.{0 v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C _x)
                                _x_3)
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C _x)
                                _x_2
                                _x_3
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_1
                                   _x_2
                                   x
                                   f)
                                g)
                             (λ
                              (_a :
                                @category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@opposite.unop.{u₁+1} C _x)
                                  _x_3),
                                @eq.{1} Prop
                                  (@eq.{v₁+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C _x)
                                        _x_3)
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C _x)
                                        _x_1
                                        _x_3
                                        x
                                        (@category_theory.category_struct.comp.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           _x_1
                                           _x_2
                                           _x_3
                                           f
                                           g))
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C _x)
                                        _x_2
                                        _x_3
                                        (@category_theory.category_struct.comp.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           (@opposite.unop.{u₁+1} C _x)
                                           _x_1
                                           _x_2
                                           x
                                           f)
                                        g))
                                  (@eq.{v₁+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C _x)
                                        _x_3)
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C _x)
                                        _x_1
                                        _x_3
                                        x
                                        (@category_theory.category_struct.comp.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           _x_1
                                           _x_2
                                           _x_3
                                           f
                                           g))
                                     _a))
                             (@eq.refl.{1} Prop
                                (@eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      (@opposite.unop.{u₁+1} C _x)
                                      _x_3)
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C _x)
                                      _x_1
                                      _x_3
                                      x
                                      (@category_theory.category_struct.comp.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         _x_1
                                         _x_2
                                         _x_3
                                         f
                                         g))
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C _x)
                                      _x_2
                                      _x_3
                                      (@category_theory.category_struct.comp.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         (@opposite.unop.{u₁+1} C _x)
                                         _x_1
                                         _x_2
                                         x
                                         f)
                                      g)))
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C _x)
                                _x_1
                                _x_3
                                x
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   _x_1
                                   _x_2
                                   _x_3
                                   f
                                   g))
                             (@category_theory.category.assoc.{v₁ u₁} C 𝒞 (@opposite.unop.{u₁+1} C _x) _x_1
                                _x_2
                                _x_3
                                x
                                f
                                g)))
                       (@eq.refl.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             _x_3)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             _x_1
                             _x_3
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x_1
                                _x_2
                                _x_3
                                f
                                g)))))))
       (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
          (λ (Y : C),
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C _x)
               Y)
          (λ (Y Y&#x27; : C)
           (f :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               Y
               Y&#x27;)
           (g :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C _x)
               Y),
             @category_theory.category_struct.comp.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               (@opposite.unop.{u₁+1} C _x)
               Y
               Y&#x27;
               g
               f)
          (λ (Y : C),
             @funext.{v₁+1 v₁+1}
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C _x)
                  Y)
               (λ
                (x :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    Y),
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    Y)
               (λ
                (g :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    Y),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C _x)
                    Y
                    Y
                    g
                    (@category_theory.category_struct.id.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       Y))
               (@category_theory.category_struct.id.{v₁ v₁+1} (Type v₁)
                  (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@opposite.unop.{u₁+1} C _x)
                     Y))
               (λ
                (x :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    Y),
                  @id.{0}
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          Y)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C _x)
                          Y
                          Y
                          x
                          (@category_theory.category_struct.id.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             Y))
                       (@category_theory.category_struct.id.{v₁ v₁+1} (Type v₁)
                          (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             Y)
                          x))
                    (@eq.mpr.{0}
                       (@eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             Y)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             Y
                             Y
                             x
                             (@category_theory.category_struct.id.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                Y))
                          x)
                       (@eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             Y)
                          x
                          x)
                       (@id.{0}
                          (@eq.{1} Prop
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C _x)
                                   Y)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   Y
                                   Y
                                   x
                                   (@category_theory.category_struct.id.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      Y))
                                x)
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C _x)
                                   Y)
                                x
                                x))
                          (@eq.rec.{0 v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C _x)
                                Y)
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C _x)
                                Y
                                Y
                                x
                                (@category_theory.category_struct.id.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   Y))
                             (λ
                              (_a :
                                @category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@opposite.unop.{u₁+1} C _x)
                                  Y),
                                @eq.{1} Prop
                                  (@eq.{v₁+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C _x)
                                        Y)
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C _x)
                                        Y
                                        Y
                                        x
                                        (@category_theory.category_struct.id.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           Y))
                                     x)
                                  (@eq.{v₁+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C _x)
                                        Y)
                                     _a
                                     x))
                             (@eq.refl.{1} Prop
                                (@eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      (@opposite.unop.{u₁+1} C _x)
                                      Y)
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C _x)
                                      Y
                                      Y
                                      x
                                      (@category_theory.category_struct.id.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         Y))
                                   x))
                             x
                             (@category_theory.category.comp_id.{v₁ u₁} C 𝒞 (@opposite.unop.{u₁+1} C _x) Y x)))
                       (@eq.refl.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             Y)
                          x))))
          (λ (_x_1 _x_2 _x_3 : C)
           (f :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               _x_1
               _x_2)
           (g :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               _x_2
               _x_3),
             @funext.{v₁+1 v₁+1}
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C _x)
                  _x_1)
               (λ
                (x :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    _x_1),
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    _x_3)
               (λ
                (g_1 :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    _x_1),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C _x)
                    _x_1
                    _x_3
                    g_1
                    (@category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       _x_1
                       _x_2
                       _x_3
                       f
                       g))
               (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                  (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@opposite.unop.{u₁+1} C _x)
                     _x_1)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@opposite.unop.{u₁+1} C _x)
                     _x_2)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@opposite.unop.{u₁+1} C _x)
                     _x_3)
                  (λ
                   (g :
                     @category_theory.has_hom.hom.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       (@opposite.unop.{u₁+1} C _x)
                       _x_1),
                     @category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       (@opposite.unop.{u₁+1} C _x)
                       _x_1
                       _x_2
                       g
                       f)
                  (λ
                   (g_1 :
                     @category_theory.has_hom.hom.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       (@opposite.unop.{u₁+1} C _x)
                       _x_2),
                     @category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       (@opposite.unop.{u₁+1} C _x)
                       _x_2
                       _x_3
                       g_1
                       g))
               (λ
                (x :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    _x_1),
                  @id.{0}
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          _x_3)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C _x)
                          _x_1
                          _x_3
                          x
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             _x_1
                             _x_2
                             _x_3
                             f
                             g))
                       (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                          (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             _x_1)
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             _x_2)
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             _x_3)
                          (λ
                           (g :
                             @category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@opposite.unop.{u₁+1} C _x)
                               _x_1),
                             @category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@opposite.unop.{u₁+1} C _x)
                               _x_1
                               _x_2
                               g
                               f)
                          (λ
                           (g_1 :
                             @category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@opposite.unop.{u₁+1} C _x)
                               _x_2),
                             @category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@opposite.unop.{u₁+1} C _x)
                               _x_2
                               _x_3
                               g_1
                               g)
                          x))
                    (@eq.mpr.{0}
                       (@eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             _x_3)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             _x_1
                             _x_3
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x_1
                                _x_2
                                _x_3
                                f
                                g))
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             _x_2
                             _x_3
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C _x)
                                _x_1
                                _x_2
                                x
                                f)
                             g))
                       (@eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             _x_3)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             _x_1
                             _x_3
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x_1
                                _x_2
                                _x_3
                                f
                                g))
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             _x_1
                             _x_3
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x_1
                                _x_2
                                _x_3
                                f
                                g)))
                       (@id.{0}
                          (@eq.{1} Prop
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_3)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_1
                                   _x_3
                                   x
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      _x_1
                                      _x_2
                                      _x_3
                                      f
                                      g))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_2
                                   _x_3
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C _x)
                                      _x_1
                                      _x_2
                                      x
                                      f)
                                   g))
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_3)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_1
                                   _x_3
                                   x
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      _x_1
                                      _x_2
                                      _x_3
                                      f
                                      g))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_1
                                   _x_3
                                   x
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      _x_1
                                      _x_2
                                      _x_3
                                      f
                                      g))))
                          (@eq.rec.{0 v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C _x)
                                _x_3)
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C _x)
                                _x_2
                                _x_3
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_1
                                   _x_2
                                   x
                                   f)
                                g)
                             (λ
                              (_a :
                                @category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@opposite.unop.{u₁+1} C _x)
                                  _x_3),
                                @eq.{1} Prop
                                  (@eq.{v₁+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C _x)
                                        _x_3)
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C _x)
                                        _x_1
                                        _x_3
                                        x
                                        (@category_theory.category_struct.comp.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           _x_1
                                           _x_2
                                           _x_3
                                           f
                                           g))
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C _x)
                                        _x_2
                                        _x_3
                                        (@category_theory.category_struct.comp.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           (@opposite.unop.{u₁+1} C _x)
                                           _x_1
                                           _x_2
                                           x
                                           f)
                                        g))
                                  (@eq.{v₁+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C _x)
                                        _x_3)
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C _x)
                                        _x_1
                                        _x_3
                                        x
                                        (@category_theory.category_struct.comp.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           _x_1
                                           _x_2
                                           _x_3
                                           f
                                           g))
                                     _a))
                             (@eq.refl.{1} Prop
                                (@eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      (@opposite.unop.{u₁+1} C _x)
                                      _x_3)
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C _x)
                                      _x_1
                                      _x_3
                                      x
                                      (@category_theory.category_struct.comp.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         _x_1
                                         _x_2
                                         _x_3
                                         f
                                         g))
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C _x)
                                      _x_2
                                      _x_3
                                      (@category_theory.category_struct.comp.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         (@opposite.unop.{u₁+1} C _x)
                                         _x_1
                                         _x_2
                                         x
                                         f)
                                      g)))
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C _x)
                                _x_1
                                _x_3
                                x
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   _x_1
                                   _x_2
                                   _x_3
                                   f
                                   g))
                             (@category_theory.category.assoc.{v₁ u₁} C 𝒞 (@opposite.unop.{u₁+1} C _x) _x_1
                                _x_2
                                _x_3
                                x
                                f
                                g)))
                       (@eq.refl.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             _x_3)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             _x_1
                             _x_3
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x_1
                                _x_2
                                _x_3
                                f
                                g))))))))
    (@category_theory.nat_trans.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
       (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
          (λ (Y : C),
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C _x)
               Y)
          (λ (Y Y&#x27; : C)
           (f :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               Y
               Y&#x27;)
           (g :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C _x)
               Y),
             @category_theory.category_struct.comp.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               (@opposite.unop.{u₁+1} C _x)
               Y
               Y&#x27;
               g
               f)
          (λ (Y : C),
             @funext.{v₁+1 v₁+1}
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C _x)
                  Y)
               (λ (x : … … Y), …)
               …
               …
               …)
          …)
       …
       …
       …)
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
_x _x _x : opposite.{u₁+1} C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
    _x
    _x,
g :
  @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
    _x
    _x,
x : C,
x_1 :
  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
    (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
       (λ (Y : C),
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            (@opposite.unop.{u₁+1} C _x)
            Y)
       (λ (Y Y&#x27; : C)
        (f :
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            Y
            Y&#x27;)
        (g :
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            (@opposite.unop.{u₁+1} C _x)
            Y),
          @category_theory.category_struct.comp.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
            (@opposite.unop.{u₁+1} C _x)
            Y
            Y&#x27;
            g
            f)
       (λ (Y : C),
          @funext.{v₁+1 v₁+1}
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C _x)
               Y)
            (λ
             (x :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C _x)
                 Y),
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C _x)
                 Y)
            (λ
             (g :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C _x)
                 Y),
               @category_theory.category_struct.comp.{v₁ u₁} C
                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                 (@opposite.unop.{u₁+1} C _x)
                 Y
                 Y
                 g
                 (@category_theory.category_struct.id.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    Y))
            (@category_theory.category_struct.id.{v₁ v₁+1} (Type v₁)
               (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C _x)
                  Y))
            (λ
             (x :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C _x)
                 Y),
               @id.{0}
                 (@eq.{v₁+1}
                    (@category_theory.has_hom.hom.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       (@opposite.unop.{u₁+1} C _x)
                       Y)
                    (@category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       (@opposite.unop.{u₁+1} C _x)
                       Y
                       Y
                       x
                       (@category_theory.category_struct.id.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          Y))
                    (@category_theory.category_struct.id.{v₁ v₁+1} (Type v₁)
                       (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                          category_theory.types.{v₁})
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          Y)
                       x))
                 (@eq.mpr.{0}
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          Y)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C _x)
                          Y
                          Y
                          x
                          (@category_theory.category_struct.id.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             Y))
                       x)
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          Y)
                       x
                       x)
                    (@id.{0}
                       (@eq.{1} Prop
                          (@eq.{v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C _x)
                                Y)
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C _x)
                                Y
                                Y
                                x
                                (@category_theory.category_struct.id.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   Y))
                             x)
                          (@eq.{v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C _x)
                                Y)
                             x
                             x))
                       (@eq.rec.{0 v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             Y)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             Y
                             Y
                             x
                             (@category_theory.category_struct.id.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                Y))
                          (λ
                           (_a :
                             @category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@opposite.unop.{u₁+1} C _x)
                               Y),
                             @eq.{1} Prop
                               (@eq.{v₁+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C _x)
                                     Y)
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@opposite.unop.{u₁+1} C _x)
                                     Y
                                     Y
                                     x
                                     (@category_theory.category_struct.id.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        Y))
                                  x)
                               (@eq.{v₁+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C _x)
                                     Y)
                                  _a
                                  x))
                          (@eq.refl.{1} Prop
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C _x)
                                   Y)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   Y
                                   Y
                                   x
                                   (@category_theory.category_struct.id.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      Y))
                                x))
                          x
                          (@category_theory.category.comp_id.{v₁ u₁} C 𝒞 (@opposite.unop.{u₁+1} C _x) Y x)))
                    (@eq.refl.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          Y)
                       x))))
       (λ (_x_1 _x_2 _x_3 : C)
        (f :
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            _x_1
            _x_2)
        (g :
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            _x_2
            _x_3),
          @funext.{v₁+1 v₁+1}
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C _x)
               _x_1)
            (λ
             (x :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C _x)
                 _x_1),
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C _x)
                 _x_3)
            (λ
             (g_1 :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C _x)
                 _x_1),
               @category_theory.category_struct.comp.{v₁ u₁} C
                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                 (@opposite.unop.{u₁+1} C _x)
                 _x_1
                 _x_3
                 g_1
                 (@category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    _x_1
                    _x_2
                    _x_3
                    f
                    g))
            (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
               (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C _x)
                  _x_1)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C _x)
                  _x_2)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C _x)
                  _x_3)
               (λ
                (g :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    _x_1),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C _x)
                    _x_1
                    _x_2
                    g
                    f)
               (λ
                (g_1 :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    _x_2),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C _x)
                    _x_2
                    _x_3
                    g_1
                    g))
            (λ
             (x :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C _x)
                 _x_1),
               @id.{0}
                 (@eq.{v₁+1}
                    (@category_theory.has_hom.hom.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       (@opposite.unop.{u₁+1} C _x)
                       _x_3)
                    (@category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       (@opposite.unop.{u₁+1} C _x)
                       _x_1
                       _x_3
                       x
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          _x_1
                          _x_2
                          _x_3
                          f
                          g))
                    (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                       (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                          category_theory.types.{v₁})
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          _x_1)
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          _x_2)
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          _x_3)
                       (λ
                        (g :
                          @category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@opposite.unop.{u₁+1} C _x)
                            _x_1),
                          @category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@opposite.unop.{u₁+1} C _x)
                            _x_1
                            _x_2
                            g
                            f)
                       (λ
                        (g_1 :
                          @category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@opposite.unop.{u₁+1} C _x)
                            _x_2),
                          @category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@opposite.unop.{u₁+1} C _x)
                            _x_2
                            _x_3
                            g_1
                            g)
                       x))
                 (@eq.mpr.{0}
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          _x_3)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C _x)
                          _x_1
                          _x_3
                          x
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             _x_1
                             _x_2
                             _x_3
                             f
                             g))
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C _x)
                          _x_2
                          _x_3
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             _x_1
                             _x_2
                             x
                             f)
                          g))
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          _x_3)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C _x)
                          _x_1
                          _x_3
                          x
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             _x_1
                             _x_2
                             _x_3
                             f
                             g))
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C _x)
                          _x_1
                          _x_3
                          x
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             _x_1
                             _x_2
                             _x_3
                             f
                             g)))
                    (@id.{0}
                       (@eq.{1} Prop
                          (@eq.{v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C _x)
                                _x_3)
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C _x)
                                _x_1
                                _x_3
                                x
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   _x_1
                                   _x_2
                                   _x_3
                                   f
                                   g))
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C _x)
                                _x_2
                                _x_3
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_1
                                   _x_2
                                   x
                                   f)
                                g))
                          (@eq.{v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C _x)
                                _x_3)
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C _x)
                                _x_1
                                _x_3
                                x
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   _x_1
                                   _x_2
                                   _x_3
                                   f
                                   g))
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C _x)
                                _x_1
                                _x_3
                                x
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   _x_1
                                   _x_2
                                   _x_3
                                   f
                                   g))))
                       (@eq.rec.{0 v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             _x_3)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             _x_2
                             _x_3
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C _x)
                                _x_1
                                _x_2
                                x
                                f)
                             g)
                          (λ
                           (_a :
                             @category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@opposite.unop.{u₁+1} C _x)
                               _x_3),
                             @eq.{1} Prop
                               (@eq.{v₁+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C _x)
                                     _x_3)
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@opposite.unop.{u₁+1} C _x)
                                     _x_1
                                     _x_3
                                     x
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        _x_1
                                        _x_2
                                        _x_3
                                        f
                                        g))
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@opposite.unop.{u₁+1} C _x)
                                     _x_2
                                     _x_3
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C _x)
                                        _x_1
                                        _x_2
                                        x
                                        f)
                                     g))
                               (@eq.{v₁+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C _x)
                                     _x_3)
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@opposite.unop.{u₁+1} C _x)
                                     _x_1
                                     _x_3
                                     x
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        _x_1
                                        _x_2
                                        _x_3
                                        f
                                        g))
                                  _a))
                          (@eq.refl.{1} Prop
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_3)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_1
                                   _x_3
                                   x
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      _x_1
                                      _x_2
                                      _x_3
                                      f
                                      g))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_2
                                   _x_3
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C _x)
                                      _x_1
                                      _x_2
                                      x
                                      f)
                                   g)))
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             _x_1
                             _x_3
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x_1
                                _x_2
                                _x_3
                                f
                                g))
                          (@category_theory.category.assoc.{v₁ u₁} C 𝒞 (@opposite.unop.{u₁+1} C _x) _x_1 _x_2
                             _x_3
                             x
                             f
                             g)))
                    (@eq.refl.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          _x_3)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C _x)
                          _x_1
                          _x_3
                          x
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             _x_1
                             _x_2
                             _x_3
                             f
                             g)))))))
    x
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
       (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
          (λ (Y : C),
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C _x)
               Y)
          (λ (Y Y&#x27; : C)
           (f :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               Y
               Y&#x27;)
           (g :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C _x)
               Y),
             @category_theory.category_struct.comp.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               (@opposite.unop.{u₁+1} C _x)
               Y
               Y&#x27;
               g
               f)
          (λ (Y : C),
             @funext.{v₁+1 v₁+1}
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C _x)
                  Y)
               (λ
                (x :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    Y),
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    Y)
               (λ
                (g :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    Y),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C _x)
                    Y
                    Y
                    g
                    (@category_theory.category_struct.id.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       Y))
               (@category_theory.category_struct.id.{v₁ v₁+1} (Type v₁)
                  (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@opposite.unop.{u₁+1} C _x)
                     Y))
               (λ
                (x :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    Y),
                  @id.{0}
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          Y)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C _x)
                          Y
                          Y
                          x
                          (@category_theory.category_struct.id.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             Y))
                       (@category_theory.category_struct.id.{v₁ v₁+1} (Type v₁)
                          (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             Y)
                          x))
                    (@eq.mpr.{0}
                       (@eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             Y)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             Y
                             Y
                             x
                             (@category_theory.category_struct.id.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                Y))
                          x)
                       (@eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             Y)
                          x
                          x)
                       (@id.{0}
                          (@eq.{1} Prop
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C _x)
                                   Y)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   Y
                                   Y
                                   x
                                   (@category_theory.category_struct.id.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      Y))
                                x)
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C _x)
                                   Y)
                                x
                                x))
                          (@eq.rec.{0 v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C _x)
                                Y)
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C _x)
                                Y
                                Y
                                x
                                (@category_theory.category_struct.id.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   Y))
                             (λ
                              (_a :
                                @category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@opposite.unop.{u₁+1} C _x)
                                  Y),
                                @eq.{1} Prop
                                  (@eq.{v₁+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C _x)
                                        Y)
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C _x)
                                        Y
                                        Y
                                        x
                                        (@category_theory.category_struct.id.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           Y))
                                     x)
                                  (@eq.{v₁+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C _x)
                                        Y)
                                     _a
                                     x))
                             (@eq.refl.{1} Prop
                                (@eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      (@opposite.unop.{u₁+1} C _x)
                                      Y)
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C _x)
                                      Y
                                      Y
                                      x
                                      (@category_theory.category_struct.id.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         Y))
                                   x))
                             x
                             (@category_theory.category.comp_id.{v₁ u₁} C 𝒞 (@opposite.unop.{u₁+1} C _x) Y x)))
                       (@eq.refl.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             Y)
                          x))))
          (λ (_x_1 _x_2 _x_3 : C)
           (f :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               _x_1
               _x_2)
           (g :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               _x_2
               _x_3),
             @funext.{v₁+1 v₁+1}
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C _x)
                  _x_1)
               (λ
                (x :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    _x_1),
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    _x_3)
               (λ
                (g_1 :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    _x_1),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C _x)
                    _x_1
                    _x_3
                    g_1
                    (@category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       _x_1
                       _x_2
                       _x_3
                       f
                       g))
               (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                  (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@opposite.unop.{u₁+1} C _x)
                     _x_1)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@opposite.unop.{u₁+1} C _x)
                     _x_2)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@opposite.unop.{u₁+1} C _x)
                     _x_3)
                  (λ
                   (g :
                     @category_theory.has_hom.hom.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       (@opposite.unop.{u₁+1} C _x)
                       _x_1),
                     @category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       (@opposite.unop.{u₁+1} C _x)
                       _x_1
                       _x_2
                       g
                       f)
                  (λ
                   (g_1 :
                     @category_theory.has_hom.hom.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       (@opposite.unop.{u₁+1} C _x)
                       _x_2),
                     @category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       (@opposite.unop.{u₁+1} C _x)
                       _x_2
                       _x_3
                       g_1
                       g))
               (λ
                (x :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    _x_1),
                  @id.{0}
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          _x_3)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C _x)
                          _x_1
                          _x_3
                          x
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             _x_1
                             _x_2
                             _x_3
                             f
                             g))
                       (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                          (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             _x_1)
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             _x_2)
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             _x_3)
                          (λ
                           (g :
                             @category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@opposite.unop.{u₁+1} C _x)
                               _x_1),
                             @category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@opposite.unop.{u₁+1} C _x)
                               _x_1
                               _x_2
                               g
                               f)
                          (λ
                           (g_1 :
                             @category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@opposite.unop.{u₁+1} C _x)
                               _x_2),
                             @category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@opposite.unop.{u₁+1} C _x)
                               _x_2
                               _x_3
                               g_1
                               g)
                          x))
                    (@eq.mpr.{0}
                       (@eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             _x_3)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             _x_1
                             _x_3
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x_1
                                _x_2
                                _x_3
                                f
                                g))
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             _x_2
                             _x_3
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C _x)
                                _x_1
                                _x_2
                                x
                                f)
                             g))
                       (@eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             _x_3)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             _x_1
                             _x_3
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x_1
                                _x_2
                                _x_3
                                f
                                g))
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             _x_1
                             _x_3
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x_1
                                _x_2
                                _x_3
                                f
                                g)))
                       (@id.{0}
                          (@eq.{1} Prop
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_3)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_1
                                   _x_3
                                   x
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      _x_1
                                      _x_2
                                      _x_3
                                      f
                                      g))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_2
                                   _x_3
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C _x)
                                      _x_1
                                      _x_2
                                      x
                                      f)
                                   g))
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_3)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_1
                                   _x_3
                                   x
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      _x_1
                                      _x_2
                                      _x_3
                                      f
                                      g))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_1
                                   _x_3
                                   x
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      _x_1
                                      _x_2
                                      _x_3
                                      f
                                      g))))
                          (@eq.rec.{0 v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C _x)
                                _x_3)
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C _x)
                                _x_2
                                _x_3
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_1
                                   _x_2
                                   x
                                   f)
                                g)
                             (λ
                              (_a :
                                @category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@opposite.unop.{u₁+1} C _x)
                                  _x_3),
                                @eq.{1} Prop
                                  (@eq.{v₁+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C _x)
                                        _x_3)
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C _x)
                                        _x_1
                                        _x_3
                                        x
                                        (@category_theory.category_struct.comp.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           _x_1
                                           _x_2
                                           _x_3
                                           f
                                           g))
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C _x)
                                        _x_2
                                        _x_3
                                        (@category_theory.category_struct.comp.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           (@opposite.unop.{u₁+1} C _x)
                                           _x_1
                                           _x_2
                                           x
                                           f)
                                        g))
                                  (@eq.{v₁+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C _x)
                                        _x_3)
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C _x)
                                        _x_1
                                        _x_3
                                        x
                                        (@category_theory.category_struct.comp.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           _x_1
                                           _x_2
                                           _x_3
                                           f
                                           g))
                                     _a))
                             (@eq.refl.{1} Prop
                                (@eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      (@opposite.unop.{u₁+1} C _x)
                                      _x_3)
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C _x)
                                      _x_1
                                      _x_3
                                      x
                                      (@category_theory.category_struct.comp.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         _x_1
                                         _x_2
                                         _x_3
                                         f
                                         g))
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C _x)
                                      _x_2
                                      _x_3
                                      (@category_theory.category_struct.comp.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         (@opposite.unop.{u₁+1} C _x)
                                         _x_1
                                         _x_2
                                         x
                                         f)
                                      g)))
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C _x)
                                _x_1
                                _x_3
                                x
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   _x_1
                                   _x_2
                                   _x_3
                                   f
                                   g))
                             (@category_theory.category.assoc.{v₁ u₁} C 𝒞 (@opposite.unop.{u₁+1} C _x) _x_1
                                _x_2
                                _x_3
                                x
                                f
                                g)))
                       (@eq.refl.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             _x_3)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             _x_1
                             _x_3
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x_1
                                _x_2
                                _x_3
                                f
                                g)))))))
       x)
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
       (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
          (λ (Y : C),
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C _x)
               Y)
          (λ (Y Y&#x27; : C)
           (f :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               Y
               Y&#x27;)
           (g :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C _x)
               Y),
             @category_theory.category_struct.comp.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               (@opposite.unop.{u₁+1} C _x)
               Y
               Y&#x27;
               g
               f)
          (λ (Y : C),
             @funext.{v₁+1 v₁+1}
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C _x)
                  Y)
               (λ
                (x :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    Y),
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    Y)
               (λ
                (g :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    Y),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C _x)
                    Y
                    Y
                    g
                    (@category_theory.category_struct.id.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       Y))
               (@category_theory.category_struct.id.{v₁ v₁+1} (Type v₁)
                  (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@opposite.unop.{u₁+1} C _x)
                     Y))
               (λ
                (x :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    Y),
                  @id.{0}
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          Y)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C _x)
                          Y
                          Y
                          x
                          (@category_theory.category_struct.id.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             Y))
                       (@category_theory.category_struct.id.{v₁ v₁+1} (Type v₁)
                          (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             Y)
                          x))
                    (@eq.mpr.{0}
                       (@eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             Y)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             Y
                             Y
                             x
                             (@category_theory.category_struct.id.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                Y))
                          x)
                       (@eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             Y)
                          x
                          x)
                       (@id.{0}
                          (@eq.{1} Prop
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C _x)
                                   Y)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   Y
                                   Y
                                   x
                                   (@category_theory.category_struct.id.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      Y))
                                x)
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C _x)
                                   Y)
                                x
                                x))
                          (@eq.rec.{0 v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C _x)
                                Y)
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C _x)
                                Y
                                Y
                                x
                                (@category_theory.category_struct.id.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   Y))
                             (λ
                              (_a :
                                @category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@opposite.unop.{u₁+1} C _x)
                                  Y),
                                @eq.{1} Prop
                                  (@eq.{v₁+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C _x)
                                        Y)
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C _x)
                                        Y
                                        Y
                                        x
                                        (@category_theory.category_struct.id.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           Y))
                                     x)
                                  (@eq.{v₁+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C _x)
                                        Y)
                                     _a
                                     x))
                             (@eq.refl.{1} Prop
                                (@eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      (@opposite.unop.{u₁+1} C _x)
                                      Y)
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C _x)
                                      Y
                                      Y
                                      x
                                      (@category_theory.category_struct.id.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         Y))
                                   x))
                             x
                             (@category_theory.category.comp_id.{v₁ u₁} C 𝒞 (@opposite.unop.{u₁+1} C _x) Y x)))
                       (@eq.refl.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             Y)
                          x))))
          (λ (_x_1 _x_2 _x_3 : C)
           (f :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               _x_1
               _x_2)
           (g :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               _x_2
               _x_3),
             @funext.{v₁+1 v₁+1}
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C _x)
                  _x_1)
               (λ
                (x :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    _x_1),
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    _x_3)
               (λ
                (g_1 :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    _x_1),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C _x)
                    _x_1
                    _x_3
                    g_1
                    (@category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       _x_1
                       _x_2
                       _x_3
                       f
                       g))
               (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                  (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@opposite.unop.{u₁+1} C _x)
                     _x_1)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@opposite.unop.{u₁+1} C _x)
                     _x_2)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@opposite.unop.{u₁+1} C _x)
                     _x_3)
                  (λ
                   (g :
                     @category_theory.has_hom.hom.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       (@opposite.unop.{u₁+1} C _x)
                       _x_1),
                     @category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       (@opposite.unop.{u₁+1} C _x)
                       _x_1
                       _x_2
                       g
                       f)
                  (λ
                   (g_1 :
                     @category_theory.has_hom.hom.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       (@opposite.unop.{u₁+1} C _x)
                       _x_2),
                     @category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       (@opposite.unop.{u₁+1} C _x)
                       _x_2
                       _x_3
                       g_1
                       g))
               (λ
                (x :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    _x_1),
                  @id.{0}
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          _x_3)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C _x)
                          _x_1
                          _x_3
                          x
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             _x_1
                             _x_2
                             _x_3
                             f
                             g))
                       (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                          (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             _x_1)
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             _x_2)
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             _x_3)
                          (λ
                           (g :
                             @category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@opposite.unop.{u₁+1} C _x)
                               _x_1),
                             @category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@opposite.unop.{u₁+1} C _x)
                               _x_1
                               _x_2
                               g
                               f)
                          (λ
                           (g_1 :
                             @category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@opposite.unop.{u₁+1} C _x)
                               _x_2),
                             @category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@opposite.unop.{u₁+1} C _x)
                               _x_2
                               _x_3
                               g_1
                               g)
                          x))
                    (@eq.mpr.{0}
                       (@eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             _x_3)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             _x_1
                             _x_3
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x_1
                                _x_2
                                _x_3
                                f
                                g))
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             _x_2
                             _x_3
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C _x)
                                _x_1
                                _x_2
                                x
                                f)
                             g))
                       (@eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             _x_3)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             _x_1
                             _x_3
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x_1
                                _x_2
                                _x_3
                                f
                                g))
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             _x_1
                             _x_3
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x_1
                                _x_2
                                _x_3
                                f
                                g)))
                       (@id.{0}
                          (@eq.{1} Prop
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_3)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_1
                                   _x_3
                                   x
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      _x_1
                                      _x_2
                                      _x_3
                                      f
                                      g))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_2
                                   _x_3
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C _x)
                                      _x_1
                                      _x_2
                                      x
                                      f)
                                   g))
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_3)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_1
                                   _x_3
                                   x
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      _x_1
                                      _x_2
                                      _x_3
                                      f
                                      g))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_1
                                   _x_3
                                   x
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      _x_1
                                      _x_2
                                      _x_3
                                      f
                                      g))))
                          (@eq.rec.{0 v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C _x)
                                _x_3)
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C _x)
                                _x_2
                                _x_3
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_1
                                   _x_2
                                   x
                                   f)
                                g)
                             (λ
                              (_a :
                                @category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@opposite.unop.{u₁+1} C _x)
                                  _x_3),
                                @eq.{1} Prop
                                  (@eq.{v₁+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C _x)
                                        _x_3)
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C _x)
                                        _x_1
                                        _x_3
                                        x
                                        (@category_theory.category_struct.comp.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           _x_1
                                           _x_2
                                           _x_3
                                           f
                                           g))
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C _x)
                                        _x_2
                                        _x_3
                                        (@category_theory.category_struct.comp.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           (@opposite.unop.{u₁+1} C _x)
                                           _x_1
                                           _x_2
                                           x
                                           f)
                                        g))
                                  (@eq.{v₁+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C _x)
                                        _x_3)
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C _x)
                                        _x_1
                                        _x_3
                                        x
                                        (@category_theory.category_struct.comp.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           _x_1
                                           _x_2
                                           _x_3
                                           f
                                           g))
                                     _a))
                             (@eq.refl.{1} Prop
                                (@eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      (@opposite.unop.{u₁+1} C _x)
                                      _x_3)
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C _x)
                                      _x_1
                                      _x_3
                                      x
                                      (@category_theory.category_struct.comp.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         _x_1
                                         _x_2
                                         _x_3
                                         f
                                         g))
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C _x)
                                      _x_2
                                      _x_3
                                      (@category_theory.category_struct.comp.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         (@opposite.unop.{u₁+1} C _x)
                                         _x_1
                                         _x_2
                                         x
                                         f)
                                      g)))
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C _x)
                                _x_1
                                _x_3
                                x
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   _x_1
                                   _x_2
                                   _x_3
                                   f
                                   g))
                             (@category_theory.category.assoc.{v₁ u₁} C 𝒞 (@opposite.unop.{u₁+1} C _x) _x_1
                                _x_2
                                _x_3
                                x
                                f
                                g)))
                       (@eq.refl.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             _x_3)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             _x_1
                             _x_3
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x_1
                                _x_2
                                _x_3
                                f
                                g)))))))
       (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
          (λ (Y : C),
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C _x)
               Y)
          (λ (Y Y&#x27; : C)
           (f :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               Y
               Y&#x27;)
           (g :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C _x)
               Y),
             @category_theory.category_struct.comp.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               (@opposite.unop.{u₁+1} C _x)
               Y
               Y&#x27;
               g
               f)
          (λ (Y : C),
             @funext.{v₁+1 v₁+1}
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C _x)
                  Y)
               (λ
                (x :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    Y),
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    …
                    Y)
               …
               …
               …)
          …)
       …
       x
       x_1)
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
_x _x _x : opposite.{u₁+1} C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
    _x
    _x,
g :
  @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
    _x
    _x,
x : C,
x_1 :
  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
    (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
       (λ (Y : C),
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            (@opposite.unop.{u₁+1} C _x)
            Y)
       (λ (Y Y&#x27; : C)
        (f :
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            Y
            Y&#x27;)
        (g :
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            (@opposite.unop.{u₁+1} C _x)
            Y),
          @category_theory.category_struct.comp.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
            (@opposite.unop.{u₁+1} C _x)
            Y
            Y&#x27;
            g
            f)
       (λ (Y : C),
          @funext.{v₁+1 v₁+1}
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C _x)
               Y)
            (λ
             (x :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C _x)
                 Y),
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C _x)
                 Y)
            (λ
             (g :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C _x)
                 Y),
               @category_theory.category_struct.comp.{v₁ u₁} C
                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                 (@opposite.unop.{u₁+1} C _x)
                 Y
                 Y
                 g
                 (@category_theory.category_struct.id.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    Y))
            (@category_theory.category_struct.id.{v₁ v₁+1} (Type v₁)
               (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C _x)
                  Y))
            (λ
             (x :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C _x)
                 Y),
               @id.{0}
                 (@eq.{v₁+1}
                    (@category_theory.has_hom.hom.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       (@opposite.unop.{u₁+1} C _x)
                       Y)
                    (@category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       (@opposite.unop.{u₁+1} C _x)
                       Y
                       Y
                       x
                       (@category_theory.category_struct.id.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          Y))
                    (@category_theory.category_struct.id.{v₁ v₁+1} (Type v₁)
                       (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                          category_theory.types.{v₁})
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          Y)
                       x))
                 (@eq.mpr.{0}
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          Y)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C _x)
                          Y
                          Y
                          x
                          (@category_theory.category_struct.id.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             Y))
                       x)
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          Y)
                       x
                       x)
                    (@id.{0}
                       (@eq.{1} Prop
                          (@eq.{v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C _x)
                                Y)
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C _x)
                                Y
                                Y
                                x
                                (@category_theory.category_struct.id.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   Y))
                             x)
                          (@eq.{v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C _x)
                                Y)
                             x
                             x))
                       (@eq.rec.{0 v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             Y)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             Y
                             Y
                             x
                             (@category_theory.category_struct.id.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                Y))
                          (λ
                           (_a :
                             @category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@opposite.unop.{u₁+1} C _x)
                               Y),
                             @eq.{1} Prop
                               (@eq.{v₁+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C _x)
                                     Y)
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@opposite.unop.{u₁+1} C _x)
                                     Y
                                     Y
                                     x
                                     (@category_theory.category_struct.id.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        Y))
                                  x)
                               (@eq.{v₁+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C _x)
                                     Y)
                                  _a
                                  x))
                          (@eq.refl.{1} Prop
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C _x)
                                   Y)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   Y
                                   Y
                                   x
                                   (@category_theory.category_struct.id.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      Y))
                                x))
                          x
                          (@category_theory.category.comp_id.{v₁ u₁} C 𝒞 (@opposite.unop.{u₁+1} C _x) Y x)))
                    (@eq.refl.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          Y)
                       x))))
       (λ (_x_1 _x_2 _x_3 : C)
        (f :
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            _x_1
            _x_2)
        (g :
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            _x_2
            _x_3),
          @funext.{v₁+1 v₁+1}
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C _x)
               _x_1)
            (λ
             (x :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C _x)
                 _x_1),
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C _x)
                 _x_3)
            (λ
             (g_1 :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C _x)
                 _x_1),
               @category_theory.category_struct.comp.{v₁ u₁} C
                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                 (@opposite.unop.{u₁+1} C _x)
                 _x_1
                 _x_3
                 g_1
                 (@category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    _x_1
                    _x_2
                    _x_3
                    f
                    g))
            (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
               (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C _x)
                  _x_1)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C _x)
                  _x_2)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C _x)
                  _x_3)
               (λ
                (g :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    _x_1),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C _x)
                    _x_1
                    _x_2
                    g
                    f)
               (λ
                (g_1 :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    _x_2),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C _x)
                    _x_2
                    _x_3
                    g_1
                    g))
            (λ
             (x :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C _x)
                 _x_1),
               @id.{0}
                 (@eq.{v₁+1}
                    (@category_theory.has_hom.hom.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       (@opposite.unop.{u₁+1} C _x)
                       _x_3)
                    (@category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       (@opposite.unop.{u₁+1} C _x)
                       _x_1
                       _x_3
                       x
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          _x_1
                          _x_2
                          _x_3
                          f
                          g))
                    (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                       (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                          category_theory.types.{v₁})
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          _x_1)
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          _x_2)
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          _x_3)
                       (λ
                        (g :
                          @category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@opposite.unop.{u₁+1} C _x)
                            _x_1),
                          @category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@opposite.unop.{u₁+1} C _x)
                            _x_1
                            _x_2
                            g
                            f)
                       (λ
                        (g_1 :
                          @category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@opposite.unop.{u₁+1} C _x)
                            _x_2),
                          @category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@opposite.unop.{u₁+1} C _x)
                            _x_2
                            _x_3
                            g_1
                            g)
                       x))
                 (@eq.mpr.{0}
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          _x_3)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C _x)
                          _x_1
                          _x_3
                          x
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             _x_1
                             _x_2
                             _x_3
                             f
                             g))
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C _x)
                          _x_2
                          _x_3
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             _x_1
                             _x_2
                             x
                             f)
                          g))
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          _x_3)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C _x)
                          _x_1
                          _x_3
                          x
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             _x_1
                             _x_2
                             _x_3
                             f
                             g))
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C _x)
                          _x_1
                          _x_3
                          x
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             _x_1
                             _x_2
                             _x_3
                             f
                             g)))
                    (@id.{0}
                       (@eq.{1} Prop
                          (@eq.{v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C _x)
                                _x_3)
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C _x)
                                _x_1
                                _x_3
                                x
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   _x_1
                                   _x_2
                                   _x_3
                                   f
                                   g))
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C _x)
                                _x_2
                                _x_3
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_1
                                   _x_2
                                   x
                                   f)
                                g))
                          (@eq.{v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C _x)
                                _x_3)
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C _x)
                                _x_1
                                _x_3
                                x
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   _x_1
                                   _x_2
                                   _x_3
                                   f
                                   g))
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C _x)
                                _x_1
                                _x_3
                                x
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   _x_1
                                   _x_2
                                   _x_3
                                   f
                                   g))))
                       (@eq.rec.{0 v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             _x_3)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             _x_2
                             _x_3
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C _x)
                                _x_1
                                _x_2
                                x
                                f)
                             g)
                          (λ
                           (_a :
                             @category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@opposite.unop.{u₁+1} C _x)
                               _x_3),
                             @eq.{1} Prop
                               (@eq.{v₁+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C _x)
                                     _x_3)
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@opposite.unop.{u₁+1} C _x)
                                     _x_1
                                     _x_3
                                     x
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        _x_1
                                        _x_2
                                        _x_3
                                        f
                                        g))
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@opposite.unop.{u₁+1} C _x)
                                     _x_2
                                     _x_3
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C _x)
                                        _x_1
                                        _x_2
                                        x
                                        f)
                                     g))
                               (@eq.{v₁+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C _x)
                                     _x_3)
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@opposite.unop.{u₁+1} C _x)
                                     _x_1
                                     _x_3
                                     x
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        _x_1
                                        _x_2
                                        _x_3
                                        f
                                        g))
                                  _a))
                          (@eq.refl.{1} Prop
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_3)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_1
                                   _x_3
                                   x
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      _x_1
                                      _x_2
                                      _x_3
                                      f
                                      g))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_2
                                   _x_3
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C _x)
                                      _x_1
                                      _x_2
                                      x
                                      f)
                                   g)))
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             _x_1
                             _x_3
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x_1
                                _x_2
                                _x_3
                                f
                                g))
                          (@category_theory.category.assoc.{v₁ u₁} C 𝒞 (@opposite.unop.{u₁+1} C _x) _x_1 _x_2
                             _x_3
                             x
                             f
                             g)))
                    (@eq.refl.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          _x_3)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C _x)
                          _x_1
                          _x_3
                          x
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             _x_1
                             _x_2
                             _x_3
                             f
                             g)))))))
    x
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@opposite.unop.{u₁+1} C _x)
       x)
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@opposite.unop.{u₁+1} C _x)
       (@opposite.unop.{u₁+1} C _x)
       x
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C _x)
          (@opposite.unop.{u₁+1} C _x)
          (@opposite.unop.{u₁+1} C _x)
          (@category_theory.has_hom.hom.unop.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             _x
             _x
             g)
          (@category_theory.has_hom.hom.unop.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             _x
             _x
             f))
       x_1)
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@opposite.unop.{u₁+1} C _x)
       (@opposite.unop.{u₁+1} C _x)
       x
       (@category_theory.has_hom.hom.unop.{v₁ u₁} C
          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
          _x
          _x
          g)
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C _x)
          (@opposite.unop.{u₁+1} C _x)
          x
          (@category_theory.has_hom.hom.unop.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             _x
             _x
             f)
          x_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
_x _x _x : opposite.{u₁+1} C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
    _x
    _x,
g :
  @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
    _x
    _x,
x : C,
x_1 :
  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
    (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
       (λ (Y : C),
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            (@opposite.unop.{u₁+1} C _x)
            Y)
       (λ (Y Y&#x27; : C)
        (f :
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            Y
            Y&#x27;)
        (g :
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            (@opposite.unop.{u₁+1} C _x)
            Y),
          @category_theory.category_struct.comp.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
            (@opposite.unop.{u₁+1} C _x)
            Y
            Y&#x27;
            g
            f)
       (λ (Y : C),
          @funext.{v₁+1 v₁+1}
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C _x)
               Y)
            (λ
             (x :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C _x)
                 Y),
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C _x)
                 Y)
            (λ
             (g :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C _x)
                 Y),
               @category_theory.category_struct.comp.{v₁ u₁} C
                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                 (@opposite.unop.{u₁+1} C _x)
                 Y
                 Y
                 g
                 (@category_theory.category_struct.id.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    Y))
            (@category_theory.category_struct.id.{v₁ v₁+1} (Type v₁)
               (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C _x)
                  Y))
            (λ
             (x :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C _x)
                 Y),
               @id.{0}
                 (@eq.{v₁+1}
                    (@category_theory.has_hom.hom.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       (@opposite.unop.{u₁+1} C _x)
                       Y)
                    (@category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       (@opposite.unop.{u₁+1} C _x)
                       Y
                       Y
                       x
                       (@category_theory.category_struct.id.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          Y))
                    (@category_theory.category_struct.id.{v₁ v₁+1} (Type v₁)
                       (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                          category_theory.types.{v₁})
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          Y)
                       x))
                 (@eq.mpr.{0}
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          Y)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C _x)
                          Y
                          Y
                          x
                          (@category_theory.category_struct.id.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             Y))
                       x)
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          Y)
                       x
                       x)
                    (@id.{0}
                       (@eq.{1} Prop
                          (@eq.{v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C _x)
                                Y)
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C _x)
                                Y
                                Y
                                x
                                (@category_theory.category_struct.id.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   Y))
                             x)
                          (@eq.{v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C _x)
                                Y)
                             x
                             x))
                       (@eq.rec.{0 v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             Y)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             Y
                             Y
                             x
                             (@category_theory.category_struct.id.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                Y))
                          (λ
                           (_a :
                             @category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@opposite.unop.{u₁+1} C _x)
                               Y),
                             @eq.{1} Prop
                               (@eq.{v₁+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C _x)
                                     Y)
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@opposite.unop.{u₁+1} C _x)
                                     Y
                                     Y
                                     x
                                     (@category_theory.category_struct.id.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        Y))
                                  x)
                               (@eq.{v₁+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C _x)
                                     Y)
                                  _a
                                  x))
                          (@eq.refl.{1} Prop
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C _x)
                                   Y)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   Y
                                   Y
                                   x
                                   (@category_theory.category_struct.id.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      Y))
                                x))
                          x
                          (@category_theory.category.comp_id.{v₁ u₁} C 𝒞 (@opposite.unop.{u₁+1} C _x) Y x)))
                    (@eq.refl.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          Y)
                       x))))
       (λ (_x_1 _x_2 _x_3 : C)
        (f :
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            _x_1
            _x_2)
        (g :
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            _x_2
            _x_3),
          @funext.{v₁+1 v₁+1}
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C _x)
               _x_1)
            (λ
             (x :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C _x)
                 _x_1),
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C _x)
                 _x_3)
            (λ
             (g_1 :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C _x)
                 _x_1),
               @category_theory.category_struct.comp.{v₁ u₁} C
                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                 (@opposite.unop.{u₁+1} C _x)
                 _x_1
                 _x_3
                 g_1
                 (@category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    _x_1
                    _x_2
                    _x_3
                    f
                    g))
            (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
               (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C _x)
                  _x_1)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C _x)
                  _x_2)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C _x)
                  _x_3)
               (λ
                (g :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    _x_1),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C _x)
                    _x_1
                    _x_2
                    g
                    f)
               (λ
                (g_1 :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C _x)
                    _x_2),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C _x)
                    _x_2
                    _x_3
                    g_1
                    g))
            (λ
             (x :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C _x)
                 _x_1),
               @id.{0}
                 (@eq.{v₁+1}
                    (@category_theory.has_hom.hom.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       (@opposite.unop.{u₁+1} C _x)
                       _x_3)
                    (@category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       (@opposite.unop.{u₁+1} C _x)
                       _x_1
                       _x_3
                       x
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          _x_1
                          _x_2
                          _x_3
                          f
                          g))
                    (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                       (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                          category_theory.types.{v₁})
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          _x_1)
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          _x_2)
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          _x_3)
                       (λ
                        (g :
                          @category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@opposite.unop.{u₁+1} C _x)
                            _x_1),
                          @category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@opposite.unop.{u₁+1} C _x)
                            _x_1
                            _x_2
                            g
                            f)
                       (λ
                        (g_1 :
                          @category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@opposite.unop.{u₁+1} C _x)
                            _x_2),
                          @category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@opposite.unop.{u₁+1} C _x)
                            _x_2
                            _x_3
                            g_1
                            g)
                       x))
                 (@eq.mpr.{0}
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          _x_3)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C _x)
                          _x_1
                          _x_3
                          x
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             _x_1
                             _x_2
                             _x_3
                             f
                             g))
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C _x)
                          _x_2
                          _x_3
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             _x_1
                             _x_2
                             x
                             f)
                          g))
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          _x_3)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C _x)
                          _x_1
                          _x_3
                          x
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             _x_1
                             _x_2
                             _x_3
                             f
                             g))
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C _x)
                          _x_1
                          _x_3
                          x
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             _x_1
                             _x_2
                             _x_3
                             f
                             g)))
                    (@id.{0}
                       (@eq.{1} Prop
                          (@eq.{v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C _x)
                                _x_3)
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C _x)
                                _x_1
                                _x_3
                                x
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   _x_1
                                   _x_2
                                   _x_3
                                   f
                                   g))
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C _x)
                                _x_2
                                _x_3
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_1
                                   _x_2
                                   x
                                   f)
                                g))
                          (@eq.{v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C _x)
                                _x_3)
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C _x)
                                _x_1
                                _x_3
                                x
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   _x_1
                                   _x_2
                                   _x_3
                                   f
                                   g))
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C _x)
                                _x_1
                                _x_3
                                x
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   _x_1
                                   _x_2
                                   _x_3
                                   f
                                   g))))
                       (@eq.rec.{0 v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C _x)
                             _x_3)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             _x_2
                             _x_3
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C _x)
                                _x_1
                                _x_2
                                x
                                f)
                             g)
                          (λ
                           (_a :
                             @category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@opposite.unop.{u₁+1} C _x)
                               _x_3),
                             @eq.{1} Prop
                               (@eq.{v₁+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C _x)
                                     _x_3)
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@opposite.unop.{u₁+1} C _x)
                                     _x_1
                                     _x_3
                                     x
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        _x_1
                                        _x_2
                                        _x_3
                                        f
                                        g))
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@opposite.unop.{u₁+1} C _x)
                                     _x_2
                                     _x_3
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C _x)
                                        _x_1
                                        _x_2
                                        x
                                        f)
                                     g))
                               (@eq.{v₁+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C _x)
                                     _x_3)
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@opposite.unop.{u₁+1} C _x)
                                     _x_1
                                     _x_3
                                     x
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        _x_1
                                        _x_2
                                        _x_3
                                        f
                                        g))
                                  _a))
                          (@eq.refl.{1} Prop
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_3)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_1
                                   _x_3
                                   x
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      _x_1
                                      _x_2
                                      _x_3
                                      f
                                      g))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C _x)
                                   _x_2
                                   _x_3
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C _x)
                                      _x_1
                                      _x_2
                                      x
                                      f)
                                   g)))
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C _x)
                             _x_1
                             _x_3
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x_1
                                _x_2
                                _x_3
                                f
                                g))
                          (@category_theory.category.assoc.{v₁ u₁} C 𝒞 (@opposite.unop.{u₁+1} C _x) _x_1 _x_2
                             _x_3
                             x
                             f
                             g)))
                    (@eq.refl.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C _x)
                          _x_3)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C _x)
                          _x_1
                          _x_3
                          x
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             _x_1
                             _x_2
                             _x_3
                             f
                             g)))))))
    x
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@opposite.unop.{u₁+1} C _x)
       x)
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@opposite.unop.{u₁+1} C _x)
       (@opposite.unop.{u₁+1} C _x)
       x
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C _x)
          (@opposite.unop.{u₁+1} C _x)
          (@opposite.unop.{u₁+1} C _x)
          (@category_theory.has_hom.hom.unop.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             _x
             _x
             g)
          (@category_theory.has_hom.hom.unop.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             _x
             _x
             f))
       x_1)
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@opposite.unop.{u₁+1} C _x)
       (@opposite.unop.{u₁+1} C _x)
       x
       (@category_theory.has_hom.hom.unop.{v₁ u₁} C
          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
          _x
          _x
          g)
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C _x)
          (@opposite.unop.{u₁+1} C _x)
          x
          (@category_theory.has_hom.hom.unop.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             _x
             _x
             f)
          x_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42    map_id&#x27; := λ X, begin ext, dsimp, erw [category.id_comp] end }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='category_theory.category.id_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='opposite.{u₁+1} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₁) [c : category_theory.category.{v₁ u₁} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) X X Y (@category_theory.category_struct.id.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) X) f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X : opposite.{u₁+1} C
⊢ @eq.{(max u₁ v₁)+1}
    (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁)
                category_theory.types.{v₁})))
       (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
          (λ (Y : C),
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C X)
               Y)
          (λ (Y Y&#x27; : C)
           (f :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               Y
               Y&#x27;)
           (g :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C X)
               Y),
             @category_theory.category_struct.comp.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               (@opposite.unop.{u₁+1} C X)
               Y
               Y&#x27;
               g
               f)
          (λ (Y : C),
             @funext.{v₁+1 v₁+1}
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C X)
                  Y)
               (λ
                (x :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    Y),
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    Y)
               (λ
                (g :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    Y),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C X)
                    Y
                    Y
                    g
                    (@category_theory.category_struct.id.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       Y))
               (@category_theory.category_struct.id.{v₁ v₁+1} (Type v₁)
                  (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@opposite.unop.{u₁+1} C X)
                     Y))
               (λ
                (x :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    Y),
                  @id.{0}
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          Y)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C X)
                          Y
                          Y
                          x
                          (@category_theory.category_struct.id.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             Y))
                       (@category_theory.category_struct.id.{v₁ v₁+1} (Type v₁)
                          (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             Y)
                          x))
                    (@eq.mpr.{0}
                       (@eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             Y)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             Y
                             Y
                             x
                             (@category_theory.category_struct.id.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                Y))
                          x)
                       (@eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             Y)
                          x
                          x)
                       (@id.{0}
                          (@eq.{1} Prop
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C X)
                                   Y)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   Y
                                   Y
                                   x
                                   (@category_theory.category_struct.id.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      Y))
                                x)
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C X)
                                   Y)
                                x
                                x))
                          (@eq.rec.{0 v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C X)
                                Y)
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C X)
                                Y
                                Y
                                x
                                (@category_theory.category_struct.id.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   Y))
                             (λ
                              (_a :
                                @category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@opposite.unop.{u₁+1} C X)
                                  Y),
                                @eq.{1} Prop
                                  (@eq.{v₁+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C X)
                                        Y)
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C X)
                                        Y
                                        Y
                                        x
                                        (@category_theory.category_struct.id.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           Y))
                                     x)
                                  (@eq.{v₁+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C X)
                                        Y)
                                     _a
                                     x))
                             (@eq.refl.{1} Prop
                                (@eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      (@opposite.unop.{u₁+1} C X)
                                      Y)
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C X)
                                      Y
                                      Y
                                      x
                                      (@category_theory.category_struct.id.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         Y))
                                   x))
                             x
                             (@category_theory.category.comp_id.{v₁ u₁} C 𝒞 (@opposite.unop.{u₁+1} C X) Y x)))
                       (@eq.refl.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             Y)
                          x))))
          (λ (_x _x_1 _x_2 : C)
           (f :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               _x
               _x_1)
           (g :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               _x_1
               _x_2),
             @funext.{v₁+1 v₁+1}
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C X)
                  _x)
               (λ
                (x :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    _x),
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    _x_2)
               (λ
                (g_1 :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    _x),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C X)
                    _x
                    _x_2
                    g_1
                    (@category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       _x
                       _x_1
                       _x_2
                       f
                       g))
               (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                  (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@opposite.unop.{u₁+1} C X)
                     _x)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@opposite.unop.{u₁+1} C X)
                     _x_1)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@opposite.unop.{u₁+1} C X)
                     _x_2)
                  (λ
                   (g :
                     @category_theory.has_hom.hom.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       (@opposite.unop.{u₁+1} C X)
                       _x),
                     @category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       (@opposite.unop.{u₁+1} C X)
                       _x
                       _x_1
                       g
                       f)
                  (λ
                   (g_1 :
                     @category_theory.has_hom.hom.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       (@opposite.unop.{u₁+1} C X)
                       _x_1),
                     @category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       (@opposite.unop.{u₁+1} C X)
                       _x_1
                       _x_2
                       g_1
                       g))
               (λ
                (x :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    _x),
                  @id.{0}
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          _x_2)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C X)
                          _x
                          _x_2
                          x
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             _x
                             _x_1
                             _x_2
                             f
                             g))
                       (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                          (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             _x)
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             _x_1)
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             _x_2)
                          (λ
                           (g :
                             @category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@opposite.unop.{u₁+1} C X)
                               _x),
                             @category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@opposite.unop.{u₁+1} C X)
                               _x
                               _x_1
                               g
                               f)
                          (λ
                           (g_1 :
                             @category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@opposite.unop.{u₁+1} C X)
                               _x_1),
                             @category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@opposite.unop.{u₁+1} C X)
                               _x_1
                               _x_2
                               g_1
                               g)
                          x))
                    (@eq.mpr.{0}
                       (@eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             _x_2)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             _x
                             _x_2
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x
                                _x_1
                                _x_2
                                f
                                g))
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             _x_1
                             _x_2
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C X)
                                _x
                                _x_1
                                x
                                f)
                             g))
                       (@eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             _x_2)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             _x
                             _x_2
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x
                                _x_1
                                _x_2
                                f
                                g))
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             _x
                             _x_2
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x
                                _x_1
                                _x_2
                                f
                                g)))
                       (@id.{0}
                          (@eq.{1} Prop
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C X)
                                   _x_2)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   _x
                                   _x_2
                                   x
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      _x
                                      _x_1
                                      _x_2
                                      f
                                      g))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   _x_1
                                   _x_2
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C X)
                                      _x
                                      _x_1
                                      x
                                      f)
                                   g))
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C X)
                                   _x_2)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   _x
                                   _x_2
                                   x
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      _x
                                      _x_1
                                      _x_2
                                      f
                                      g))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   _x
                                   _x_2
                                   x
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      _x
                                      _x_1
                                      _x_2
                                      f
                                      g))))
                          (@eq.rec.{0 v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C X)
                                _x_2)
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C X)
                                _x_1
                                _x_2
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   _x
                                   _x_1
                                   x
                                   f)
                                g)
                             (λ
                              (_a :
                                @category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@opposite.unop.{u₁+1} C X)
                                  _x_2),
                                @eq.{1} Prop
                                  (@eq.{v₁+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C X)
                                        _x_2)
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C X)
                                        _x
                                        _x_2
                                        x
                                        (@category_theory.category_struct.comp.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           _x
                                           _x_1
                                           _x_2
                                           f
                                           g))
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C X)
                                        _x_1
                                        _x_2
                                        (@category_theory.category_struct.comp.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           (@opposite.unop.{u₁+1} C X)
                                           _x
                                           _x_1
                                           x
                                           f)
                                        g))
                                  (@eq.{v₁+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C X)
                                        _x_2)
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C X)
                                        _x
                                        _x_2
                                        x
                                        (@category_theory.category_struct.comp.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           _x
                                           _x_1
                                           _x_2
                                           f
                                           g))
                                     _a))
                             (@eq.refl.{1} Prop
                                (@eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      (@opposite.unop.{u₁+1} C X)
                                      _x_2)
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C X)
                                      _x
                                      _x_2
                                      x
                                      (@category_theory.category_struct.comp.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         _x
                                         _x_1
                                         _x_2
                                         f
                                         g))
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C X)
                                      _x_1
                                      _x_2
                                      (@category_theory.category_struct.comp.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         (@opposite.unop.{u₁+1} C X)
                                         _x
                                         _x_1
                                         x
                                         f)
                                      g)))
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C X)
                                _x
                                _x_2
                                x
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   _x
                                   _x_1
                                   _x_2
                                   f
                                   g))
                             (@category_theory.category.assoc.{v₁ u₁} C 𝒞 (@opposite.unop.{u₁+1} C X) _x _x_1
                                _x_2
                                x
                                f
                                g)))
                       (@eq.refl.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             _x_2)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             _x
                             _x_2
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x
                                _x_1
                                _x_2
                                f
                                g)))))))
       (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
          (λ (Y : C),
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C X)
               Y)
          (λ (Y Y&#x27; : C)
           (f :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               Y
               Y&#x27;)
           (g :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C X)
               Y),
             @category_theory.category_struct.comp.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               (@opposite.unop.{u₁+1} C X)
               Y
               Y&#x27;
               g
               f)
          (λ (Y : C),
             @funext.{v₁+1 v₁+1}
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C X)
                  Y)
               (λ
                (x :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    Y),
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    Y)
               (λ
                (g :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    Y),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C X)
                    Y
                    Y
                    g
                    (@category_theory.category_struct.id.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       Y))
               (@category_theory.category_struct.id.{v₁ v₁+1} (Type v₁)
                  (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@opposite.unop.{u₁+1} C X)
                     Y))
               (λ
                (x :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    Y),
                  @id.{0}
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          Y)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C X)
                          Y
                          Y
                          x
                          (@category_theory.category_struct.id.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             Y))
                       (@category_theory.category_struct.id.{v₁ v₁+1} (Type v₁)
                          (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             Y)
                          x))
                    (@eq.mpr.{0}
                       (@eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             Y)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             Y
                             Y
                             x
                             (@category_theory.category_struct.id.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                Y))
                          x)
                       (@eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             Y)
                          x
                          x)
                       (@id.{0}
                          (@eq.{1} Prop
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C X)
                                   Y)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   Y
                                   Y
                                   x
                                   (@category_theory.category_struct.id.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      Y))
                                x)
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C X)
                                   Y)
                                x
                                x))
                          (@eq.rec.{0 v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C X)
                                Y)
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C X)
                                Y
                                Y
                                x
                                (@category_theory.category_struct.id.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   Y))
                             (λ
                              (_a :
                                @category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@opposite.unop.{u₁+1} C X)
                                  Y),
                                @eq.{1} Prop
                                  (@eq.{v₁+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C X)
                                        Y)
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C X)
                                        Y
                                        Y
                                        x
                                        (@category_theory.category_struct.id.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           Y))
                                     x)
                                  (@eq.{v₁+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C X)
                                        Y)
                                     _a
                                     x))
                             (@eq.refl.{1} Prop
                                (@eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      (@opposite.unop.{u₁+1} C X)
                                      Y)
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C X)
                                      Y
                                      Y
                                      x
                                      (@category_theory.category_struct.id.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         Y))
                                   x))
                             x
                             (@category_theory.category.comp_id.{v₁ u₁} C 𝒞 (@opposite.unop.{u₁+1} C X) Y x)))
                       (@eq.refl.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             Y)
                          x))))
          (λ (_x _x_1 _x_2 : C)
           (f :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               _x
               _x_1)
           (g :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               _x_1
               _x_2),
             @funext.{v₁+1 v₁+1}
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C X)
                  _x)
               (λ
                (x :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    _x),
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    _x_2)
               (λ
                (g_1 :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    _x),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C X)
                    _x
                    _x_2
                    g_1
                    (@category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       _x
                       _x_1
                       _x_2
                       f
                       g))
               (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                  (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@opposite.unop.{u₁+1} C X)
                     _x)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@opposite.unop.{u₁+1} C X)
                     _x_1)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@opposite.unop.{u₁+1} C X)
                     _x_2)
                  (λ
                   (g :
                     @category_theory.has_hom.hom.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       (@opposite.unop.{u₁+1} C X)
                       _x),
                     @category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       (@opposite.unop.{u₁+1} C X)
                       _x
                       _x_1
                       g
                       f)
                  (λ
                   (g_1 :
                     @category_theory.has_hom.hom.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       (@opposite.unop.{u₁+1} C X)
                       _x_1),
                     @category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       (@opposite.unop.{u₁+1} C X)
                       _x_1
                       _x_2
                       g_1
                       g))
               (λ
                (x :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    _x),
                  @id.{0}
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          _x_2)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C X)
                          _x
                          _x_2
                          x
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             _x
                             _x_1
                             _x_2
                             f
                             g))
                       (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                          (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             _x)
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             _x_1)
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             _x_2)
                          (λ
                           (g :
                             @category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@opposite.unop.{u₁+1} C X)
                               _x),
                             @category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@opposite.unop.{u₁+1} C X)
                               _x
                               _x_1
                               g
                               f)
                          (λ
                           (g_1 :
                             @category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@opposite.unop.{u₁+1} C X)
                               _x_1),
                             @category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@opposite.unop.{u₁+1} C X)
                               _x_1
                               _x_2
                               g_1
                               g)
                          x))
                    (@eq.mpr.{0}
                       (@eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             _x_2)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             _x
                             _x_2
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x
                                _x_1
                                _x_2
                                f
                                g))
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             _x_1
                             _x_2
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C X)
                                _x
                                _x_1
                                x
                                f)
                             g))
                       (@eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             _x_2)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             _x
                             _x_2
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x
                                _x_1
                                _x_2
                                f
                                g))
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             _x
                             _x_2
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x
                                _x_1
                                _x_2
                                f
                                g)))
                       (@id.{0}
                          (@eq.{1} Prop
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C X)
                                   _x_2)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   _x
                                   _x_2
                                   x
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      _x
                                      _x_1
                                      _x_2
                                      f
                                      g))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   _x_1
                                   _x_2
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C X)
                                      _x
                                      _x_1
                                      x
                                      f)
                                   g))
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C X)
                                   _x_2)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   _x
                                   _x_2
                                   x
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      _x
                                      _x_1
                                      _x_2
                                      f
                                      g))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   _x
                                   _x_2
                                   x
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      _x
                                      _x_1
                                      _x_2
                                      f
                                      g))))
                          (@eq.rec.{0 v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C X)
                                _x_2)
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C X)
                                _x_1
                                _x_2
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   _x
                                   _x_1
                                   x
                                   f)
                                g)
                             (λ
                              (_a :
                                @category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@opposite.unop.{u₁+1} C X)
                                  _x_2),
                                @eq.{1} Prop
                                  (@eq.{v₁+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C X)
                                        _x_2)
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C X)
                                        _x
                                        _x_2
                                        x
                                        (@category_theory.category_struct.comp.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           _x
                                           _x_1
                                           _x_2
                                           f
                                           g))
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C X)
                                        _x_1
                                        _x_2
                                        (@category_theory.category_struct.comp.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           (@opposite.unop.{u₁+1} C X)
                                           _x
                                           _x_1
                                           x
                                           f)
                                        g))
                                  (@eq.{v₁+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C X)
                                        _x_2)
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C X)
                                        _x
                                        _x_2
                                        x
                                        (@category_theory.category_struct.comp.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           _x
                                           _x_1
                                           _x_2
                                           f
                                           g))
                                     _a))
                             (@eq.refl.{1} Prop
                                (@eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      (@opposite.unop.{u₁+1} C X)
                                      _x_2)
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C X)
                                      _x
                                      _x_2
                                      x
                                      (@category_theory.category_struct.comp.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         _x
                                         _x_1
                                         _x_2
                                         f
                                         g))
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C X)
                                      _x_1
                                      _x_2
                                      (@category_theory.category_struct.comp.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         (@opposite.unop.{u₁+1} C X)
                                         _x
                                         _x_1
                                         x
                                         f)
                                      g)))
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C X)
                                _x
                                _x_2
                                x
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   _x
                                   _x_1
                                   _x_2
                                   f
                                   g))
                             (@category_theory.category.assoc.{v₁ u₁} C 𝒞 (@opposite.unop.{u₁+1} C X) _x _x_1
                                _x_2
                                x
                                f
                                g)))
                       (@eq.refl.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             _x_2)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             _x
                             _x_2
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x
                                _x_1
                                _x_2
                                f
                                g))))))))
    (@category_theory.nat_trans.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
       (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
          (λ (Y : C),
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C X)
               Y)
          (λ (Y Y&#x27; : C)
           (f :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               Y
               Y&#x27;)
           (g :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C X)
               Y),
             @category_theory.category_struct.comp.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               (@opposite.unop.{u₁+1} C X)
               Y
               Y&#x27;
               g
               f)
          (λ (Y : C),
             @funext.{v₁+1 v₁+1}
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C X)
                  Y)
               (λ (x : … … Y), …)
               …
               …
               …)
          …)
       …
       …
       …)
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X : opposite.{u₁+1} C,
x : C,
x_1 :
  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
    (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
       (λ (Y : C),
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            (@opposite.unop.{u₁+1} C X)
            Y)
       (λ (Y Y&#x27; : C)
        (f :
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            Y
            Y&#x27;)
        (g :
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            (@opposite.unop.{u₁+1} C X)
            Y),
          @category_theory.category_struct.comp.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
            (@opposite.unop.{u₁+1} C X)
            Y
            Y&#x27;
            g
            f)
       (λ (Y : C),
          @funext.{v₁+1 v₁+1}
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C X)
               Y)
            (λ
             (x :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 Y),
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 Y)
            (λ
             (g :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 Y),
               @category_theory.category_struct.comp.{v₁ u₁} C
                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                 (@opposite.unop.{u₁+1} C X)
                 Y
                 Y
                 g
                 (@category_theory.category_struct.id.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    Y))
            (@category_theory.category_struct.id.{v₁ v₁+1} (Type v₁)
               (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C X)
                  Y))
            (λ
             (x :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 Y),
               @id.{0}
                 (@eq.{v₁+1}
                    (@category_theory.has_hom.hom.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       (@opposite.unop.{u₁+1} C X)
                       Y)
                    (@category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       (@opposite.unop.{u₁+1} C X)
                       Y
                       Y
                       x
                       (@category_theory.category_struct.id.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          Y))
                    (@category_theory.category_struct.id.{v₁ v₁+1} (Type v₁)
                       (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                          category_theory.types.{v₁})
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          Y)
                       x))
                 (@eq.mpr.{0}
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          Y)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C X)
                          Y
                          Y
                          x
                          (@category_theory.category_struct.id.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             Y))
                       x)
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          Y)
                       x
                       x)
                    (@id.{0}
                       (@eq.{1} Prop
                          (@eq.{v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C X)
                                Y)
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C X)
                                Y
                                Y
                                x
                                (@category_theory.category_struct.id.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   Y))
                             x)
                          (@eq.{v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C X)
                                Y)
                             x
                             x))
                       (@eq.rec.{0 v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             Y)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             Y
                             Y
                             x
                             (@category_theory.category_struct.id.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                Y))
                          (λ
                           (_a :
                             @category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@opposite.unop.{u₁+1} C X)
                               Y),
                             @eq.{1} Prop
                               (@eq.{v₁+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C X)
                                     Y)
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@opposite.unop.{u₁+1} C X)
                                     Y
                                     Y
                                     x
                                     (@category_theory.category_struct.id.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        Y))
                                  x)
                               (@eq.{v₁+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C X)
                                     Y)
                                  _a
                                  x))
                          (@eq.refl.{1} Prop
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C X)
                                   Y)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   Y
                                   Y
                                   x
                                   (@category_theory.category_struct.id.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      Y))
                                x))
                          x
                          (@category_theory.category.comp_id.{v₁ u₁} C 𝒞 (@opposite.unop.{u₁+1} C X) Y x)))
                    (@eq.refl.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          Y)
                       x))))
       (λ (_x _x_1 _x_2 : C)
        (f :
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            _x
            _x_1)
        (g :
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            _x_1
            _x_2),
          @funext.{v₁+1 v₁+1}
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C X)
               _x)
            (λ
             (x :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 _x),
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 _x_2)
            (λ
             (g_1 :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 _x),
               @category_theory.category_struct.comp.{v₁ u₁} C
                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                 (@opposite.unop.{u₁+1} C X)
                 _x
                 _x_2
                 g_1
                 (@category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    _x
                    _x_1
                    _x_2
                    f
                    g))
            (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
               (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C X)
                  _x)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C X)
                  _x_1)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C X)
                  _x_2)
               (λ
                (g :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    _x),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C X)
                    _x
                    _x_1
                    g
                    f)
               (λ
                (g_1 :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    _x_1),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C X)
                    _x_1
                    _x_2
                    g_1
                    g))
            (λ
             (x :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 _x),
               @id.{0}
                 (@eq.{v₁+1}
                    (@category_theory.has_hom.hom.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       (@opposite.unop.{u₁+1} C X)
                       _x_2)
                    (@category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       (@opposite.unop.{u₁+1} C X)
                       _x
                       _x_2
                       x
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          _x
                          _x_1
                          _x_2
                          f
                          g))
                    (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                       (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                          category_theory.types.{v₁})
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          _x)
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          _x_1)
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          _x_2)
                       (λ
                        (g :
                          @category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@opposite.unop.{u₁+1} C X)
                            _x),
                          @category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@opposite.unop.{u₁+1} C X)
                            _x
                            _x_1
                            g
                            f)
                       (λ
                        (g_1 :
                          @category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@opposite.unop.{u₁+1} C X)
                            _x_1),
                          @category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@opposite.unop.{u₁+1} C X)
                            _x_1
                            _x_2
                            g_1
                            g)
                       x))
                 (@eq.mpr.{0}
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          _x_2)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C X)
                          _x
                          _x_2
                          x
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             _x
                             _x_1
                             _x_2
                             f
                             g))
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C X)
                          _x_1
                          _x_2
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             _x
                             _x_1
                             x
                             f)
                          g))
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          _x_2)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C X)
                          _x
                          _x_2
                          x
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             _x
                             _x_1
                             _x_2
                             f
                             g))
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C X)
                          _x
                          _x_2
                          x
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             _x
                             _x_1
                             _x_2
                             f
                             g)))
                    (@id.{0}
                       (@eq.{1} Prop
                          (@eq.{v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C X)
                                _x_2)
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C X)
                                _x
                                _x_2
                                x
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   _x
                                   _x_1
                                   _x_2
                                   f
                                   g))
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C X)
                                _x_1
                                _x_2
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   _x
                                   _x_1
                                   x
                                   f)
                                g))
                          (@eq.{v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C X)
                                _x_2)
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C X)
                                _x
                                _x_2
                                x
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   _x
                                   _x_1
                                   _x_2
                                   f
                                   g))
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C X)
                                _x
                                _x_2
                                x
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   _x
                                   _x_1
                                   _x_2
                                   f
                                   g))))
                       (@eq.rec.{0 v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             _x_2)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             _x_1
                             _x_2
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C X)
                                _x
                                _x_1
                                x
                                f)
                             g)
                          (λ
                           (_a :
                             @category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@opposite.unop.{u₁+1} C X)
                               _x_2),
                             @eq.{1} Prop
                               (@eq.{v₁+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C X)
                                     _x_2)
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@opposite.unop.{u₁+1} C X)
                                     _x
                                     _x_2
                                     x
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        _x
                                        _x_1
                                        _x_2
                                        f
                                        g))
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@opposite.unop.{u₁+1} C X)
                                     _x_1
                                     _x_2
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C X)
                                        _x
                                        _x_1
                                        x
                                        f)
                                     g))
                               (@eq.{v₁+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C X)
                                     _x_2)
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@opposite.unop.{u₁+1} C X)
                                     _x
                                     _x_2
                                     x
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        _x
                                        _x_1
                                        _x_2
                                        f
                                        g))
                                  _a))
                          (@eq.refl.{1} Prop
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C X)
                                   _x_2)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   _x
                                   _x_2
                                   x
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      _x
                                      _x_1
                                      _x_2
                                      f
                                      g))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   _x_1
                                   _x_2
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C X)
                                      _x
                                      _x_1
                                      x
                                      f)
                                   g)))
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             _x
                             _x_2
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x
                                _x_1
                                _x_2
                                f
                                g))
                          (@category_theory.category.assoc.{v₁ u₁} C 𝒞 (@opposite.unop.{u₁+1} C X) _x _x_1 _x_2
                             x
                             f
                             g)))
                    (@eq.refl.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          _x_2)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C X)
                          _x
                          _x_2
                          x
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             _x
                             _x_1
                             _x_2
                             f
                             g)))))))
    x
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
       (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
          (λ (Y : C),
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C X)
               Y)
          (λ (Y Y&#x27; : C)
           (f :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               Y
               Y&#x27;)
           (g :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C X)
               Y),
             @category_theory.category_struct.comp.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               (@opposite.unop.{u₁+1} C X)
               Y
               Y&#x27;
               g
               f)
          (λ (Y : C),
             @funext.{v₁+1 v₁+1}
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C X)
                  Y)
               (λ
                (x :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    Y),
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    Y)
               (λ
                (g :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    Y),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C X)
                    Y
                    Y
                    g
                    (@category_theory.category_struct.id.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       Y))
               (@category_theory.category_struct.id.{v₁ v₁+1} (Type v₁)
                  (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@opposite.unop.{u₁+1} C X)
                     Y))
               (λ
                (x :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    Y),
                  @id.{0}
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          Y)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C X)
                          Y
                          Y
                          x
                          (@category_theory.category_struct.id.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             Y))
                       (@category_theory.category_struct.id.{v₁ v₁+1} (Type v₁)
                          (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             Y)
                          x))
                    (@eq.mpr.{0}
                       (@eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             Y)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             Y
                             Y
                             x
                             (@category_theory.category_struct.id.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                Y))
                          x)
                       (@eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             Y)
                          x
                          x)
                       (@id.{0}
                          (@eq.{1} Prop
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C X)
                                   Y)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   Y
                                   Y
                                   x
                                   (@category_theory.category_struct.id.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      Y))
                                x)
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C X)
                                   Y)
                                x
                                x))
                          (@eq.rec.{0 v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C X)
                                Y)
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C X)
                                Y
                                Y
                                x
                                (@category_theory.category_struct.id.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   Y))
                             (λ
                              (_a :
                                @category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@opposite.unop.{u₁+1} C X)
                                  Y),
                                @eq.{1} Prop
                                  (@eq.{v₁+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C X)
                                        Y)
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C X)
                                        Y
                                        Y
                                        x
                                        (@category_theory.category_struct.id.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           Y))
                                     x)
                                  (@eq.{v₁+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C X)
                                        Y)
                                     _a
                                     x))
                             (@eq.refl.{1} Prop
                                (@eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      (@opposite.unop.{u₁+1} C X)
                                      Y)
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C X)
                                      Y
                                      Y
                                      x
                                      (@category_theory.category_struct.id.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         Y))
                                   x))
                             x
                             (@category_theory.category.comp_id.{v₁ u₁} C 𝒞 (@opposite.unop.{u₁+1} C X) Y x)))
                       (@eq.refl.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             Y)
                          x))))
          (λ (_x _x_1 _x_2 : C)
           (f :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               _x
               _x_1)
           (g :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               _x_1
               _x_2),
             @funext.{v₁+1 v₁+1}
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C X)
                  _x)
               (λ
                (x :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    _x),
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    _x_2)
               (λ
                (g_1 :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    _x),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C X)
                    _x
                    _x_2
                    g_1
                    (@category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       _x
                       _x_1
                       _x_2
                       f
                       g))
               (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                  (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@opposite.unop.{u₁+1} C X)
                     _x)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@opposite.unop.{u₁+1} C X)
                     _x_1)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@opposite.unop.{u₁+1} C X)
                     _x_2)
                  (λ
                   (g :
                     @category_theory.has_hom.hom.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       (@opposite.unop.{u₁+1} C X)
                       _x),
                     @category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       (@opposite.unop.{u₁+1} C X)
                       _x
                       _x_1
                       g
                       f)
                  (λ
                   (g_1 :
                     @category_theory.has_hom.hom.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       (@opposite.unop.{u₁+1} C X)
                       _x_1),
                     @category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       (@opposite.unop.{u₁+1} C X)
                       _x_1
                       _x_2
                       g_1
                       g))
               (λ
                (x :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    _x),
                  @id.{0}
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          _x_2)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C X)
                          _x
                          _x_2
                          x
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             _x
                             _x_1
                             _x_2
                             f
                             g))
                       (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                          (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             _x)
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             _x_1)
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             _x_2)
                          (λ
                           (g :
                             @category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@opposite.unop.{u₁+1} C X)
                               _x),
                             @category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@opposite.unop.{u₁+1} C X)
                               _x
                               _x_1
                               g
                               f)
                          (λ
                           (g_1 :
                             @category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@opposite.unop.{u₁+1} C X)
                               _x_1),
                             @category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@opposite.unop.{u₁+1} C X)
                               _x_1
                               _x_2
                               g_1
                               g)
                          x))
                    (@eq.mpr.{0}
                       (@eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             _x_2)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             _x
                             _x_2
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x
                                _x_1
                                _x_2
                                f
                                g))
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             _x_1
                             _x_2
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C X)
                                _x
                                _x_1
                                x
                                f)
                             g))
                       (@eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             _x_2)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             _x
                             _x_2
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x
                                _x_1
                                _x_2
                                f
                                g))
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             _x
                             _x_2
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x
                                _x_1
                                _x_2
                                f
                                g)))
                       (@id.{0}
                          (@eq.{1} Prop
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C X)
                                   _x_2)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   _x
                                   _x_2
                                   x
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      _x
                                      _x_1
                                      _x_2
                                      f
                                      g))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   _x_1
                                   _x_2
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C X)
                                      _x
                                      _x_1
                                      x
                                      f)
                                   g))
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C X)
                                   _x_2)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   _x
                                   _x_2
                                   x
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      _x
                                      _x_1
                                      _x_2
                                      f
                                      g))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   _x
                                   _x_2
                                   x
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      _x
                                      _x_1
                                      _x_2
                                      f
                                      g))))
                          (@eq.rec.{0 v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C X)
                                _x_2)
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C X)
                                _x_1
                                _x_2
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   _x
                                   _x_1
                                   x
                                   f)
                                g)
                             (λ
                              (_a :
                                @category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@opposite.unop.{u₁+1} C X)
                                  _x_2),
                                @eq.{1} Prop
                                  (@eq.{v₁+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C X)
                                        _x_2)
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C X)
                                        _x
                                        _x_2
                                        x
                                        (@category_theory.category_struct.comp.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           _x
                                           _x_1
                                           _x_2
                                           f
                                           g))
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C X)
                                        _x_1
                                        _x_2
                                        (@category_theory.category_struct.comp.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           (@opposite.unop.{u₁+1} C X)
                                           _x
                                           _x_1
                                           x
                                           f)
                                        g))
                                  (@eq.{v₁+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C X)
                                        _x_2)
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C X)
                                        _x
                                        _x_2
                                        x
                                        (@category_theory.category_struct.comp.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           _x
                                           _x_1
                                           _x_2
                                           f
                                           g))
                                     _a))
                             (@eq.refl.{1} Prop
                                (@eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      (@opposite.unop.{u₁+1} C X)
                                      _x_2)
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C X)
                                      _x
                                      _x_2
                                      x
                                      (@category_theory.category_struct.comp.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         _x
                                         _x_1
                                         _x_2
                                         f
                                         g))
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C X)
                                      _x_1
                                      _x_2
                                      (@category_theory.category_struct.comp.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         (@opposite.unop.{u₁+1} C X)
                                         _x
                                         _x_1
                                         x
                                         f)
                                      g)))
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C X)
                                _x
                                _x_2
                                x
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   _x
                                   _x_1
                                   _x_2
                                   f
                                   g))
                             (@category_theory.category.assoc.{v₁ u₁} C 𝒞 (@opposite.unop.{u₁+1} C X) _x _x_1
                                _x_2
                                x
                                f
                                g)))
                       (@eq.refl.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             _x_2)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             _x
                             _x_2
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x
                                _x_1
                                _x_2
                                f
                                g)))))))
       x)
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
       (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
          (λ (Y : C),
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C X)
               Y)
          (λ (Y Y&#x27; : C)
           (f :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               Y
               Y&#x27;)
           (g :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C X)
               Y),
             @category_theory.category_struct.comp.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               (@opposite.unop.{u₁+1} C X)
               Y
               Y&#x27;
               g
               f)
          (λ (Y : C),
             @funext.{v₁+1 v₁+1}
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C X)
                  Y)
               (λ
                (x :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    Y),
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    Y)
               (λ
                (g :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    Y),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C X)
                    Y
                    Y
                    g
                    (@category_theory.category_struct.id.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       Y))
               (@category_theory.category_struct.id.{v₁ v₁+1} (Type v₁)
                  (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@opposite.unop.{u₁+1} C X)
                     Y))
               (λ
                (x :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    Y),
                  @id.{0}
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          Y)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C X)
                          Y
                          Y
                          x
                          (@category_theory.category_struct.id.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             Y))
                       (@category_theory.category_struct.id.{v₁ v₁+1} (Type v₁)
                          (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             Y)
                          x))
                    (@eq.mpr.{0}
                       (@eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             Y)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             Y
                             Y
                             x
                             (@category_theory.category_struct.id.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                Y))
                          x)
                       (@eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             Y)
                          x
                          x)
                       (@id.{0}
                          (@eq.{1} Prop
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C X)
                                   Y)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   Y
                                   Y
                                   x
                                   (@category_theory.category_struct.id.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      Y))
                                x)
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C X)
                                   Y)
                                x
                                x))
                          (@eq.rec.{0 v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C X)
                                Y)
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C X)
                                Y
                                Y
                                x
                                (@category_theory.category_struct.id.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   Y))
                             (λ
                              (_a :
                                @category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@opposite.unop.{u₁+1} C X)
                                  Y),
                                @eq.{1} Prop
                                  (@eq.{v₁+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C X)
                                        Y)
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C X)
                                        Y
                                        Y
                                        x
                                        (@category_theory.category_struct.id.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           Y))
                                     x)
                                  (@eq.{v₁+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C X)
                                        Y)
                                     _a
                                     x))
                             (@eq.refl.{1} Prop
                                (@eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      (@opposite.unop.{u₁+1} C X)
                                      Y)
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C X)
                                      Y
                                      Y
                                      x
                                      (@category_theory.category_struct.id.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         Y))
                                   x))
                             x
                             (@category_theory.category.comp_id.{v₁ u₁} C 𝒞 (@opposite.unop.{u₁+1} C X) Y x)))
                       (@eq.refl.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             Y)
                          x))))
          (λ (_x _x_1 _x_2 : C)
           (f :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               _x
               _x_1)
           (g :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               _x_1
               _x_2),
             @funext.{v₁+1 v₁+1}
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C X)
                  _x)
               (λ
                (x :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    _x),
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    _x_2)
               (λ
                (g_1 :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    _x),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C X)
                    _x
                    _x_2
                    g_1
                    (@category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       _x
                       _x_1
                       _x_2
                       f
                       g))
               (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                  (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@opposite.unop.{u₁+1} C X)
                     _x)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@opposite.unop.{u₁+1} C X)
                     _x_1)
                  (@category_theory.has_hom.hom.{v₁ u₁} C
                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                     (@opposite.unop.{u₁+1} C X)
                     _x_2)
                  (λ
                   (g :
                     @category_theory.has_hom.hom.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       (@opposite.unop.{u₁+1} C X)
                       _x),
                     @category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       (@opposite.unop.{u₁+1} C X)
                       _x
                       _x_1
                       g
                       f)
                  (λ
                   (g_1 :
                     @category_theory.has_hom.hom.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       (@opposite.unop.{u₁+1} C X)
                       _x_1),
                     @category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       (@opposite.unop.{u₁+1} C X)
                       _x_1
                       _x_2
                       g_1
                       g))
               (λ
                (x :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    _x),
                  @id.{0}
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          _x_2)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C X)
                          _x
                          _x_2
                          x
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             _x
                             _x_1
                             _x_2
                             f
                             g))
                       (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                          (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             _x)
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             _x_1)
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             _x_2)
                          (λ
                           (g :
                             @category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@opposite.unop.{u₁+1} C X)
                               _x),
                             @category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@opposite.unop.{u₁+1} C X)
                               _x
                               _x_1
                               g
                               f)
                          (λ
                           (g_1 :
                             @category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@opposite.unop.{u₁+1} C X)
                               _x_1),
                             @category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               (@opposite.unop.{u₁+1} C X)
                               _x_1
                               _x_2
                               g_1
                               g)
                          x))
                    (@eq.mpr.{0}
                       (@eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             _x_2)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             _x
                             _x_2
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x
                                _x_1
                                _x_2
                                f
                                g))
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             _x_1
                             _x_2
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C X)
                                _x
                                _x_1
                                x
                                f)
                             g))
                       (@eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             _x_2)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             _x
                             _x_2
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x
                                _x_1
                                _x_2
                                f
                                g))
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             _x
                             _x_2
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x
                                _x_1
                                _x_2
                                f
                                g)))
                       (@id.{0}
                          (@eq.{1} Prop
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C X)
                                   _x_2)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   _x
                                   _x_2
                                   x
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      _x
                                      _x_1
                                      _x_2
                                      f
                                      g))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   _x_1
                                   _x_2
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C X)
                                      _x
                                      _x_1
                                      x
                                      f)
                                   g))
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C X)
                                   _x_2)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   _x
                                   _x_2
                                   x
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      _x
                                      _x_1
                                      _x_2
                                      f
                                      g))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   _x
                                   _x_2
                                   x
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      _x
                                      _x_1
                                      _x_2
                                      f
                                      g))))
                          (@eq.rec.{0 v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C X)
                                _x_2)
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C X)
                                _x_1
                                _x_2
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   _x
                                   _x_1
                                   x
                                   f)
                                g)
                             (λ
                              (_a :
                                @category_theory.has_hom.hom.{v₁ u₁} C
                                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                  (@opposite.unop.{u₁+1} C X)
                                  _x_2),
                                @eq.{1} Prop
                                  (@eq.{v₁+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C X)
                                        _x_2)
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C X)
                                        _x
                                        _x_2
                                        x
                                        (@category_theory.category_struct.comp.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           _x
                                           _x_1
                                           _x_2
                                           f
                                           g))
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C X)
                                        _x_1
                                        _x_2
                                        (@category_theory.category_struct.comp.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           (@opposite.unop.{u₁+1} C X)
                                           _x
                                           _x_1
                                           x
                                           f)
                                        g))
                                  (@eq.{v₁+1}
                                     (@category_theory.has_hom.hom.{v₁ u₁} C
                                        (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                        (@opposite.unop.{u₁+1} C X)
                                        _x_2)
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C X)
                                        _x
                                        _x_2
                                        x
                                        (@category_theory.category_struct.comp.{v₁ u₁} C
                                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                           _x
                                           _x_1
                                           _x_2
                                           f
                                           g))
                                     _a))
                             (@eq.refl.{1} Prop
                                (@eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      (@opposite.unop.{u₁+1} C X)
                                      _x_2)
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C X)
                                      _x
                                      _x_2
                                      x
                                      (@category_theory.category_struct.comp.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         _x
                                         _x_1
                                         _x_2
                                         f
                                         g))
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C X)
                                      _x_1
                                      _x_2
                                      (@category_theory.category_struct.comp.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         (@opposite.unop.{u₁+1} C X)
                                         _x
                                         _x_1
                                         x
                                         f)
                                      g)))
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C X)
                                _x
                                _x_2
                                x
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   _x
                                   _x_1
                                   _x_2
                                   f
                                   g))
                             (@category_theory.category.assoc.{v₁ u₁} C 𝒞 (@opposite.unop.{u₁+1} C X) _x _x_1
                                _x_2
                                x
                                f
                                g)))
                       (@eq.refl.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             _x_2)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             _x
                             _x_2
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x
                                _x_1
                                _x_2
                                f
                                g)))))))
       (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
          (λ (Y : C),
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C X)
               Y)
          (λ (Y Y&#x27; : C)
           (f :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               Y
               Y&#x27;)
           (g :
             @category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C X)
               Y),
             @category_theory.category_struct.comp.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
               (@opposite.unop.{u₁+1} C X)
               Y
               Y&#x27;
               g
               f)
          (λ (Y : C),
             @funext.{v₁+1 v₁+1}
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C X)
                  Y)
               (λ
                (x :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    Y),
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    …
                    Y)
               …
               …
               …)
          …)
       …
       x
       x_1)
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X : opposite.{u₁+1} C,
x : C,
x_1 :
  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
    (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
       (λ (Y : C),
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            (@opposite.unop.{u₁+1} C X)
            Y)
       (λ (Y Y&#x27; : C)
        (f :
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            Y
            Y&#x27;)
        (g :
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            (@opposite.unop.{u₁+1} C X)
            Y),
          @category_theory.category_struct.comp.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
            (@opposite.unop.{u₁+1} C X)
            Y
            Y&#x27;
            g
            f)
       (λ (Y : C),
          @funext.{v₁+1 v₁+1}
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C X)
               Y)
            (λ
             (x :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 Y),
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 Y)
            (λ
             (g :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 Y),
               @category_theory.category_struct.comp.{v₁ u₁} C
                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                 (@opposite.unop.{u₁+1} C X)
                 Y
                 Y
                 g
                 (@category_theory.category_struct.id.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    Y))
            (@category_theory.category_struct.id.{v₁ v₁+1} (Type v₁)
               (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C X)
                  Y))
            (λ
             (x :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 Y),
               @id.{0}
                 (@eq.{v₁+1}
                    (@category_theory.has_hom.hom.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       (@opposite.unop.{u₁+1} C X)
                       Y)
                    (@category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       (@opposite.unop.{u₁+1} C X)
                       Y
                       Y
                       x
                       (@category_theory.category_struct.id.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          Y))
                    (@category_theory.category_struct.id.{v₁ v₁+1} (Type v₁)
                       (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                          category_theory.types.{v₁})
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          Y)
                       x))
                 (@eq.mpr.{0}
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          Y)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C X)
                          Y
                          Y
                          x
                          (@category_theory.category_struct.id.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             Y))
                       x)
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          Y)
                       x
                       x)
                    (@id.{0}
                       (@eq.{1} Prop
                          (@eq.{v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C X)
                                Y)
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C X)
                                Y
                                Y
                                x
                                (@category_theory.category_struct.id.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   Y))
                             x)
                          (@eq.{v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C X)
                                Y)
                             x
                             x))
                       (@eq.rec.{0 v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             Y)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             Y
                             Y
                             x
                             (@category_theory.category_struct.id.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                Y))
                          (λ
                           (_a :
                             @category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@opposite.unop.{u₁+1} C X)
                               Y),
                             @eq.{1} Prop
                               (@eq.{v₁+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C X)
                                     Y)
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@opposite.unop.{u₁+1} C X)
                                     Y
                                     Y
                                     x
                                     (@category_theory.category_struct.id.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        Y))
                                  x)
                               (@eq.{v₁+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C X)
                                     Y)
                                  _a
                                  x))
                          (@eq.refl.{1} Prop
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C X)
                                   Y)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   Y
                                   Y
                                   x
                                   (@category_theory.category_struct.id.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      Y))
                                x))
                          x
                          (@category_theory.category.comp_id.{v₁ u₁} C 𝒞 (@opposite.unop.{u₁+1} C X) Y x)))
                    (@eq.refl.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          Y)
                       x))))
       (λ (_x _x_1 _x_2 : C)
        (f :
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            _x
            _x_1)
        (g :
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            _x_1
            _x_2),
          @funext.{v₁+1 v₁+1}
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C X)
               _x)
            (λ
             (x :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 _x),
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 _x_2)
            (λ
             (g_1 :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 _x),
               @category_theory.category_struct.comp.{v₁ u₁} C
                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                 (@opposite.unop.{u₁+1} C X)
                 _x
                 _x_2
                 g_1
                 (@category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    _x
                    _x_1
                    _x_2
                    f
                    g))
            (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
               (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C X)
                  _x)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C X)
                  _x_1)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C X)
                  _x_2)
               (λ
                (g :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    _x),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C X)
                    _x
                    _x_1
                    g
                    f)
               (λ
                (g_1 :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    _x_1),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C X)
                    _x_1
                    _x_2
                    g_1
                    g))
            (λ
             (x :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 _x),
               @id.{0}
                 (@eq.{v₁+1}
                    (@category_theory.has_hom.hom.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       (@opposite.unop.{u₁+1} C X)
                       _x_2)
                    (@category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       (@opposite.unop.{u₁+1} C X)
                       _x
                       _x_2
                       x
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          _x
                          _x_1
                          _x_2
                          f
                          g))
                    (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                       (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                          category_theory.types.{v₁})
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          _x)
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          _x_1)
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          _x_2)
                       (λ
                        (g :
                          @category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@opposite.unop.{u₁+1} C X)
                            _x),
                          @category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@opposite.unop.{u₁+1} C X)
                            _x
                            _x_1
                            g
                            f)
                       (λ
                        (g_1 :
                          @category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@opposite.unop.{u₁+1} C X)
                            _x_1),
                          @category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@opposite.unop.{u₁+1} C X)
                            _x_1
                            _x_2
                            g_1
                            g)
                       x))
                 (@eq.mpr.{0}
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          _x_2)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C X)
                          _x
                          _x_2
                          x
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             _x
                             _x_1
                             _x_2
                             f
                             g))
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C X)
                          _x_1
                          _x_2
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             _x
                             _x_1
                             x
                             f)
                          g))
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          _x_2)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C X)
                          _x
                          _x_2
                          x
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             _x
                             _x_1
                             _x_2
                             f
                             g))
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C X)
                          _x
                          _x_2
                          x
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             _x
                             _x_1
                             _x_2
                             f
                             g)))
                    (@id.{0}
                       (@eq.{1} Prop
                          (@eq.{v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C X)
                                _x_2)
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C X)
                                _x
                                _x_2
                                x
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   _x
                                   _x_1
                                   _x_2
                                   f
                                   g))
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C X)
                                _x_1
                                _x_2
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   _x
                                   _x_1
                                   x
                                   f)
                                g))
                          (@eq.{v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C X)
                                _x_2)
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C X)
                                _x
                                _x_2
                                x
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   _x
                                   _x_1
                                   _x_2
                                   f
                                   g))
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C X)
                                _x
                                _x_2
                                x
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   _x
                                   _x_1
                                   _x_2
                                   f
                                   g))))
                       (@eq.rec.{0 v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             _x_2)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             _x_1
                             _x_2
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C X)
                                _x
                                _x_1
                                x
                                f)
                             g)
                          (λ
                           (_a :
                             @category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@opposite.unop.{u₁+1} C X)
                               _x_2),
                             @eq.{1} Prop
                               (@eq.{v₁+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C X)
                                     _x_2)
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@opposite.unop.{u₁+1} C X)
                                     _x
                                     _x_2
                                     x
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        _x
                                        _x_1
                                        _x_2
                                        f
                                        g))
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@opposite.unop.{u₁+1} C X)
                                     _x_1
                                     _x_2
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C X)
                                        _x
                                        _x_1
                                        x
                                        f)
                                     g))
                               (@eq.{v₁+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C X)
                                     _x_2)
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@opposite.unop.{u₁+1} C X)
                                     _x
                                     _x_2
                                     x
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        _x
                                        _x_1
                                        _x_2
                                        f
                                        g))
                                  _a))
                          (@eq.refl.{1} Prop
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C X)
                                   _x_2)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   _x
                                   _x_2
                                   x
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      _x
                                      _x_1
                                      _x_2
                                      f
                                      g))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   _x_1
                                   _x_2
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C X)
                                      _x
                                      _x_1
                                      x
                                      f)
                                   g)))
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             _x
                             _x_2
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x
                                _x_1
                                _x_2
                                f
                                g))
                          (@category_theory.category.assoc.{v₁ u₁} C 𝒞 (@opposite.unop.{u₁+1} C X) _x _x_1 _x_2
                             x
                             f
                             g)))
                    (@eq.refl.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          _x_2)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C X)
                          _x
                          _x_2
                          x
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             _x
                             _x_1
                             _x_2
                             f
                             g)))))))
    x
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@opposite.unop.{u₁+1} C X)
       x)
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@opposite.unop.{u₁+1} C X)
       (@opposite.unop.{u₁+1} C X)
       x
       (@category_theory.category_struct.id.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C X))
       x_1)
    x_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X : opposite.{u₁+1} C,
x : C,
x_1 :
  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
    (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
       (λ (Y : C),
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            (@opposite.unop.{u₁+1} C X)
            Y)
       (λ (Y Y&#x27; : C)
        (f :
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            Y
            Y&#x27;)
        (g :
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            (@opposite.unop.{u₁+1} C X)
            Y),
          @category_theory.category_struct.comp.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
            (@opposite.unop.{u₁+1} C X)
            Y
            Y&#x27;
            g
            f)
       (λ (Y : C),
          @funext.{v₁+1 v₁+1}
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C X)
               Y)
            (λ
             (x :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 Y),
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 Y)
            (λ
             (g :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 Y),
               @category_theory.category_struct.comp.{v₁ u₁} C
                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                 (@opposite.unop.{u₁+1} C X)
                 Y
                 Y
                 g
                 (@category_theory.category_struct.id.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    Y))
            (@category_theory.category_struct.id.{v₁ v₁+1} (Type v₁)
               (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C X)
                  Y))
            (λ
             (x :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 Y),
               @id.{0}
                 (@eq.{v₁+1}
                    (@category_theory.has_hom.hom.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       (@opposite.unop.{u₁+1} C X)
                       Y)
                    (@category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       (@opposite.unop.{u₁+1} C X)
                       Y
                       Y
                       x
                       (@category_theory.category_struct.id.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          Y))
                    (@category_theory.category_struct.id.{v₁ v₁+1} (Type v₁)
                       (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                          category_theory.types.{v₁})
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          Y)
                       x))
                 (@eq.mpr.{0}
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          Y)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C X)
                          Y
                          Y
                          x
                          (@category_theory.category_struct.id.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             Y))
                       x)
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          Y)
                       x
                       x)
                    (@id.{0}
                       (@eq.{1} Prop
                          (@eq.{v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C X)
                                Y)
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C X)
                                Y
                                Y
                                x
                                (@category_theory.category_struct.id.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   Y))
                             x)
                          (@eq.{v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C X)
                                Y)
                             x
                             x))
                       (@eq.rec.{0 v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             Y)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             Y
                             Y
                             x
                             (@category_theory.category_struct.id.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                Y))
                          (λ
                           (_a :
                             @category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@opposite.unop.{u₁+1} C X)
                               Y),
                             @eq.{1} Prop
                               (@eq.{v₁+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C X)
                                     Y)
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@opposite.unop.{u₁+1} C X)
                                     Y
                                     Y
                                     x
                                     (@category_theory.category_struct.id.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        Y))
                                  x)
                               (@eq.{v₁+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C X)
                                     Y)
                                  _a
                                  x))
                          (@eq.refl.{1} Prop
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C X)
                                   Y)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   Y
                                   Y
                                   x
                                   (@category_theory.category_struct.id.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      Y))
                                x))
                          x
                          (@category_theory.category.comp_id.{v₁ u₁} C 𝒞 (@opposite.unop.{u₁+1} C X) Y x)))
                    (@eq.refl.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          Y)
                       x))))
       (λ (_x _x_1 _x_2 : C)
        (f :
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            _x
            _x_1)
        (g :
          @category_theory.has_hom.hom.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            _x_1
            _x_2),
          @funext.{v₁+1 v₁+1}
            (@category_theory.has_hom.hom.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C X)
               _x)
            (λ
             (x :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 _x),
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 _x_2)
            (λ
             (g_1 :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 _x),
               @category_theory.category_struct.comp.{v₁ u₁} C
                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                 (@opposite.unop.{u₁+1} C X)
                 _x
                 _x_2
                 g_1
                 (@category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    _x
                    _x_1
                    _x_2
                    f
                    g))
            (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
               (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C X)
                  _x)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C X)
                  _x_1)
               (@category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C X)
                  _x_2)
               (λ
                (g :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    _x),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C X)
                    _x
                    _x_1
                    g
                    f)
               (λ
                (g_1 :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    _x_1),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C X)
                    _x_1
                    _x_2
                    g_1
                    g))
            (λ
             (x :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 _x),
               @id.{0}
                 (@eq.{v₁+1}
                    (@category_theory.has_hom.hom.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       (@opposite.unop.{u₁+1} C X)
                       _x_2)
                    (@category_theory.category_struct.comp.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                       (@opposite.unop.{u₁+1} C X)
                       _x
                       _x_2
                       x
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          _x
                          _x_1
                          _x_2
                          f
                          g))
                    (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                       (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                          category_theory.types.{v₁})
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          _x)
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          _x_1)
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          _x_2)
                       (λ
                        (g :
                          @category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@opposite.unop.{u₁+1} C X)
                            _x),
                          @category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@opposite.unop.{u₁+1} C X)
                            _x
                            _x_1
                            g
                            f)
                       (λ
                        (g_1 :
                          @category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@opposite.unop.{u₁+1} C X)
                            _x_1),
                          @category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            (@opposite.unop.{u₁+1} C X)
                            _x_1
                            _x_2
                            g_1
                            g)
                       x))
                 (@eq.mpr.{0}
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          _x_2)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C X)
                          _x
                          _x_2
                          x
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             _x
                             _x_1
                             _x_2
                             f
                             g))
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C X)
                          _x_1
                          _x_2
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             _x
                             _x_1
                             x
                             f)
                          g))
                    (@eq.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          _x_2)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C X)
                          _x
                          _x_2
                          x
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             _x
                             _x_1
                             _x_2
                             f
                             g))
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C X)
                          _x
                          _x_2
                          x
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             _x
                             _x_1
                             _x_2
                             f
                             g)))
                    (@id.{0}
                       (@eq.{1} Prop
                          (@eq.{v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C X)
                                _x_2)
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C X)
                                _x
                                _x_2
                                x
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   _x
                                   _x_1
                                   _x_2
                                   f
                                   g))
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C X)
                                _x_1
                                _x_2
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   _x
                                   _x_1
                                   x
                                   f)
                                g))
                          (@eq.{v₁+1}
                             (@category_theory.has_hom.hom.{v₁ u₁} C
                                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                (@opposite.unop.{u₁+1} C X)
                                _x_2)
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C X)
                                _x
                                _x_2
                                x
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   _x
                                   _x_1
                                   _x_2
                                   f
                                   g))
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C X)
                                _x
                                _x_2
                                x
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   _x
                                   _x_1
                                   _x_2
                                   f
                                   g))))
                       (@eq.rec.{0 v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             _x_2)
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             _x_1
                             _x_2
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                (@opposite.unop.{u₁+1} C X)
                                _x
                                _x_1
                                x
                                f)
                             g)
                          (λ
                           (_a :
                             @category_theory.has_hom.hom.{v₁ u₁} C
                               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                               (@opposite.unop.{u₁+1} C X)
                               _x_2),
                             @eq.{1} Prop
                               (@eq.{v₁+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C X)
                                     _x_2)
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@opposite.unop.{u₁+1} C X)
                                     _x
                                     _x_2
                                     x
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        _x
                                        _x_1
                                        _x_2
                                        f
                                        g))
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@opposite.unop.{u₁+1} C X)
                                     _x_1
                                     _x_2
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        (@opposite.unop.{u₁+1} C X)
                                        _x
                                        _x_1
                                        x
                                        f)
                                     g))
                               (@eq.{v₁+1}
                                  (@category_theory.has_hom.hom.{v₁ u₁} C
                                     (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                     (@opposite.unop.{u₁+1} C X)
                                     _x_2)
                                  (@category_theory.category_struct.comp.{v₁ u₁} C
                                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                     (@opposite.unop.{u₁+1} C X)
                                     _x
                                     _x_2
                                     x
                                     (@category_theory.category_struct.comp.{v₁ u₁} C
                                        (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                        _x
                                        _x_1
                                        _x_2
                                        f
                                        g))
                                  _a))
                          (@eq.refl.{1} Prop
                             (@eq.{v₁+1}
                                (@category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C X)
                                   _x_2)
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   _x
                                   _x_2
                                   x
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      _x
                                      _x_1
                                      _x_2
                                      f
                                      g))
                                (@category_theory.category_struct.comp.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C X)
                                   _x_1
                                   _x_2
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      (@opposite.unop.{u₁+1} C X)
                                      _x
                                      _x_1
                                      x
                                      f)
                                   g)))
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C X)
                             _x
                             _x_2
                             x
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                _x
                                _x_1
                                _x_2
                                f
                                g))
                          (@category_theory.category.assoc.{v₁ u₁} C 𝒞 (@opposite.unop.{u₁+1} C X) _x _x_1 _x_2
                             x
                             f
                             g)))
                    (@eq.refl.{v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C X)
                          _x_2)
                       (@category_theory.category_struct.comp.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                          (@opposite.unop.{u₁+1} C X)
                          _x
                          _x_2
                          x
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             _x
                             _x_1
                             _x_2
                             f
                             g)))))))
    x
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@opposite.unop.{u₁+1} C X)
       x)
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@opposite.unop.{u₁+1} C X)
       (@opposite.unop.{u₁+1} C X)
       x
       (@category_theory.category_struct.id.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C X))
       x_1)
    x_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  namespace yoneda</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  lemma obj_map_id {X Y : C} (f : op X ⟶ op Y) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='opposite.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='opposite.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Sort u}, α → opposite.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Sort u}, α → opposite.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47    ((@yoneda C _).obj X).map f (𝟙 X) = ((@yoneda C _).map f.unop).app (op Y) (𝟙 Y) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.yoneda'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.yoneda'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.has_hom.hom.unop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='opposite.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 26, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 26, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type (max v₁ u₁ (v₁+1))} [_inst_2 : category_theory.category.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} D], @category_theory.functor.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type (v₁+1)} [_inst_2 : category_theory.category.{v₁ v₁+1} D] (c : @category_theory.functor.{v₁ v₁ u₁ v₁+1} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₁ v₁+1} D (@category_theory.category_struct.to_has_hom.{v₁ v₁+1} D (@category_theory.category.to_category_struct.{v₁ v₁+1} D _inst_2)) (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.has_hom.opposite.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))) (@opposite.op.{u₁+1} C X) (@opposite.op.{u₁+1} C Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] (X : obj), @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₁}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type (max v₁ u₁ (v₁+1))} [_inst_2 : category_theory.category.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} D] (c : @category_theory.functor.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} D (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} D (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} D _inst_2)) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.has_hom.opposite.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))) (@opposite.op.{u₁+1} C X) (@opposite.op.{u₁+1} C Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.has_hom.{v₁ u₁} C] {X Y : opposite.{u₁+1} C}, @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.has_hom.opposite.{v₁ u₁} C 𝒞) X Y → @category_theory.has_hom.hom.{v₁ u₁} C 𝒞 (@opposite.unop.{u₁+1} C Y) (@opposite.unop.{u₁+1} C X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type (v₁+1)} [𝒟 : category_theory.category.{v₁ v₁+1} D] {F G : @category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₁ v₁+1} D (@category_theory.category_struct.to_has_hom.{v₁ v₁+1} D (@category_theory.category.to_category_struct.{v₁ v₁+1} D 𝒟)) (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Sort u}, α → opposite.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] (X : obj), @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  by obviously</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
    (@category_theory.has_hom.opposite.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)))
    (@opposite.op.{u₁+1} C X)
    (@opposite.op.{u₁+1} C Y)
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          X)
       (@opposite.op.{u₁+1} C Y))
    (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          X)
       (@opposite.op.{u₁+1} C X)
       (@opposite.op.{u₁+1} C Y)
       f
       (@category_theory.category_struct.id.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C (@opposite.op.{u₁+1} C Y)))
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C (@opposite.op.{u₁+1} C X)))
       (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C (@opposite.op.{u₁+1} C Y))
          (@opposite.unop.{u₁+1} C (@opposite.op.{u₁+1} C X))
          (@category_theory.has_hom.hom.unop.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@opposite.op.{u₁+1} C X)
             (@opposite.op.{u₁+1} C Y)
             f))
       (@opposite.op.{u₁+1} C Y)
       (@category_theory.category_struct.id.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  @[simp] lemma naturality {X Y : C} (α : yoneda.obj X ⟶ yoneda.obj Y)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.yoneda'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.yoneda'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                        </code><font color='red'><a title='{&#x27;line&#x27;: 26, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 26, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type (max v₁ u₁ (v₁+1))} [_inst_2 : category_theory.category.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} D], @category_theory.functor.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v₁ u₁ (v₁+1))} [c : category_theory.has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} obj], obj → obj → Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type (max v₁ u₁ (v₁+1))} [_inst_2 : category_theory.category.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} D], @category_theory.functor.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51    {Z Z&#x27; : C} (f : Z ⟶ Z&#x27;) (h : Z&#x27; ⟶ X) : f ≫ α.app (op Z&#x27;) h = α.app (op Z) (f ≫ h) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='Z&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='opposite.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='opposite.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Z Z&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Y → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) Y Z → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}))) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.yoneda.{v₁ u₁} C 𝒞) X) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.yoneda.{v₁ u₁} C 𝒞) Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type (v₁+1)} [𝒟 : category_theory.category.{v₁ v₁+1} D] {F G : @category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₁ v₁+1} D (@category_theory.category_struct.to_has_hom.{v₁ v₁+1} D (@category_theory.category.to_category_struct.{v₁ v₁+1} D 𝒟)) (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u}, α → opposite.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Z&#x27; X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v₁}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}))) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.yoneda.{v₁ u₁} C 𝒞) X) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.yoneda.{v₁ u₁} C 𝒞) Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type (v₁+1)} [𝒟 : category_theory.category.{v₁ v₁+1} D] {F G : @category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₁ v₁+1} D (@category_theory.category_struct.to_has_hom.{v₁ v₁+1} D (@category_theory.category.to_category_struct.{v₁ v₁+1} D 𝒟)) (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u}, α → opposite.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Z Z&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Y → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) Y Z → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Z&#x27; X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y : opposite.{u₁+1} C,
f :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})))
    (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
       X)
    (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
       Y)
⊢ @eq.{(max u₁ v₁)+1}
    (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁)
                category_theory.types.{v₁})))
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
          X)
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
          Y))
    (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
       X
       Y
       (@category_theory.has_hom.hom.op.{v₁ u₁} C
          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
          (@opposite.unop.{u₁+1} C Y)
          (@opposite.unop.{u₁+1} C X)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
             (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
                X)
             (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
                Y)
             f
             (@opposite.unop.{u₁+1} C X)
             (@category_theory.category_struct.id.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                (@opposite.unop.{u₁+1} C X)))))
    f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  begin erw [functor_to_types.naturality], refl end</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.functor_to_types.naturality'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/types.lean&#x27;, &#x27;line&#x27;: 42, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (F G : @category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) {X Y : C} (σ : @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}))) F G) (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y) (x : @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F X), @eq.{v₁+1} (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} G Y) (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F G σ Y (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F X Y f x)) (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} G X Y f (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F G σ X x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y : C,
α :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁})
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})))
    (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.yoneda.{v₁ u₁} C 𝒞)
       X)
    (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.yoneda.{v₁ u₁} C 𝒞)
       Y),
Z Z&#x27; : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    Z
    Z&#x27;,
h :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    Z&#x27;
    X
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       Z
       Y)
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       Z
       Z&#x27;
       Y
       f
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             X)
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             Y)
          α
          (@opposite.op.{u₁+1} C Z&#x27;)
          h))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          X)
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          Y)
       α
       (@opposite.op.{u₁+1} C Z)
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C Z)
          Z&#x27;
          X
          f
          h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y : C,
α :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁})
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})))
    (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.yoneda.{v₁ u₁} C 𝒞)
       X)
    (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.yoneda.{v₁ u₁} C 𝒞)
       Y),
Z Z&#x27; : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    Z
    Z&#x27;,
h :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    Z&#x27;
    X
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       Z
       Y)
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       Z
       Z&#x27;
       Y
       f
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             X)
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             Y)
          α
          (@opposite.op.{u₁+1} C Z&#x27;)
          h))
    (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          Y)
       Z&#x27;
       (@opposite.op.{u₁+1} C Z)
       f
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             X)
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             Y)
          α
          Z&#x27;
          h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  instance yoneda_full : full (@yoneda C _) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='category_theory.full'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.yoneda'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/fully_faithful.lean&#x27;, &#x27;line&#x27;: 20, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 26, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → Type (max u₁ v₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='A functor `F : C ⥤ D` is full if for each `X Y : C`, `F.map` is surjective.
In fact, we use a constructive definition, so the `full F` typeclass contains data,
specifying a particular preimage of each `f : F.obj X ⟶ F.obj Y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  { preimage := λ X Y f, (f.app (op X)) (𝟙 X) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='opposite.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}))) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.yoneda.{v₁ u₁} C 𝒞) X) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.yoneda.{v₁ u₁} C 𝒞) Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}))) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.yoneda.{v₁ u₁} C 𝒞) X) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.yoneda.{v₁ u₁} C 𝒞) Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type (v₁+1)} [𝒟 : category_theory.category.{v₁ v₁+1} D] {F G : @category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₁ v₁+1} D (@category_theory.category_struct.to_has_hom.{v₁ v₁+1} D (@category_theory.category.to_category_struct.{v₁ v₁+1} D 𝒟)) (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u}, α → opposite.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] (X : obj), @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  instance yoneda_faithful : faithful (@yoneda C _) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='category_theory.faithful'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.yoneda'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/fully_faithful.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 26, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='A functor `F : C ⥤ D` is faithful if for each `X Y : C`, `F.map` is injective.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y : C,
p :
  Π {Z : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      Z
      X →
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      Z
      Y,
q :
  Π {Z : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      Z
      Y →
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      Z
      X,
h₁ :
  ∀ {Z : C}
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      Z
      X),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         Z
         X)
      (@q Z (@p Z f))
      f,
h₂ :
  ∀ {Z : C}
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      Z
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         Z
         Y)
      (@p Z (@q Z f))
      f,
n :
  ∀ {Z Z&#x27; : C}
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      Z&#x27;
      Z)
  (g :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      Z
      X),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         Z&#x27;
         Y)
      (@p Z&#x27;
         (@category_theory.category_struct.comp.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
            Z&#x27;
            Z
            X
            f
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         Z&#x27;
         Z
         Y
         f
         (@p Z g)),
Z : opposite.{u₁+1} C,
x :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    (@opposite.unop.{u₁+1} C Z)
    X
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@opposite.unop.{u₁+1} C Z)
       X)
    (@q (@opposite.unop.{u₁+1} C Z) (@p (@opposite.unop.{u₁+1} C Z) x))
    x'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  { injectivity&#x27; := λ X Y f g p,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{(max u₁ v₁)+1} (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}))) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.yoneda.{v₁ u₁} C 𝒞) X) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.yoneda.{v₁ u₁} C 𝒞) Y)) (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.yoneda.{v₁ u₁} C 𝒞) X Y f) (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.yoneda.{v₁ u₁} C 𝒞) X Y g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y : C,
f g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y,
p :
  @eq.{(max u₁ v₁)+1}
    (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})))
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          X)
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          Y))
    (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.yoneda.{v₁ u₁} C 𝒞)
       X
       Y
       f)
    (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.yoneda.{v₁ u₁} C 𝒞)
       X
       Y
       g)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       Y)
    f
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59      injection p with h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1036, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1036, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max u₁ v₁)+1} (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}))) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.yoneda.{v₁ u₁} C 𝒞) X) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.yoneda.{v₁ u₁} C 𝒞) Y)) (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.yoneda.{v₁ u₁} C 𝒞) X Y f) (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.yoneda.{v₁ u₁} C 𝒞) X Y g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `injection` tactic is based on the fact that constructors of inductive data types are injections. That means that if `c` is a constructor of an inductive datatype, and if `(c t₁)` and `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.

If `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies injectivity to derive the equality of all arguments of `t₁` and `t₂` placed in the same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`. To use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.

Given `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types `a = c` and `b = d` to the main goal. The tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `injection` tactic is based on the fact that constructors of inductive data types are injections. That means that if `c` is a constructor of an inductive datatype, and if `(c t₁)` and `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.

If `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies injectivity to derive the equality of all arguments of `t₁` and `t₂` placed in the same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`. To use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.

Given `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types `a = c` and `b = d` to the main goal. The tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='injection'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='injection'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y : C,
f g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y,
p :
  @eq.{(max u₁ v₁)+1}
    (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})))
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          X)
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          Y))
    (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.yoneda.{v₁ u₁} C 𝒞)
       X
       Y
       f)
    (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.yoneda.{v₁ u₁} C 𝒞)
       X
       Y
       g)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       Y)
    f
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y : C,
f g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y,
p :
  @eq.{(max u₁ v₁)+1}
    (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})))
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          X)
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          Y))
    (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.yoneda.{v₁ u₁} C 𝒞)
       X
       Y
       f)
    (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.yoneda.{v₁ u₁} C 𝒞)
       X
       Y
       g),
h :
  @eq.{(max (u₁+1) (v₁+1))}
    (Π (X_1 : opposite.{u₁+1} C),
       @category_theory.has_hom.hom.{v₁ v₁+1} (Type v₁)
         (@category_theory.category_struct.to_has_hom.{v₁ v₁+1} (Type v₁)
            (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁}))
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
               (Type v₁)
               category_theory.types.{v₁}
               (λ (Y : opposite.{u₁+1} C),
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C Y)
                    X)
               (λ (Y Y&#x27; : opposite.{u₁+1} C)
                (f :
                  @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                       (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                    Y
                    Y&#x27;)
                (g :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C Y)
                    X),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C Y&#x27;)
                    (@opposite.unop.{u₁+1} C Y)
                    X
                    (@category_theory.has_hom.hom.unop.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       Y
                       Y&#x27;
                       f)
                    g)
               (@category_theory.yoneda._proof_3.{u₁ v₁} C 𝒞 X)
               (@category_theory.yoneda._proof_4.{u₁ v₁} C 𝒞 X))
            X_1)
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
               (Type v₁)
               category_theory.types.{v₁}
               (λ (Y_1 : opposite.{u₁+1} C),
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C Y_1)
                    Y)
               (λ (Y_1 Y&#x27; : opposite.{u₁+1} C)
                (f :
                  @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                       (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                    Y_1
                    Y&#x27;)
                (g :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C Y_1)
                    Y),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C Y&#x27;)
                    (@opposite.unop.{u₁+1} C Y_1)
                    Y
                    (@category_theory.has_hom.hom.unop.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       Y_1
                       Y&#x27;
                       f)
                    g)
               (@category_theory.yoneda._proof_5.{u₁ v₁} C 𝒞 Y)
               (@category_theory.yoneda._proof_6.{u₁ v₁} C 𝒞 Y))
            X_1))
    (λ (Y_1 : opposite.{u₁+1} C)
     (g :
       @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
         (Type v₁)
         category_theory.types.{v₁}
         (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (λ (Y : opposite.{u₁+1} C),
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C Y)
                 X)
            (λ (Y Y&#x27; : opposite.{u₁+1} C)
             (f :
               @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                    (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                 Y
                 Y&#x27;)
             (g :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C Y)
                 X),
               @category_theory.category_struct.comp.{v₁ u₁} C
                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                 (@opposite.unop.{u₁+1} C Y&#x27;)
                 (@opposite.unop.{u₁+1} C Y)
                 X
                 (@category_theory.has_hom.hom.unop.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    Y
                    Y&#x27;
                    f)
                 g)
            (@category_theory.yoneda._proof_3.{u₁ v₁} C 𝒞 X)
            (@category_theory.yoneda._proof_4.{u₁ v₁} C 𝒞 X))
         Y_1),
       @category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         (@opposite.unop.{u₁+1} C Y_1)
         X
         Y
         g
         f)
    (λ (Y_1 : opposite.{u₁+1} C)
     (g_1 :
       @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
         (Type v₁)
         category_theory.types.{v₁}
         (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (λ (Y : opposite.{u₁+1} C),
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C Y)
                 X)
            (λ (Y Y&#x27; : opposite.{u₁+1} C)
             (f :
               @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                    (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                 Y
                 Y&#x27;)
             (g :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C Y)
                 X),
               @category_theory.category_struct.comp.{v₁ u₁} C
                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                 (@opposite.unop.{u₁+1} C Y&#x27;)
                 (@opposite.unop.{u₁+1} C Y)
                 X
                 (@category_theory.has_hom.hom.unop.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    Y
                    Y&#x27;
                    f)
                 g)
            (@category_theory.yoneda._proof_3.{u₁ v₁} C 𝒞 X)
            (@category_theory.yoneda._proof_4.{u₁ v₁} C 𝒞 X))
         Y_1),
       @category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         (@opposite.unop.{u₁+1} C Y_1)
         X
         Y
         g_1
         g)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       Y)
    f
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60      convert (congr_fun (congr_fun h (op X)) (𝟙 X)); dsimp; simp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='congr_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='opposite.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 170, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type v₁} {β : α → Type v₁} {f g : Π (x : α), β x}, @eq.{v₁+1} (Π (x : α), β x) f g → ∀ (a : α), @eq.{v₁+1} (β a) (f a) (g a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (u₁+1) (v₁+1))} (Π (X_1 : opposite.{u₁+1} C), @category_theory.has_hom.hom.{v₁ v₁+1} (Type v₁) (@category_theory.category_struct.to_has_hom.{v₁ v₁+1} (Type v₁) (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})) (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁} (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁} (λ (Y : opposite.{u₁+1} C), @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@opposite.unop.{u₁+1} C Y) X) (λ (Y Y&#x27; : opposite.{u₁+1} C) (f : @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞))) Y Y&#x27;) (g : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@opposite.unop.{u₁+1} C Y) X), @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@opposite.unop.{u₁+1} C Y&#x27;) (@opposite.unop.{u₁+1} C Y) X (@category_theory.has_hom.hom.unop.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Y Y&#x27; f) g) (@category_theory.yoneda._proof_3.{u₁ v₁} C 𝒞 X) (@category_theory.yoneda._proof_4.{u₁ v₁} C 𝒞 X)) X_1) (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁} (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁} (λ (Y_1 : opposite.{u₁+1} C), @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@opposite.unop.{u₁+1} C Y_1) Y) (λ (Y_1 Y&#x27; : opposite.{u₁+1} C) (f : @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞))) Y_1 Y&#x27;) (g : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@opposite.unop.{u₁+1} C Y_1) Y), @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@opposite.unop.{u₁+1} C Y&#x27;) (@opposite.unop.{u₁+1} C Y_1) Y (@category_theory.has_hom.hom.unop.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Y_1 Y&#x27; f) g) (@category_theory.yoneda._proof_5.{u₁ v₁} C 𝒞 Y) (@category_theory.yoneda._proof_6.{u₁ v₁} C 𝒞 Y)) X_1)) (λ (Y_1 : opposite.{u₁+1} C) (g : @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁} (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁} (λ (Y : opposite.{u₁+1} C), @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@opposite.unop.{u₁+1} C Y) X) (λ (Y Y&#x27; : opposite.{u₁+1} C) (f : @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞))) Y Y&#x27;) (g : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@opposite.unop.{u₁+1} C Y) X), @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@opposite.unop.{u₁+1} C Y&#x27;) (@opposite.unop.{u₁+1} C Y) X (@category_theory.has_hom.hom.unop.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Y Y&#x27; f) g) (@category_theory.yoneda._proof_3.{u₁ v₁} C 𝒞 X) (@category_theory.yoneda._proof_4.{u₁ v₁} C 𝒞 X)) Y_1), @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@opposite.unop.{u₁+1} C Y_1) X Y g f) (λ (Y_1 : opposite.{u₁+1} C) (g_1 : @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁} (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁} (λ (Y : opposite.{u₁+1} C), @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@opposite.unop.{u₁+1} C Y) X) (λ (Y Y&#x27; : opposite.{u₁+1} C) (f : @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞))) Y Y&#x27;) (g : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@opposite.unop.{u₁+1} C Y) X), @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@opposite.unop.{u₁+1} C Y&#x27;) (@opposite.unop.{u₁+1} C Y) X (@category_theory.has_hom.hom.unop.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Y Y&#x27; f) g) (@category_theory.yoneda._proof_3.{u₁ v₁} C 𝒞 X) (@category_theory.yoneda._proof_4.{u₁ v₁} C 𝒞 X)) Y_1), @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@opposite.unop.{u₁+1} C Y_1) X Y g_1 g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u₁}, α → opposite.{u₁+1} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] (X : obj), @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@interactive.with_desc (option.{0} unit) (@coe.{1 1} string format (@coe_to_lift.{1 1} string format (@coe_base.{1 1} string format string_to_format)) (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))))))))) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))))))) → @interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `refine` but generates equality proof obligations
for every discrepancy between the goal and the type of the rule.
`convert e using n` (with `n : ℕ`) bounds the depth of the search
for discrepancies, analogous to `congr&#x27; n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='convert'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;←&#x27;, &#x27;expr&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y : C,
f g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y,
p :
  @eq.{(max u₁ v₁)+1}
    (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})))
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          X)
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          Y))
    (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.yoneda.{v₁ u₁} C 𝒞)
       X
       Y
       f)
    (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.yoneda.{v₁ u₁} C 𝒞)
       X
       Y
       g),
h :
  @eq.{(max (u₁+1) (v₁+1))}
    (Π (X_1 : opposite.{u₁+1} C),
       @category_theory.has_hom.hom.{v₁ v₁+1} (Type v₁)
         (@category_theory.category_struct.to_has_hom.{v₁ v₁+1} (Type v₁)
            (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁}))
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
               (Type v₁)
               category_theory.types.{v₁}
               (λ (Y : opposite.{u₁+1} C),
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C Y)
                    X)
               (λ (Y Y&#x27; : opposite.{u₁+1} C)
                (f :
                  @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                       (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                    Y
                    Y&#x27;)
                (g :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C Y)
                    X),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C Y&#x27;)
                    (@opposite.unop.{u₁+1} C Y)
                    X
                    (@category_theory.has_hom.hom.unop.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       Y
                       Y&#x27;
                       f)
                    g)
               (@category_theory.yoneda._proof_3.{u₁ v₁} C 𝒞 X)
               (@category_theory.yoneda._proof_4.{u₁ v₁} C 𝒞 X))
            X_1)
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
               (Type v₁)
               category_theory.types.{v₁}
               (λ (Y_1 : opposite.{u₁+1} C),
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C Y_1)
                    Y)
               (λ (Y_1 Y&#x27; : opposite.{u₁+1} C)
                (f :
                  @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                       (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                    Y_1
                    Y&#x27;)
                (g :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C Y_1)
                    Y),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C Y&#x27;)
                    (@opposite.unop.{u₁+1} C Y_1)
                    Y
                    (@category_theory.has_hom.hom.unop.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       Y_1
                       Y&#x27;
                       f)
                    g)
               (@category_theory.yoneda._proof_5.{u₁ v₁} C 𝒞 Y)
               (@category_theory.yoneda._proof_6.{u₁ v₁} C 𝒞 Y))
            X_1))
    (λ (Y_1 : opposite.{u₁+1} C)
     (g :
       @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
         (Type v₁)
         category_theory.types.{v₁}
         (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (λ (Y : opposite.{u₁+1} C),
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C Y)
                 X)
            (λ (Y Y&#x27; : opposite.{u₁+1} C)
             (f :
               @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                    (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                 Y
                 Y&#x27;)
             (g :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C Y)
                 X),
               @category_theory.category_struct.comp.{v₁ u₁} C
                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                 (@opposite.unop.{u₁+1} C Y&#x27;)
                 (@opposite.unop.{u₁+1} C Y)
                 X
                 (@category_theory.has_hom.hom.unop.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    Y
                    Y&#x27;
                    f)
                 g)
            (@category_theory.yoneda._proof_3.{u₁ v₁} C 𝒞 X)
            (@category_theory.yoneda._proof_4.{u₁ v₁} C 𝒞 X))
         Y_1),
       @category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         (@opposite.unop.{u₁+1} C Y_1)
         X
         Y
         g
         f)
    (λ (Y_1 : opposite.{u₁+1} C)
     (g_1 :
       @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
         (Type v₁)
         category_theory.types.{v₁}
         (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (λ (Y : opposite.{u₁+1} C),
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C Y)
                 X)
            (λ (Y Y&#x27; : opposite.{u₁+1} C)
             (f :
               @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                    (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                 Y
                 Y&#x27;)
             (g :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C Y)
                 X),
               @category_theory.category_struct.comp.{v₁ u₁} C
                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                 (@opposite.unop.{u₁+1} C Y&#x27;)
                 (@opposite.unop.{u₁+1} C Y)
                 X
                 (@category_theory.has_hom.hom.unop.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    Y
                    Y&#x27;
                    f)
                 g)
            (@category_theory.yoneda._proof_3.{u₁ v₁} C 𝒞 X)
            (@category_theory.yoneda._proof_4.{u₁ v₁} C 𝒞 X))
         Y_1),
       @category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         (@opposite.unop.{u₁+1} C Y_1)
         X
         Y
         g_1
         g)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       Y)
    f
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61    end }</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63  /-- Extensionality via Yoneda. The typical usage would be</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  ```</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  -- Goal is `X ≅ Y`</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  apply yoneda.ext,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  -- Goals are now functions `(Z ⟶ X) → (Z ⟶ Y)`, `(Z ⟶ Y) → (Z ⟶ X)`, and the fact that these</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68  functions are inverses and natural in `Z`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  ```</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  def ext (X Y : C)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72    (p : Π {Z : C}, (Z ⟶ X) → (Z ⟶ Y)) (q : Π {Z : C}, (Z ⟶ Y) → (Z ⟶ X))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73    (h₁ : Π {Z : C} (f : Z ⟶ X), q (p f) = f) (h₂ : Π {Z : C} (f : Z ⟶ Y), p (q f) = f)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {Z : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Z Y → @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Z X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {Z : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Z X → @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Z Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Z X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₁}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Z X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {Z : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Z X → @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Z Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {Z : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Z Y → @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Z X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Z Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₁}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Z Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74    (n : Π {Z Z&#x27; : C} (f : Z&#x27; ⟶ Z) (g : Z ⟶ X), p (f ≫ g) = f ≫ p g) : X ≅ Y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='Z&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {Z : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Z X → @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Z Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Z&#x27; Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Y → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) Y Z → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Z X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₁}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Z&#x27; Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Y → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) Y Z → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {Z : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Z X → @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Z Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Z X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C], C → C → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75  @preimage_iso _ _ _ _ yoneda _ _ _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.preimage_iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='category_theory.yoneda'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/fully_faithful.lean&#x27;, &#x27;line&#x27;: 58, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;line&#x27;: 26, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} [_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] [_inst_2 : @category_theory.faithful.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] {X Y : C}, @category_theory.iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) → @category_theory.iso.{v₁ u₁} C 𝒞 X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='If `F : C ⥤ D` is fully faithful, every isomorphism `F.obj X ≅ F.obj Y` has a preimage.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76    (nat_iso.of_components (λ Z, { hom := p, inv := q, }) (by tidy))</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.nat_iso.of_components'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_isomorphism.lean&#x27;, &#x27;line&#x27;: 92, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/tidy.lean&#x27;, &#x27;line&#x27;: 91, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} (app : Π (X : C), @category_theory.iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)), (∀ {X Y : C} (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f) (@category_theory.iso.hom.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y) (app Y))) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y) (@category_theory.iso.hom.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X) (app X)) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f))) → @category_theory.iso.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='opposite.{u₁+1} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π {Z : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Z X → @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Z Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Π {Z : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Z Y → @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Z X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → opt_param.{1} tactic.tidy.cfg {trace_result := bool.ff, trace_result_prefix := string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))), tactics := tactic.tidy.default_tactics} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title=' Use a variety of conservative tactics to solve goals.
`tidy?` reports back the tactic script it found.
The default list of tactics is stored in `tactic.tidy.default_tidy_tactics`.
This list can be overridden using `tidy { tactics := ... }`.
(The list must be a `list` of `tactic string`, so that `tidy?`
can report a usable tactic script.) 

Tactics can also be added to the list by tagging them (locally) with the
`[tidy]` attribute.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='teal'><a title='tidy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                            </code><font color='grey'><a title='[&#x27;??&#x27;, &#x27;tactic.tidy.cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                           </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y : C,
p :
  Π {Z : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      Z
      X →
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      Z
      Y,
q :
  Π {Z : C},
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      Z
      Y →
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      Z
      X,
h₁ :
  ∀ {Z : C}
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      Z
      X),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         Z
         X)
      (@q Z (@p Z f))
      f,
h₂ :
  ∀ {Z : C}
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      Z
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         Z
         Y)
      (@p Z (@q Z f))
      f,
n :
  ∀ {Z Z&#x27; : C}
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      Z&#x27;
      Z)
  (g :
    @category_theory.has_hom.hom.{v₁ u₁} C
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
      Z
      X),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ u₁} C
         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
         Z&#x27;
         Y)
      (@p Z&#x27;
         (@category_theory.category_struct.comp.{v₁ u₁} C
            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
            Z&#x27;
            Z
            X
            f
            g))
      (@category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         Z&#x27;
         Z
         Y
         f
         (@p Z g))
⊢ ∀ {X_1 Y_1 : opposite.{u₁+1} C}
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
         (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
      X_1
      Y_1),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ v₁+1} (Type v₁)
         (@category_theory.category_struct.to_has_hom.{v₁ v₁+1} (Type v₁)
            (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁}))
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@category_theory.yoneda.{v₁ u₁} C 𝒞)
               X)
            X_1)
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@category_theory.yoneda.{v₁ u₁} C 𝒞)
               Y)
            Y_1))
      (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
         (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@category_theory.yoneda.{v₁ u₁} C 𝒞)
               X)
            X_1)
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@category_theory.yoneda.{v₁ u₁} C 𝒞)
               X)
            Y_1)
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@category_theory.yoneda.{v₁ u₁} C 𝒞)
               Y)
            Y_1)
         (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@category_theory.yoneda.{v₁ u₁} C 𝒞)
               X)
            X_1
            Y_1
            f)
         (@category_theory.iso.hom.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁}
            (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
               (Type v₁)
               category_theory.types.{v₁}
               (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                  X)
               Y_1)
            (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
               (Type v₁)
               category_theory.types.{v₁}
               (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                  Y)
               Y_1)
            (@category_theory.iso.mk.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁}
               (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}
                  (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                     X)
                  Y_1)
               (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}
                  (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                     Y)
                  Y_1)
               (@p (@opposite.unop.{u₁+1} C Y_1))
               (@q (@opposite.unop.{u₁+1} C Y_1))
               (@id.{0}
                  (∀ (X Y : C)
                   (p :
                     Π {Z : C},
                       @category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         Z
                         X →
                       @category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         Z
                         Y)
                   (q :
                     Π {Z : C},
                       @category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         Z
                         Y →
                       @category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         Z
                         X),
                     (∀ {Z : C}
                      (f :
                        @category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          Z
                          X),
                        @eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             Z
                             X)
                          (@q Z (@p Z f))
                          f) →
                     (∀ {Z : C}
                      (f :
                        @category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          Z
                          Y),
                        @eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             Z
                             Y)
                          (@p Z (@q Z f))
                          f) →
                     (∀ {Z Z&#x27; : C}
                      (f :
                        @category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          Z&#x27;
                          Z)
                      (g :
                        @category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          Z
                          X),
                        @eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             Z&#x27;
                             Y)
                          (@p Z&#x27;
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                Z&#x27;
                                Z
                                X
                                f
                                g))
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             Z&#x27;
                             Z
                             Y
                             f
                             (@p Z g))) →
                     ∀ (Z : opposite.{u₁+1} C),
                       @eq.{v₁+1}
                         (@category_theory.has_hom.hom.{v₁ v₁+1} (Type v₁)
                            (@category_theory.category_struct.to_has_hom.{v₁ v₁+1} (Type v₁)
                               (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                                  category_theory.types.{v₁}))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁}
                               (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                                  X)
                               Z)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁}
                               (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                                  X)
                               Z))
                         (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                            (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                               category_theory.types.{v₁})
                            (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁}
                               (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                                  X)
                               Z)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁}
                               (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                                  Y)
                               Z)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁}
                               (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                                  X)
                               Z)
                            (@p (@opposite.unop.{u₁+1} C Z))
                            (@q (@opposite.unop.{u₁+1} C Z)))
                         (@category_theory.category_struct.id.{v₁ v₁+1} (Type v₁)
                            (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                               category_theory.types.{v₁})
                            (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁}
                               (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                                  X)
                               Z)))
                  (λ (X Y : C)
                   (p :
                     Π {Z : C},
                       @category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         Z
                         X →
                       @category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         Z
                         Y)
                   (q :
                     Π {Z : C},
                       @category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         Z
                         Y →
                       @category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         Z
                         X)
                   (h₁ :
                     ∀ {Z : C}
                     (f :
                       @category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         Z
                         X),
                       @eq.{v₁+1}
                         (@category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            Z
                            X)
                         (@q Z (@p Z f))
                         f)
                   (h₂ :
                     ∀ {Z : C}
                     (f :
                       @category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         Z
                         Y),
                       @eq.{v₁+1}
                         (@category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            Z
                            Y)
                         (@p Z (@q Z f))
                         f)
                   (n :
                     ∀ {Z Z&#x27; : C}
                     (f :
                       @category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         Z&#x27;
                         Z)
                     (g :
                       @category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         Z
                         X),
                       @eq.{v₁+1}
                         (@category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            Z&#x27;
                            Y)
                         (@p Z&#x27;
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               Z&#x27;
                               Z
                               X
                               f
                               g))
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            Z&#x27;
                            Z
                            Y
                            f
                            (@p Z g))) (Z : opposite.{u₁+1} C),
                     @funext.{v₁+1 v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C Z)
                          X)
                       (λ
                        (x :
                          @category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@opposite.unop.{u₁+1} C Z)
                            X),
                          @category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@opposite.unop.{u₁+1} C Z)
                            X)
                       (@function.comp.{v₁+1 v₁+1 v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C Z)
                             X)
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C Z)
                             Y)
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C Z)
                             X)
                          (@q (@opposite.unop.{u₁+1} C Z))
                          (@p (@opposite.unop.{u₁+1} C Z)))
                       (@id.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C Z)
                             X))
                       (λ
                        (x :
                          @category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@opposite.unop.{u₁+1} C Z)
                            X),
                          @id.{0}
                            (∀ (X Y : C)
                             (p :
                               Π {Z : C},
                                 @category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   Z
                                   X →
                                 @category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   Z
                                   Y)
                             (q :
                               Π {Z : C},
                                 @category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   Z
                                   Y →
                                 @category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   Z
                                   X),
                               (∀ {Z : C}
                                (f :
                                  @category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    Z
                                    X),
                                  @eq.{v₁+1}
                                    (@category_theory.has_hom.hom.{v₁ u₁} C
                                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                       Z
                                       X)
                                    (@q Z (@p Z f))
                                    f) →
                               (∀ {Z : C}
                                (f :
                                  @category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    Z
                                    Y),
                                  @eq.{v₁+1}
                                    (@category_theory.has_hom.hom.{v₁ u₁} C
                                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                       Z
                                       Y)
                                    (@p Z (@q Z f))
                                    f) →
                               (∀ {Z Z&#x27; : C}
                                (f :
                                  @category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    Z&#x27;
                                    Z)
                                (g :
                                  @category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    Z
                                    X),
                                  @eq.{v₁+1}
                                    (@category_theory.has_hom.hom.{v₁ u₁} C
                                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                       Z&#x27;
                                       Y)
                                    (@p Z&#x27;
                                       (@category_theory.category_struct.comp.{v₁ u₁} C
                                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                          Z&#x27;
                                          Z
                                          X
                                          f
                                          g))
                                    (@category_theory.category_struct.comp.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                       Z&#x27;
                                       Z
                                       Y
                                       f
                                       (@p Z g))) →
                               ∀ (Z : opposite.{u₁+1} C)
                               (x :
                                 @category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C Z)
                                   X),
                                 @eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      (@opposite.unop.{u₁+1} C Z)
                                      X)
                                   (@function.comp.{v₁+1 v₁+1 v₁+1}
                                      (@category_theory.has_hom.hom.{v₁ u₁} C
                                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                         (@opposite.unop.{u₁+1} C Z)
                                         X)
                                      (@category_theory.has_hom.hom.{v₁ u₁} C
                                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                         (@opposite.unop.{u₁+1} C Z)
                                         Y)
                                      (@category_theory.has_hom.hom.{v₁ u₁} C
                                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                         (@opposite.unop.{u₁+1} C Z)
                                         X)
                                      (@q (@opposite.unop.{u₁+1} C Z))
                                      (@p (@opposite.unop.{u₁+1} C Z))
                                      x)
                                   (@id.{v₁+1}
                                      (@category_theory.has_hom.hom.{v₁ u₁} C
                                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                         (@opposite.unop.{u₁+1} C Z)
                                         X)
                                      x))
                            (λ (X Y : C)
                             (p :
                               Π {Z : C},
                                 @category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   Z
                                   X →
                                 @category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   Z
                                   Y)
                             (q :
                               Π {Z : C},
                                 @category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   Z
                                   Y →
                                 @category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   Z
                                   X)
                             (h₁ :
                               ∀ {Z : C}
                               (f :
                                 @category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   Z
                                   X),
                                 @eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      Z
                                      X)
                                   (@q Z (@p Z f))
                                   f)
                             (h₂ :
                               ∀ {Z : C}
                               (f :
                                 @category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   Z
                                   Y),
                                 @eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      Z
                                      Y)
                                   (@p Z (@q Z f))
                                   f)
                             (n :
                               ∀ {Z Z&#x27; : C}
                               (f :
                                 @category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   Z&#x27;
                                   Z)
                               (g :
                                 @category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   Z
                                   X),
                                 @eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      Z&#x27;
                                      Y)
                                   (@p Z&#x27;
                                      (@category_theory.category_struct.comp.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         Z&#x27;
                                         Z
                                         X
                                         f
                                         g))
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      Z&#x27;
                                      Z
                                      Y
                                      f
                                      (@p Z g))) (Z : opposite.{u₁+1} C)
                             (x :
                               @category_theory.has_hom.hom.{v₁ u₁} C
                                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                 (@opposite.unop.{u₁+1} C Z)
                                 X), @h₁ (@opposite.unop.{u₁+1} C Z) x)
                            X
                            Y
                            p
                            q
                            h₁
                            h₂
                            n
                            Z
                            x))
                  X
                  Y
                  p
                  q
                  h₁
                  h₂
                  n
                  Y_1)
               (@id.{0}
                  (∀ (X Y : C)
                   (p :
                     Π {Z : C},
                       @category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         Z
                         X →
                       @category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         Z
                         Y)
                   (q :
                     Π {Z : C},
                       @category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         Z
                         Y →
                       @category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         Z
                         X),
                     (∀ {Z : C}
                      (f :
                        @category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          Z
                          X),
                        @eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             Z
                             X)
                          (@q Z (@p Z f))
                          f) →
                     (∀ {Z : C}
                      (f :
                        @category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          Z
                          Y),
                        @eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             Z
                             Y)
                          (@p Z (@q Z f))
                          f) →
                     (∀ {Z Z&#x27; : C}
                      (f :
                        @category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          Z&#x27;
                          Z)
                      (g :
                        @category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          Z
                          X),
                        @eq.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             Z&#x27;
                             Y)
                          (@p Z&#x27;
                             (@category_theory.category_struct.comp.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                Z&#x27;
                                Z
                                X
                                f
                                g))
                          (@category_theory.category_struct.comp.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             Z&#x27;
                             Z
                             Y
                             f
                             (@p Z g))) →
                     ∀ (Z : opposite.{u₁+1} C),
                       @eq.{v₁+1}
                         (@category_theory.has_hom.hom.{v₁ v₁+1} (Type v₁)
                            (@category_theory.category_struct.to_has_hom.{v₁ v₁+1} (Type v₁)
                               (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                                  category_theory.types.{v₁}))
                            (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁}
                               (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                                  Y)
                               Z)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁}
                               (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                                  Y)
                               Z))
                         (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                            (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                               category_theory.types.{v₁})
                            (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁}
                               (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                                  Y)
                               Z)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁}
                               (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                                  X)
                               Z)
                            (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁}
                               (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                                  Y)
                               Z)
                            (@q (@opposite.unop.{u₁+1} C Z))
                            (@p (@opposite.unop.{u₁+1} C Z)))
                         (@category_theory.category_struct.id.{v₁ v₁+1} (Type v₁)
                            (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                               category_theory.types.{v₁})
                            (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁}
                               (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                                  Y)
                               Z)))
                  (λ (X Y : C)
                   (p :
                     Π {Z : C},
                       @category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         Z
                         X →
                       @category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         Z
                         Y)
                   (q :
                     Π {Z : C},
                       @category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         Z
                         Y →
                       @category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         Z
                         X)
                   (h₁ :
                     ∀ {Z : C}
                     (f :
                       @category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         Z
                         X),
                       @eq.{v₁+1}
                         (@category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            Z
                            X)
                         (@q Z (@p Z f))
                         f)
                   (h₂ :
                     ∀ {Z : C}
                     (f :
                       @category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         Z
                         Y),
                       @eq.{v₁+1}
                         (@category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            Z
                            Y)
                         (@p Z (@q Z f))
                         f)
                   (n :
                     ∀ {Z Z&#x27; : C}
                     (f :
                       @category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         Z&#x27;
                         Z)
                     (g :
                       @category_theory.has_hom.hom.{v₁ u₁} C
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                         Z
                         X),
                       @eq.{v₁+1}
                         (@category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            Z&#x27;
                            Y)
                         (@p Z&#x27;
                            (@category_theory.category_struct.comp.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                               Z&#x27;
                               Z
                               X
                               f
                               g))
                         (@category_theory.category_struct.comp.{v₁ u₁} C
                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                            Z&#x27;
                            Z
                            Y
                            f
                            (@p Z g))) (Z : opposite.{u₁+1} C),
                     @funext.{v₁+1 v₁+1}
                       (@category_theory.has_hom.hom.{v₁ u₁} C
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                          (@opposite.unop.{u₁+1} C Z)
                          Y)
                       (λ
                        (x :
                          @category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@opposite.unop.{u₁+1} C Z)
                            Y),
                          @category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@opposite.unop.{u₁+1} C Z)
                            Y)
                       (@function.comp.{v₁+1 v₁+1 v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C Z)
                             Y)
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C Z)
                             X)
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C Z)
                             Y)
                          (@p (@opposite.unop.{u₁+1} C Z))
                          (@q (@opposite.unop.{u₁+1} C Z)))
                       (@id.{v₁+1}
                          (@category_theory.has_hom.hom.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C Z)
                             Y))
                       (λ
                        (x :
                          @category_theory.has_hom.hom.{v₁ u₁} C
                            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                            (@opposite.unop.{u₁+1} C Z)
                            Y),
                          @id.{0}
                            (∀ (X Y : C)
                             (p :
                               Π {Z : C},
                                 @category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   Z
                                   X →
                                 @category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   Z
                                   Y)
                             (q :
                               Π {Z : C},
                                 @category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   Z
                                   Y →
                                 @category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   Z
                                   X),
                               (∀ {Z : C}
                                (f :
                                  @category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    Z
                                    X),
                                  @eq.{v₁+1}
                                    (@category_theory.has_hom.hom.{v₁ u₁} C
                                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                       Z
                                       X)
                                    (@q Z (@p Z f))
                                    f) →
                               (∀ {Z : C}
                                (f :
                                  @category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    Z
                                    Y),
                                  @eq.{v₁+1}
                                    (@category_theory.has_hom.hom.{v₁ u₁} C
                                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                       Z
                                       Y)
                                    (@p Z (@q Z f))
                                    f) →
                               (∀ {Z Z&#x27; : C}
                                (f :
                                  @category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    Z&#x27;
                                    Z)
                                (g :
                                  @category_theory.has_hom.hom.{v₁ u₁} C
                                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                    Z
                                    X),
                                  @eq.{v₁+1}
                                    (@category_theory.has_hom.hom.{v₁ u₁} C
                                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                       Z&#x27;
                                       Y)
                                    (@p Z&#x27;
                                       (@category_theory.category_struct.comp.{v₁ u₁} C
                                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                          Z&#x27;
                                          Z
                                          X
                                          f
                                          g))
                                    (@category_theory.category_struct.comp.{v₁ u₁} C
                                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                       Z&#x27;
                                       Z
                                       Y
                                       f
                                       (@p Z g))) →
                               ∀ (Z : opposite.{u₁+1} C)
                               (x :
                                 @category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   (@opposite.unop.{u₁+1} C Z)
                                   Y),
                                 @eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      (@opposite.unop.{u₁+1} C Z)
                                      Y)
                                   (@function.comp.{v₁+1 v₁+1 v₁+1}
                                      (@category_theory.has_hom.hom.{v₁ u₁} C
                                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                         (@opposite.unop.{u₁+1} C Z)
                                         Y)
                                      (@category_theory.has_hom.hom.{v₁ u₁} C
                                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                         (@opposite.unop.{u₁+1} C Z)
                                         X)
                                      (@category_theory.has_hom.hom.{v₁ u₁} C
                                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                         (@opposite.unop.{u₁+1} C Z)
                                         Y)
                                      (@p (@opposite.unop.{u₁+1} C Z))
                                      (@q (@opposite.unop.{u₁+1} C Z))
                                      x)
                                   (@id.{v₁+1}
                                      (@category_theory.has_hom.hom.{v₁ u₁} C
                                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                            (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                         (@opposite.unop.{u₁+1} C Z)
                                         Y)
                                      x))
                            (λ (X Y : C)
                             (p :
                               Π {Z : C},
                                 @category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   Z
                                   X →
                                 @category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   Z
                                   Y)
                             (q :
                               Π {Z : C},
                                 @category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   Z
                                   Y →
                                 @category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   Z
                                   X)
                             (h₁ :
                               ∀ {Z : C}
                               (f :
                                 @category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   Z
                                   X),
                                 @eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      Z
                                      X)
                                   (@q Z (@p Z f))
                                   f)
                             (h₂ :
                               ∀ {Z : C}
                               (f :
                                 @category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   Z
                                   Y),
                                 @eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      Z
                                      Y)
                                   (@p Z (@q Z f))
                                   f)
                             (n :
                               ∀ {Z Z&#x27; : C}
                               (f :
                                 @category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   Z&#x27;
                                   Z)
                               (g :
                                 @category_theory.has_hom.hom.{v₁ u₁} C
                                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                   Z
                                   X),
                                 @eq.{v₁+1}
                                   (@category_theory.has_hom.hom.{v₁ u₁} C
                                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                      Z&#x27;
                                      Y)
                                   (@p Z&#x27;
                                      (@category_theory.category_struct.comp.{v₁ u₁} C
                                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                         Z&#x27;
                                         Z
                                         X
                                         f
                                         g))
                                   (@category_theory.category_struct.comp.{v₁ u₁} C
                                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                      Z&#x27;
                                      Z
                                      Y
                                      f
                                      (@p Z g))) (Z : opposite.{u₁+1} C)
                             (x :
                               @category_theory.has_hom.hom.{v₁ u₁} C
                                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                                 (@opposite.unop.{u₁+1} C Z)
                                 Y), @h₂ (@opposite.unop.{u₁+1} C Z) x)
                            X
                            Y
                            p
                            q
                            h₁
                            h₂
                            n
                            Z
                            x))
                  X
                  Y
                  p
                  q
                  h₁
                  h₂
                  n
                  Y_1))))
      (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
         (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@category_theory.yoneda.{v₁ u₁} C 𝒞)
               X)
            X_1)
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@category_theory.yoneda.{v₁ u₁} C 𝒞)
               Y)
            X_1)
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@category_theory.yoneda.{v₁ u₁} C 𝒞)
               Y)
            Y_1)
         (@category_theory.iso.hom.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁}
            (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
               (Type v₁)
               category_theory.types.{v₁}
               (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                  X)
               X_1)
            (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} … … (Type v₁) category_theory.types.{v₁} …
               X_1)
            …)
         …)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78  def is_iso {X Y : C} (f : X ⟶ Y) [is_iso (yoneda.map f)] : is_iso f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.is_iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.yoneda'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.is_iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 154, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 26, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 154, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type (max v₁ u₁ (v₁+1))} [𝒞 : category_theory.category.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} C] {X Y : C}, @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} C (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} C 𝒞)) X Y → Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type (max v₁ u₁ (v₁+1))} [_inst_2 : category_theory.category.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} D] (c : @category_theory.functor.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} D (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} D (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} D _inst_2)) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {X Y : C}, @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X Y → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                  </code><font color='orange'><a title='`is_iso` typeclass expressing that a morphism is invertible.
   This contains the data of the inverse, but is a subsingleton type.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`is_iso` typeclass expressing that a morphism is invertible.
   This contains the data of the inverse, but is a subsingleton type.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79  is_iso_of_fully_faithful yoneda f</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.is_iso_of_fully_faithful'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.yoneda'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/fully_faithful.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 26, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) [_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] [_inst_2 : @category_theory.faithful.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] {X Y : C} (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y) [_inst_3 : @category_theory.is_iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f)], @category_theory.is_iso.{v₁ u₁} C 𝒞 X Y f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81  end yoneda</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83  namespace coyoneda</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85  @[simp] lemma naturality {X Y : Cᵒᵖ} (α : coyoneda.obj X ⟶ coyoneda.obj Y)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='category_theory.coyoneda'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.coyoneda'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;line&#x27;: 34, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 34, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type (max v₁ u₁ (v₁+1))} [_inst_2 : category_theory.category.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} D], @category_theory.functor.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{u₁+1} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v₁ u₁ (v₁+1))} [c : category_theory.has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} obj], obj → obj → Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type (max v₁ u₁ (v₁+1))} [_inst_2 : category_theory.category.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} D], @category_theory.functor.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{u₁+1} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86    {Z Z&#x27; : C} (f : Z&#x27; ⟶ Z) (h : unop X ⟶ Z&#x27;) : (α.app Z&#x27; h) ≫ f = α.app Z (h ≫ f) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='Z&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='opposite.unop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Sort u}, opposite.{u} α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{u₁+1} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}))) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.coyoneda.{v₁ u₁} C 𝒞) X) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.coyoneda.{v₁ u₁} C 𝒞) Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type (v₁+1)} [𝒟 : category_theory.category.{v₁ v₁+1} D] {F G : @category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₁ v₁+1} D (@category_theory.category_struct.to_has_hom.{v₁ v₁+1} D (@category_theory.category.to_category_struct.{v₁ v₁+1} D 𝒟)) (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@opposite.unop.{u₁+1} C X) Z&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Y → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) Y Z → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Z&#x27; Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v₁}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}))) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.coyoneda.{v₁ u₁} C 𝒞) X) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.coyoneda.{v₁ u₁} C 𝒞) Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type (v₁+1)} [𝒟 : category_theory.category.{v₁ v₁+1} D] {F G : @category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₁ v₁+1} D (@category_theory.category_struct.to_has_hom.{v₁ v₁+1} D (@category_theory.category.to_category_struct.{v₁ v₁+1} D 𝒟)) (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@opposite.unop.{u₁+1} C X) Z&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Y → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) Y Z → @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Z&#x27; Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87  begin erw [functor_to_types.naturality], refl end</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.functor_to_types.naturality'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/types.lean&#x27;, &#x27;line&#x27;: 42, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (F G : @category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) {X Y : C} (σ : @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}))) F G) (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y) (x : @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F X), @eq.{v₁+1} (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} G Y) (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F G σ Y (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F X Y f x)) (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} G X Y f (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F G σ X x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y : opposite.{u₁+1} C,
α :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})))
    (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
       X)
    (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
       Y),
Z Z&#x27; : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    Z&#x27;
    Z,
h :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    (@opposite.unop.{u₁+1} C X)
    Z&#x27;
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@opposite.unop.{u₁+1} C Y)
       Z)
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@opposite.unop.{u₁+1} C Y)
       Z&#x27;
       Z
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
             (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
             X)
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
             (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
             Y)
          α
          Z&#x27;
          h)
       f)
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
          X)
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
          Y)
       α
       Z
       (@category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C X)
          Z&#x27;
          Z
          h
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y : opposite.{u₁+1} C,
α :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})))
    (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
       X)
    (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
       Y),
Z Z&#x27; : C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    Z&#x27;
    Z,
h :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    (@opposite.unop.{u₁+1} C X)
    Z&#x27;
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       (@opposite.unop.{u₁+1} C Y)
       Z)
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@opposite.unop.{u₁+1} C Y)
       Z&#x27;
       Z
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
             (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
             X)
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
             (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
             Y)
          α
          Z&#x27;
          h)
       f)
    (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
          Y)
       Z&#x27;
       Z
       f
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
             (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
             X)
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
             (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
             Y)
          α
          Z&#x27;
          h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  instance coyoneda_full : full (@coyoneda C _) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='category_theory.full'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.coyoneda'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/fully_faithful.lean&#x27;, &#x27;line&#x27;: 20, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 34, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → Type (max u₁ v₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='A functor `F : C ⥤ D` is full if for each `X Y : C`, `F.map` is surjective.
In fact, we use a constructive definition, so the `full F` typeclass contains data,
specifying a particular preimage of each `f : F.obj X ⟶ F.obj Y`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90  { preimage := λ X Y f, ((f.app (unop X)) (𝟙 _)).op }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='opposite.unop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.has_hom.hom.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='opposite.{u₁+1} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{u₁+1} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}))) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.coyoneda.{v₁ u₁} C 𝒞) X) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.coyoneda.{v₁ u₁} C 𝒞) Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}))) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.coyoneda.{v₁ u₁} C 𝒞) X) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.coyoneda.{v₁ u₁} C 𝒞) Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type (v₁+1)} [𝒟 : category_theory.category.{v₁ v₁+1} D] {F G : @category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₁ v₁+1} D (@category_theory.category_struct.to_has_hom.{v₁ v₁+1} D (@category_theory.category.to_category_struct.{v₁ v₁+1} D 𝒟)) (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u}, opposite.{u} α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{u₁+1} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] (X : obj), @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.has_hom.{v₁ u₁} C] {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C 𝒞 X Y → @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.has_hom.opposite.{v₁ u₁} C 𝒞) (@opposite.op.{u₁+1} C Y) (@opposite.op.{u₁+1} C X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91  instance coyoneda_faithful : faithful (@coyoneda C _) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.faithful'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.coyoneda'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/fully_faithful.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 34, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='A functor `F : C ⥤ D` is faithful if for each `X Y : C`, `F.map` is injective.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92  { injectivity&#x27; := λ X Y f g p,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='g'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='opposite.{u₁+1} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{u₁+1} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@eq.{(max u₁ v₁)+1} (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}))) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.coyoneda.{v₁ u₁} C 𝒞) X) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.coyoneda.{v₁ u₁} C 𝒞) Y)) (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.coyoneda.{v₁ u₁} C 𝒞) X Y f) (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.coyoneda.{v₁ u₁} C 𝒞) X Y g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y : opposite.{u₁+1} C,
f g :
  @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
    X
    Y,
p :
  @eq.{(max u₁ v₁)+1}
    (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁)
                category_theory.types.{v₁})))
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
          X)
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
          Y))
    (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
       X
       Y
       f)
    (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
       X
       Y
       g)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
          (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
       X
       Y)
    f
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94      injection p with h,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1036, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1036, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max u₁ v₁)+1} (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}))) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.coyoneda.{v₁ u₁} C 𝒞) X) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.coyoneda.{v₁ u₁} C 𝒞) Y)) (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.coyoneda.{v₁ u₁} C 𝒞) X Y f) (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.coyoneda.{v₁ u₁} C 𝒞) X Y g)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `injection` tactic is based on the fact that constructors of inductive data types are injections. That means that if `c` is a constructor of an inductive datatype, and if `(c t₁)` and `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.

If `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies injectivity to derive the equality of all arguments of `t₁` and `t₂` placed in the same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`. To use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.

Given `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types `a = c` and `b = d` to the main goal. The tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `injection` tactic is based on the fact that constructors of inductive data types are injections. That means that if `c` is a constructor of an inductive datatype, and if `(c t₁)` and `(c t₂)` are two terms that are equal then  `t₁` and `t₂` are equal too.

If `q` is a proof of a statement of conclusion `t₁ = t₂`, then injection applies injectivity to derive the equality of all arguments of `t₁` and `t₂` placed in the same positions. For example, from `(a::b) = (c::d)` we derive `a=c` and `b=d`. To use this tactic `t₁` and `t₂` should be constructor applications of the same constructor.

Given `h : a::b = c::d`, the tactic `injection h` adds two new hypothesis with types `a = c` and `b = d` to the main goal. The tactic `injection h with h₁ h₂` uses the names `h₁` and `h₂` to name the new hypotheses.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='injection'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='injection'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y : opposite.{u₁+1} C,
f g :
  @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
    X
    Y,
p :
  @eq.{(max u₁ v₁)+1}
    (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁)
                category_theory.types.{v₁})))
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
          X)
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
          Y))
    (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
       X
       Y
       f)
    (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
       X
       Y
       g)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
          (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
       X
       Y)
    f
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y : opposite.{u₁+1} C,
f g :
  @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
    X
    Y,
p :
  @eq.{(max u₁ v₁)+1}
    (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁)
                category_theory.types.{v₁})))
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
          X)
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
          Y))
    (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
       X
       Y
       f)
    (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
       X
       Y
       g),
h :
  @eq.{(max (u₁+1) (v₁+1))}
    (Π (X_1 : C),
       @category_theory.has_hom.hom.{v₁ v₁+1} (Type v₁)
         (@category_theory.category_struct.to_has_hom.{v₁ v₁+1} (Type v₁)
            (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁}))
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
            (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
               (λ (Y : C),
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    Y)
               (λ (Y Y&#x27; : C)
                (f :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    Y
                    Y&#x27;)
                (g :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    Y),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C X)
                    Y
                    Y&#x27;
                    g
                    f)
               (@category_theory.coyoneda._proof_3.{u₁ v₁} C 𝒞 X)
               (@category_theory.coyoneda._proof_4.{u₁ v₁} C 𝒞 X))
            X_1)
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
            (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
               (λ (Y_1 : C),
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C Y)
                    Y_1)
               (λ (Y_1 Y&#x27; : C)
                (f :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    Y_1
                    Y&#x27;)
                (g :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C Y)
                    Y_1),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C Y)
                    Y_1
                    Y&#x27;
                    g
                    f)
               (@category_theory.coyoneda._proof_5.{u₁ v₁} C 𝒞 Y)
               (@category_theory.coyoneda._proof_6.{u₁ v₁} C 𝒞 Y))
            X_1))
    (λ (Y_1 : C)
     (g :
       @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
         (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
            (λ (Y : C),
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 Y)
            (λ (Y Y&#x27; : C)
             (f :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 Y
                 Y&#x27;)
             (g :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 Y),
               @category_theory.category_struct.comp.{v₁ u₁} C
                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                 (@opposite.unop.{u₁+1} C X)
                 Y
                 Y&#x27;
                 g
                 f)
            (@category_theory.coyoneda._proof_3.{u₁ v₁} C 𝒞 X)
            (@category_theory.coyoneda._proof_4.{u₁ v₁} C 𝒞 X))
         Y_1),
       @category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         (@opposite.unop.{u₁+1} C Y)
         (@opposite.unop.{u₁+1} C X)
         Y_1
         (@category_theory.has_hom.hom.unop.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            X
            Y
            f)
         g)
    (λ (Y_1 : C)
     (g_1 :
       @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
         (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
            (λ (Y : C),
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 Y)
            (λ (Y Y&#x27; : C)
             (f :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 Y
                 Y&#x27;)
             (g :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 Y),
               @category_theory.category_struct.comp.{v₁ u₁} C
                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                 (@opposite.unop.{u₁+1} C X)
                 Y
                 Y&#x27;
                 g
                 f)
            (@category_theory.coyoneda._proof_3.{u₁ v₁} C 𝒞 X)
            (@category_theory.coyoneda._proof_4.{u₁ v₁} C 𝒞 X))
         Y_1),
       @category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         (@opposite.unop.{u₁+1} C Y)
         (@opposite.unop.{u₁+1} C X)
         Y_1
         (@category_theory.has_hom.hom.unop.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            X
            Y
            g)
         g_1)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
          (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
       X
       Y)
    f
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95      have t := (congr_fun (congr_fun h (unop X)) (𝟙 _)),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='blue'><a title='congr_fun'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='opposite.unop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 70, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type v₁} {β : α → Type v₁} {f g : Π (x : α), β x}, @eq.{v₁+1} (Π (x : α), β x) f g → ∀ (a : α), @eq.{v₁+1} (β a) (f a) (g a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (u₁+1) (v₁+1))} (Π (X_1 : C), @category_theory.has_hom.hom.{v₁ v₁+1} (Type v₁) (@category_theory.category_struct.to_has_hom.{v₁ v₁+1} (Type v₁) (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})) (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} (λ (Y : C), @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@opposite.unop.{u₁+1} C X) Y) (λ (Y Y&#x27; : C) (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Y Y&#x27;) (g : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@opposite.unop.{u₁+1} C X) Y), @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@opposite.unop.{u₁+1} C X) Y Y&#x27; g f) (@category_theory.coyoneda._proof_3.{u₁ v₁} C 𝒞 X) (@category_theory.coyoneda._proof_4.{u₁ v₁} C 𝒞 X)) X_1) (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} (λ (Y_1 : C), @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@opposite.unop.{u₁+1} C Y) Y_1) (λ (Y_1 Y&#x27; : C) (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Y_1 Y&#x27;) (g : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@opposite.unop.{u₁+1} C Y) Y_1), @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@opposite.unop.{u₁+1} C Y) Y_1 Y&#x27; g f) (@category_theory.coyoneda._proof_5.{u₁ v₁} C 𝒞 Y) (@category_theory.coyoneda._proof_6.{u₁ v₁} C 𝒞 Y)) X_1)) (λ (Y_1 : C) (g : @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} (λ (Y : C), @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@opposite.unop.{u₁+1} C X) Y) (λ (Y Y&#x27; : C) (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Y Y&#x27;) (g : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@opposite.unop.{u₁+1} C X) Y), @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@opposite.unop.{u₁+1} C X) Y Y&#x27; g f) (@category_theory.coyoneda._proof_3.{u₁ v₁} C 𝒞 X) (@category_theory.coyoneda._proof_4.{u₁ v₁} C 𝒞 X)) Y_1), @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@opposite.unop.{u₁+1} C Y) (@opposite.unop.{u₁+1} C X) Y_1 (@category_theory.has_hom.hom.unop.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y f) g) (λ (Y_1 : C) (g_1 : @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} (λ (Y : C), @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@opposite.unop.{u₁+1} C X) Y) (λ (Y Y&#x27; : C) (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Y Y&#x27;) (g : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@opposite.unop.{u₁+1} C X) Y), @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@opposite.unop.{u₁+1} C X) Y Y&#x27; g f) (@category_theory.coyoneda._proof_3.{u₁ v₁} C 𝒞 X) (@category_theory.coyoneda._proof_4.{u₁ v₁} C 𝒞 X)) Y_1), @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@opposite.unop.{u₁+1} C Y) (@opposite.unop.{u₁+1} C X) Y_1 (@category_theory.has_hom.hom.unop.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y g) g_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u₁}, opposite.{u₁+1} α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='opposite.{u₁+1} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] (X : obj), @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y : opposite.{u₁+1} C,
f g :
  @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
    X
    Y,
p :
  @eq.{(max u₁ v₁)+1}
    (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁)
                category_theory.types.{v₁})))
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
          X)
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
          Y))
    (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
       X
       Y
       f)
    (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
       X
       Y
       g),
h :
  @eq.{(max (u₁+1) (v₁+1))}
    (Π (X_1 : C),
       @category_theory.has_hom.hom.{v₁ v₁+1} (Type v₁)
         (@category_theory.category_struct.to_has_hom.{v₁ v₁+1} (Type v₁)
            (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁}))
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
            (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
               (λ (Y : C),
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    Y)
               (λ (Y Y&#x27; : C)
                (f :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    Y
                    Y&#x27;)
                (g :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    Y),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C X)
                    Y
                    Y&#x27;
                    g
                    f)
               (@category_theory.coyoneda._proof_3.{u₁ v₁} C 𝒞 X)
               (@category_theory.coyoneda._proof_4.{u₁ v₁} C 𝒞 X))
            X_1)
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
            (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
               (λ (Y_1 : C),
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C Y)
                    Y_1)
               (λ (Y_1 Y&#x27; : C)
                (f :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    Y_1
                    Y&#x27;)
                (g :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C Y)
                    Y_1),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C Y)
                    Y_1
                    Y&#x27;
                    g
                    f)
               (@category_theory.coyoneda._proof_5.{u₁ v₁} C 𝒞 Y)
               (@category_theory.coyoneda._proof_6.{u₁ v₁} C 𝒞 Y))
            X_1))
    (λ (Y_1 : C)
     (g :
       @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
         (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
            (λ (Y : C),
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 Y)
            (λ (Y Y&#x27; : C)
             (f :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 Y
                 Y&#x27;)
             (g :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 Y),
               @category_theory.category_struct.comp.{v₁ u₁} C
                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                 (@opposite.unop.{u₁+1} C X)
                 Y
                 Y&#x27;
                 g
                 f)
            (@category_theory.coyoneda._proof_3.{u₁ v₁} C 𝒞 X)
            (@category_theory.coyoneda._proof_4.{u₁ v₁} C 𝒞 X))
         Y_1),
       @category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         (@opposite.unop.{u₁+1} C Y)
         (@opposite.unop.{u₁+1} C X)
         Y_1
         (@category_theory.has_hom.hom.unop.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            X
            Y
            f)
         g)
    (λ (Y_1 : C)
     (g_1 :
       @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
         (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
            (λ (Y : C),
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 Y)
            (λ (Y Y&#x27; : C)
             (f :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 Y
                 Y&#x27;)
             (g :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 Y),
               @category_theory.category_struct.comp.{v₁ u₁} C
                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                 (@opposite.unop.{u₁+1} C X)
                 Y
                 Y&#x27;
                 g
                 f)
            (@category_theory.coyoneda._proof_3.{u₁ v₁} C 𝒞 X)
            (@category_theory.coyoneda._proof_4.{u₁ v₁} C 𝒞 X))
         Y_1),
       @category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         (@opposite.unop.{u₁+1} C Y)
         (@opposite.unop.{u₁+1} C X)
         Y_1
         (@category_theory.has_hom.hom.unop.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            X
            Y
            g)
         g_1)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
          (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
       X
       Y)
    f
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y : opposite.{u₁+1} C,
f g :
  @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
    X
    Y,
p :
  @eq.{(max u₁ v₁)+1}
    (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁)
                category_theory.types.{v₁})))
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
          X)
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
          Y))
    (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
       X
       Y
       f)
    (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
       X
       Y
       g),
h :
  @eq.{(max (u₁+1) (v₁+1))}
    (Π (X_1 : C),
       @category_theory.has_hom.hom.{v₁ v₁+1} (Type v₁)
         (@category_theory.category_struct.to_has_hom.{v₁ v₁+1} (Type v₁)
            (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁}))
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
            (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
               (λ (Y : C),
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    Y)
               (λ (Y Y&#x27; : C)
                (f :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    Y
                    Y&#x27;)
                (g :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    Y),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C X)
                    Y
                    Y&#x27;
                    g
                    f)
               (@category_theory.coyoneda._proof_3.{u₁ v₁} C 𝒞 X)
               (@category_theory.coyoneda._proof_4.{u₁ v₁} C 𝒞 X))
            X_1)
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
            (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
               (λ (Y_1 : C),
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C Y)
                    Y_1)
               (λ (Y_1 Y&#x27; : C)
                (f :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    Y_1
                    Y&#x27;)
                (g :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C Y)
                    Y_1),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C Y)
                    Y_1
                    Y&#x27;
                    g
                    f)
               (@category_theory.coyoneda._proof_5.{u₁ v₁} C 𝒞 Y)
               (@category_theory.coyoneda._proof_6.{u₁ v₁} C 𝒞 Y))
            X_1))
    (λ (Y_1 : C)
     (g :
       @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
         (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
            (λ (Y : C),
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 Y)
            (λ (Y Y&#x27; : C)
             (f :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 Y
                 Y&#x27;)
             (g :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 Y),
               @category_theory.category_struct.comp.{v₁ u₁} C
                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                 (@opposite.unop.{u₁+1} C X)
                 Y
                 Y&#x27;
                 g
                 f)
            (@category_theory.coyoneda._proof_3.{u₁ v₁} C 𝒞 X)
            (@category_theory.coyoneda._proof_4.{u₁ v₁} C 𝒞 X))
         Y_1),
       @category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         (@opposite.unop.{u₁+1} C Y)
         (@opposite.unop.{u₁+1} C X)
         Y_1
         (@category_theory.has_hom.hom.unop.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            X
            Y
            f)
         g)
    (λ (Y_1 : C)
     (g_1 :
       @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
         (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
            (λ (Y : C),
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 Y)
            (λ (Y Y&#x27; : C)
             (f :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 Y
                 Y&#x27;)
             (g :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 Y),
               @category_theory.category_struct.comp.{v₁ u₁} C
                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                 (@opposite.unop.{u₁+1} C X)
                 Y
                 Y&#x27;
                 g
                 f)
            (@category_theory.coyoneda._proof_3.{u₁ v₁} C 𝒞 X)
            (@category_theory.coyoneda._proof_4.{u₁ v₁} C 𝒞 X))
         Y_1),
       @category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         (@opposite.unop.{u₁+1} C Y)
         (@opposite.unop.{u₁+1} C X)
         Y_1
         (@category_theory.has_hom.hom.unop.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            X
            Y
            g)
         g_1),
t :
  @eq.{v₁+1}
    ((λ
      (x :
        @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
          (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
             (λ (Y : C),
                @category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C X)
                  Y)
             (λ (Y Y&#x27; : C)
              (f :
                @category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  Y
                  Y&#x27;)
              (g :
                @category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C X)
                  Y),
                @category_theory.category_struct.comp.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                  (@opposite.unop.{u₁+1} C X)
                  Y
                  Y&#x27;
                  g
                  f)
             (@category_theory.coyoneda._proof_3.{u₁ v₁} C 𝒞 X)
             (@category_theory.coyoneda._proof_4.{u₁ v₁} C 𝒞 X))
          (@opposite.unop.{u₁+1} C X)),
        @category_theory.has_hom.hom.{v₁ u₁} C
          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
          (@opposite.unop.{u₁+1} C Y)
          (@opposite.unop.{u₁+1} C X))
       (@category_theory.category_struct.id.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C X)))
    ((λ
      (g :
        @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
          (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
             (λ (Y : C),
                @category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C X)
                  Y)
             (λ (Y Y&#x27; : C)
              (f :
                @category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  Y
                  Y&#x27;)
              (g :
                @category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C X)
                  Y),
                @category_theory.category_struct.comp.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                  (@opposite.unop.{u₁+1} C X)
                  Y
                  Y&#x27;
                  g
                  f)
             (@category_theory.coyoneda._proof_3.{u₁ v₁} C 𝒞 X)
             (@category_theory.coyoneda._proof_4.{u₁ v₁} C 𝒞 X))
          (@opposite.unop.{u₁+1} C X)),
        @category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C Y)
          (@opposite.unop.{u₁+1} C X)
          (@opposite.unop.{u₁+1} C X)
          (@category_theory.has_hom.hom.unop.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             Y
             f)
          g)
       (@category_theory.category_struct.id.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C X)))
    ((λ
      (g_1 :
        @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
          (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
             (λ (Y : C),
                @category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C X)
                  Y)
             (λ (Y Y&#x27; : C)
              (f :
                @category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  Y
                  Y&#x27;)
              (g :
                @category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C X)
                  Y),
                @category_theory.category_struct.comp.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                  (@opposite.unop.{u₁+1} C X)
                  Y
                  Y&#x27;
                  g
                  f)
             (@category_theory.coyoneda._proof_3.{u₁ v₁} C 𝒞 X)
             (@category_theory.coyoneda._proof_4.{u₁ v₁} C 𝒞 X))
          (@opposite.unop.{u₁+1} C X)),
        @category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C Y)
          (@opposite.unop.{u₁+1} C X)
          (@opposite.unop.{u₁+1} C X)
          (@category_theory.has_hom.hom.unop.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             Y
             g)
          g_1)
       (@category_theory.category_struct.id.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C X)))
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
          (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
       X
       Y)
    f
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96      simpa using congr_arg has_hom.hom.op t,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='congr_arg'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 73, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type v₁} {a₁ a₂ : α} (f : α → β), @eq.{v₁+1} α a₁ a₂ → @eq.{v₁+1} β (f a₁) (f a₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.has_hom.{v₁ u₁} C] {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C 𝒞 X Y → @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.has_hom.opposite.{v₁ u₁} C 𝒞) (@opposite.op.{u₁+1} C Y) (@opposite.op.{u₁+1} C X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{v₁+1} ((λ (x : @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} (λ (Y : C), @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@opposite.unop.{u₁+1} C X) Y) (λ (Y Y&#x27; : C) (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Y Y&#x27;) (g : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@opposite.unop.{u₁+1} C X) Y), @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@opposite.unop.{u₁+1} C X) Y Y&#x27; g f) (@category_theory.coyoneda._proof_3.{u₁ v₁} C 𝒞 X) (@category_theory.coyoneda._proof_4.{u₁ v₁} C 𝒞 X)) (@opposite.unop.{u₁+1} C X)), @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@opposite.unop.{u₁+1} C Y) (@opposite.unop.{u₁+1} C X)) (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@opposite.unop.{u₁+1} C X))) ((λ (g : @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} (λ (Y : C), @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@opposite.unop.{u₁+1} C X) Y) (λ (Y Y&#x27; : C) (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Y Y&#x27;) (g : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@opposite.unop.{u₁+1} C X) Y), @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@opposite.unop.{u₁+1} C X) Y Y&#x27; g f) (@category_theory.coyoneda._proof_3.{u₁ v₁} C 𝒞 X) (@category_theory.coyoneda._proof_4.{u₁ v₁} C 𝒞 X)) (@opposite.unop.{u₁+1} C X)), @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@opposite.unop.{u₁+1} C Y) (@opposite.unop.{u₁+1} C X) (@opposite.unop.{u₁+1} C X) (@category_theory.has_hom.hom.unop.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y f) g) (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@opposite.unop.{u₁+1} C X))) ((λ (g_1 : @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} (λ (Y : C), @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@opposite.unop.{u₁+1} C X) Y) (λ (Y Y&#x27; : C) (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Y Y&#x27;) (g : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@opposite.unop.{u₁+1} C X) Y), @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@opposite.unop.{u₁+1} C X) Y Y&#x27; g f) (@category_theory.coyoneda._proof_3.{u₁ v₁} C 𝒞 X) (@category_theory.coyoneda._proof_4.{u₁ v₁} C 𝒞 X)) (@opposite.unop.{u₁+1} C X)), @category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@opposite.unop.{u₁+1} C Y) (@opposite.unop.{u₁+1} C X) (@opposite.unop.{u₁+1} C X) (@category_theory.has_hom.hom.unop.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y g) g_1) (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) (@opposite.unop.{u₁+1} C X)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y : opposite.{u₁+1} C,
f g :
  @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
    X
    Y,
p :
  @eq.{(max u₁ v₁)+1}
    (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁)
                category_theory.types.{v₁})))
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
          X)
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
          (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
          Y))
    (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
       X
       Y
       f)
    (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})
       (@category_theory.coyoneda.{v₁ u₁} C 𝒞)
       X
       Y
       g),
h :
  @eq.{(max (u₁+1) (v₁+1))}
    (Π (X_1 : C),
       @category_theory.has_hom.hom.{v₁ v₁+1} (Type v₁)
         (@category_theory.category_struct.to_has_hom.{v₁ v₁+1} (Type v₁)
            (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁}))
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
            (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
               (λ (Y : C),
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    Y)
               (λ (Y Y&#x27; : C)
                (f :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    Y
                    Y&#x27;)
                (g :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    Y),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C X)
                    Y
                    Y&#x27;
                    g
                    f)
               (@category_theory.coyoneda._proof_3.{u₁ v₁} C 𝒞 X)
               (@category_theory.coyoneda._proof_4.{u₁ v₁} C 𝒞 X))
            X_1)
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
            (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
               (λ (Y_1 : C),
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C Y)
                    Y_1)
               (λ (Y_1 Y&#x27; : C)
                (f :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    Y_1
                    Y&#x27;)
                (g :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C Y)
                    Y_1),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C Y)
                    Y_1
                    Y&#x27;
                    g
                    f)
               (@category_theory.coyoneda._proof_5.{u₁ v₁} C 𝒞 Y)
               (@category_theory.coyoneda._proof_6.{u₁ v₁} C 𝒞 Y))
            X_1))
    (λ (Y_1 : C)
     (g :
       @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
         (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
            (λ (Y : C),
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 Y)
            (λ (Y Y&#x27; : C)
             (f :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 Y
                 Y&#x27;)
             (g :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 Y),
               @category_theory.category_struct.comp.{v₁ u₁} C
                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                 (@opposite.unop.{u₁+1} C X)
                 Y
                 Y&#x27;
                 g
                 f)
            (@category_theory.coyoneda._proof_3.{u₁ v₁} C 𝒞 X)
            (@category_theory.coyoneda._proof_4.{u₁ v₁} C 𝒞 X))
         Y_1),
       @category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         (@opposite.unop.{u₁+1} C Y)
         (@opposite.unop.{u₁+1} C X)
         Y_1
         (@category_theory.has_hom.hom.unop.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            X
            Y
            f)
         g)
    (λ (Y_1 : C)
     (g_1 :
       @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
         (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
            (λ (Y : C),
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 Y)
            (λ (Y Y&#x27; : C)
             (f :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 Y
                 Y&#x27;)
             (g :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C X)
                 Y),
               @category_theory.category_struct.comp.{v₁ u₁} C
                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                 (@opposite.unop.{u₁+1} C X)
                 Y
                 Y&#x27;
                 g
                 f)
            (@category_theory.coyoneda._proof_3.{u₁ v₁} C 𝒞 X)
            (@category_theory.coyoneda._proof_4.{u₁ v₁} C 𝒞 X))
         Y_1),
       @category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         (@opposite.unop.{u₁+1} C Y)
         (@opposite.unop.{u₁+1} C X)
         Y_1
         (@category_theory.has_hom.hom.unop.{v₁ u₁} C
            (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
               (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
            X
            Y
            g)
         g_1),
t :
  @eq.{v₁+1}
    ((λ
      (x :
        @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
          (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
             (λ (Y : C),
                @category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C X)
                  Y)
             (λ (Y Y&#x27; : C)
              (f :
                @category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  Y
                  Y&#x27;)
              (g :
                @category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C X)
                  Y),
                @category_theory.category_struct.comp.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                  (@opposite.unop.{u₁+1} C X)
                  Y
                  Y&#x27;
                  g
                  f)
             (@category_theory.coyoneda._proof_3.{u₁ v₁} C 𝒞 X)
             (@category_theory.coyoneda._proof_4.{u₁ v₁} C 𝒞 X))
          (@opposite.unop.{u₁+1} C X)),
        @category_theory.has_hom.hom.{v₁ u₁} C
          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
          (@opposite.unop.{u₁+1} C Y)
          (@opposite.unop.{u₁+1} C X))
       (@category_theory.category_struct.id.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C X)))
    ((λ
      (g :
        @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
          (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
             (λ (Y : C),
                @category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C X)
                  Y)
             (λ (Y Y&#x27; : C)
              (f :
                @category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  Y
                  Y&#x27;)
              (g :
                @category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C X)
                  Y),
                @category_theory.category_struct.comp.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                  (@opposite.unop.{u₁+1} C X)
                  Y
                  Y&#x27;
                  g
                  f)
             (@category_theory.coyoneda._proof_3.{u₁ v₁} C 𝒞 X)
             (@category_theory.coyoneda._proof_4.{u₁ v₁} C 𝒞 X))
          (@opposite.unop.{u₁+1} C X)),
        @category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C Y)
          (@opposite.unop.{u₁+1} C X)
          (@opposite.unop.{u₁+1} C X)
          (@category_theory.has_hom.hom.unop.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             Y
             f)
          g)
       (@category_theory.category_struct.id.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C X)))
    ((λ
      (g_1 :
        @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
          (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}
             (λ (Y : C),
                @category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C X)
                  Y)
             (λ (Y Y&#x27; : C)
              (f :
                @category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  Y
                  Y&#x27;)
              (g :
                @category_theory.has_hom.hom.{v₁ u₁} C
                  (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                  (@opposite.unop.{u₁+1} C X)
                  Y),
                @category_theory.category_struct.comp.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                  (@opposite.unop.{u₁+1} C X)
                  Y
                  Y&#x27;
                  g
                  f)
             (@category_theory.coyoneda._proof_3.{u₁ v₁} C 𝒞 X)
             (@category_theory.coyoneda._proof_4.{u₁ v₁} C 𝒞 X))
          (@opposite.unop.{u₁+1} C X)),
        @category_theory.category_struct.comp.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C Y)
          (@opposite.unop.{u₁+1} C X)
          (@opposite.unop.{u₁+1} C X)
          (@category_theory.has_hom.hom.unop.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             X
             Y
             g)
          g_1)
       (@category_theory.category_struct.id.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C X)))
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
          (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
       X
       Y)
    f
    g'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97    end }</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99  def is_iso {X Y : Cᵒᵖ} (f : X ⟶ Y) [is_iso (coyoneda.map f)] : is_iso f :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.is_iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.coyoneda'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.is_iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 154, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 34, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 154, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='opposite.{u₁+1} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.has_hom.{v₁ u₁} obj], obj → obj → Type v₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='opposite.{u₁+1} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type (max v₁ u₁ (v₁+1))} [𝒞 : category_theory.category.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} C] {X Y : C}, @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} C (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} C 𝒞)) X Y → Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type (max v₁ u₁ (v₁+1))} [_inst_2 : category_theory.category.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} D] (c : @category_theory.functor.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} D (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} D (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} D _inst_2)) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.has_hom.opposite.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {C : Type u} [𝒞 : category_theory.category.{v u} C] {X Y : C}, @category_theory.has_hom.hom.{v u} C (@category_theory.category_struct.to_has_hom.{v u} C (@category_theory.category.to_category_struct.{v u} C 𝒞)) X Y → Type v'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.has_hom.opposite.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='`is_iso` typeclass expressing that a morphism is invertible.
   This contains the data of the inverse, but is a subsingleton type.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='orange'><a title='`is_iso` typeclass expressing that a morphism is invertible.
   This contains the data of the inverse, but is a subsingleton type.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100  is_iso_of_fully_faithful coyoneda f</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.is_iso_of_fully_faithful'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.coyoneda'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/fully_faithful.lean&#x27;, &#x27;line&#x27;: 72, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 34, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] (F : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) [_inst_1 : @category_theory.full.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] [_inst_2 : @category_theory.faithful.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F] {X Y : C} (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y) [_inst_3 : @category_theory.is_iso.{v₂ u₂} D 𝒟 (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f)], @category_theory.is_iso.{v₁ u₁} C 𝒞 X Y f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.has_hom.opposite.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102  end coyoneda</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104  class representable (F : Cᵒᵖ ⥤ Type v₁) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type (v₁+1)) [_inst_2 : category_theory.category.{v₁ v₁+1} D], Type (max v₁ u₁ (v₁+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y : C,
f g :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    X
    Y,
p :
  @eq.{(max u₁ v₁)+1}
    (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})))
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          X)
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          Y))
    (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.yoneda.{v₁ u₁} C 𝒞)
       X
       Y
       f)
    (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@category_theory.yoneda.{v₁ u₁} C 𝒞)
       X
       Y
       g),
h :
  @eq.{(max (u₁+1) (v₁+1))}
    (Π (X_1 : opposite.{u₁+1} C),
       @category_theory.has_hom.hom.{v₁ v₁+1} (Type v₁)
         (@category_theory.category_struct.to_has_hom.{v₁ v₁+1} (Type v₁)
            (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁}))
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
               (Type v₁)
               category_theory.types.{v₁}
               (λ (Y : opposite.{u₁+1} C),
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C Y)
                    X)
               (λ (Y Y&#x27; : opposite.{u₁+1} C)
                (f :
                  @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                       (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                    Y
                    Y&#x27;)
                (g :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C Y)
                    X),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C Y&#x27;)
                    (@opposite.unop.{u₁+1} C Y)
                    X
                    (@category_theory.has_hom.hom.unop.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       Y
                       Y&#x27;
                       f)
                    g)
               (@category_theory.yoneda._proof_3.{u₁ v₁} C 𝒞 X)
               (@category_theory.yoneda._proof_4.{u₁ v₁} C 𝒞 X))
            X_1)
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
               (Type v₁)
               category_theory.types.{v₁}
               (λ (Y_1 : opposite.{u₁+1} C),
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C Y_1)
                    Y)
               (λ (Y_1 Y&#x27; : opposite.{u₁+1} C)
                (f :
                  @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                       (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                    Y_1
                    Y&#x27;)
                (g :
                  @category_theory.has_hom.hom.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C Y_1)
                    Y),
                  @category_theory.category_struct.comp.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C Y&#x27;)
                    (@opposite.unop.{u₁+1} C Y_1)
                    Y
                    (@category_theory.has_hom.hom.unop.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       Y_1
                       Y&#x27;
                       f)
                    g)
               (@category_theory.yoneda._proof_5.{u₁ v₁} C 𝒞 Y)
               (@category_theory.yoneda._proof_6.{u₁ v₁} C 𝒞 Y))
            X_1))
    (λ (Y_1 : opposite.{u₁+1} C)
     (g :
       @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
         (Type v₁)
         category_theory.types.{v₁}
         (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (λ (Y : opposite.{u₁+1} C),
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C Y)
                 X)
            (λ (Y Y&#x27; : opposite.{u₁+1} C)
             (f :
               @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                    (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                 Y
                 Y&#x27;)
             (g :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C Y)
                 X),
               @category_theory.category_struct.comp.{v₁ u₁} C
                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                 (@opposite.unop.{u₁+1} C Y&#x27;)
                 (@opposite.unop.{u₁+1} C Y)
                 X
                 (@category_theory.has_hom.hom.unop.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    Y
                    Y&#x27;
                    f)
                 g)
            (@category_theory.yoneda._proof_3.{u₁ v₁} C 𝒞 X)
            (@category_theory.yoneda._proof_4.{u₁ v₁} C 𝒞 X))
         Y_1),
       @category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         (@opposite.unop.{u₁+1} C Y_1)
         X
         Y
         g
         f)
    (λ (Y_1 : opposite.{u₁+1} C)
     (g_1 :
       @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
         (Type v₁)
         category_theory.types.{v₁}
         (@category_theory.functor.mk.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (λ (Y : opposite.{u₁+1} C),
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C Y)
                 X)
            (λ (Y Y&#x27; : opposite.{u₁+1} C)
             (f :
               @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                    (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                 Y
                 Y&#x27;)
             (g :
               @category_theory.has_hom.hom.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C Y)
                 X),
               @category_theory.category_struct.comp.{v₁ u₁} C
                 (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                 (@opposite.unop.{u₁+1} C Y&#x27;)
                 (@opposite.unop.{u₁+1} C Y)
                 X
                 (@category_theory.has_hom.hom.unop.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    Y
                    Y&#x27;
                    f)
                 g)
            (@category_theory.yoneda._proof_3.{u₁ v₁} C 𝒞 X)
            (@category_theory.yoneda._proof_4.{u₁ v₁} C 𝒞 X))
         Y_1),
       @category_theory.category_struct.comp.{v₁ u₁} C
         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
         (@opposite.unop.{u₁+1} C Y_1)
         X
         Y
         g_1
         g)
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ u₁} C
       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
       X
       Y)
    f
    (@category_theory.category_struct.comp.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
       (@opposite.unop.{u₁+1} C (@opposite.op.{u₁+1} C X))
       X
       Y
       (@category_theory.category_struct.id.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          X)
       f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105  (X : C)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106  (w : yoneda.obj X ≅ F)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='category_theory.yoneda'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;line&#x27;: 26, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type (max v₁ u₁ (v₁+1))} [_inst_2 : category_theory.category.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} D], @category_theory.functor.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max v₁ u₁ (v₁+1))} [_inst_1 : category_theory.category.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} C], C → C → Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108  end category_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110  namespace category_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111  -- For the rest of the file, we are using product categories,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112  -- so need to restrict to the case morphisms are in &#x27;Type&#x27;, not &#x27;Sort&#x27;.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114  universes v₁ u₁ u₂ -- declare the `v`&#x27;s first; see `category_theory.category` for an explanation</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116  open opposite</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118  variables (C : Type u₁) [𝒞 : category.{v₁} C]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119  include 𝒞</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121  -- We need to help typeclass inference with some awkward universe levels here.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122  instance prod_category_instance_1 : category ((Cᵒᵖ ⥤ Type v₁) × Cᵒᵖ) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type (v₁+1)) [_inst_2 : category_theory.category.{v₁ v₁+1} D], Type (max v₁ u₁ (v₁+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type (max v₁ u₁ (v₁+1)) → Type u₁ → Type (max (max v₁ u₁ (v₁+1)) u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123  category_theory.prod.{(max u₁ v₁) v₁} (Cᵒᵖ ⥤ Type v₁) Cᵒᵖ</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/products/basic.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (C : Type u₁) [𝒞 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [𝒟 : category_theory.category.{v₂ u₂} D], category_theory.category.{(max v₁ v₂) (max u₁ u₂)} (prod.{u₁ u₂} C D)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type (v₁+1)) [_inst_2 : category_theory.category.{v₁ v₁+1} D], Type (max v₁ u₁ (v₁+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`prod C D` gives the cartesian product of two categories.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125  instance prod_category_instance_2 : category (Cᵒᵖ × (Cᵒᵖ ⥤ Type v₁)) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁ → Type (max v₁ u₁ (v₁+1)) → Type (max u₁ v₁ u₁ (v₁+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type (v₁+1)) [_inst_2 : category_theory.category.{v₁ v₁+1} D], Type (max v₁ u₁ (v₁+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126  category_theory.prod.{v₁ (max u₁ v₁)} Cᵒᵖ (Cᵒᵖ ⥤ Type v₁)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/products/basic.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (C : Type u₁) [𝒞 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [𝒟 : category_theory.category.{v₂ u₂} D], category_theory.category.{(max v₁ v₂) (max u₁ u₂)} (prod.{u₁ u₂} C D)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type (v₁+1)) [_inst_2 : category_theory.category.{v₁ v₁+1} D], Type (max v₁ u₁ (v₁+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`prod C D` gives the cartesian product of two categories.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128  open yoneda</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130  def yoneda_evaluation : Cᵒᵖ × (Cᵒᵖ ⥤ Type v₁) ⥤ Type (max u₁ v₁) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁ → Type (max v₁ u₁ (v₁+1)) → Type (max u₁ v₁ u₁ (v₁+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type (v₁+1)) [_inst_2 : category_theory.category.{v₁ v₁+1} D], Type (max v₁ u₁ (v₁+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π (C : Type (max u₁ v₁ u₁ (v₁+1))) [_inst_1 : category_theory.category.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} C] (D : Type ((max u₁ v₁)+1)) [_inst_2 : category_theory.category.{(max u₁ v₁) (max u₁ v₁)+1} D], Type (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131  evaluation_uncurried Cᵒᵖ (Type v₁) ⋙ ulift_functor.{u₁}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.evaluation_uncurried'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.ulift_functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/products/basic.lean&#x27;, &#x27;line&#x27;: 105, &#x27;column&#x27;: 21}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/types.lean&#x27;, &#x27;line&#x27;: 55, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (C : Type u₁) [𝒞 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [𝒟 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{(max v₁ u₁ v₂) v₂ (max u₁ v₁ v₂ u₁ u₂) u₂} (prod.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)) (@category_theory.prod.{v₁ (max u₁ v₂) u₁ (max v₁ v₂ u₁ u₂)} C 𝒞 (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)) D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {C : Type (max u₁ v₁ u₁ (v₁+1))} [𝒞 : category_theory.category.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} C] {D : Type (v₁+1)} [𝒟 : category_theory.category.{v₁ v₁+1} D] {E : Type ((max u₁ v₁)+1)} [ℰ : category_theory.category.{(max u₁ v₁) (max u₁ v₁)+1} E], @category_theory.functor.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1} C 𝒞 D 𝒟 → @category_theory.functor.{v₁ (max u₁ v₁) v₁+1 (max u₁ v₁)+1} D 𝒟 E ℰ → @category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u (max u v) u+1 (max u v)+1} (Type u) category_theory.types.{u} (Type (max u v)) category_theory.types.{(max u v)}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133  @[simp] lemma yoneda_evaluation_map_down</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134    (P Q : Cᵒᵖ × (Cᵒᵖ ⥤ Type v₁)) (α : P ⟶ Q) (x : (yoneda_evaluation C).obj P) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='P'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.yoneda_evaluation'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='P'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 130, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁ → Type (max v₁ u₁ (v₁+1)) → Type (max u₁ v₁ u₁ (v₁+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type (v₁+1)) [_inst_2 : category_theory.category.{v₁ v₁+1} D], Type (max v₁ u₁ (v₁+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max u₁ v₁ u₁ (v₁+1))} [c : category_theory.has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} obj], obj → obj → Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π (C : Type u₁) [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞) (Type (max u₁ v₁)) category_theory.types.{(max u₁ v₁)}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max u₁ v₁ u₁ (v₁+1))} [_inst_1 : category_theory.category.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} C] {D : Type ((max u₁ v₁)+1)} [_inst_2 : category_theory.category.{(max u₁ v₁) (max u₁ v₁)+1} D], @category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135    ((yoneda_evaluation C).map α x).down = α.2.app Q.1 (P.2.map α.1 x.down) := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.yoneda_evaluation'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ulift.down'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='P'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='ulift.down'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;line&#x27;: 130, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 993, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 993, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π (C : Type u₁) [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞) (Type (max u₁ v₁)) category_theory.types.{(max u₁ v₁)}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max u₁ v₁ u₁ (v₁+1))} [_inst_1 : category_theory.category.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} C] {D : Type ((max u₁ v₁)+1)} [_inst_2 : category_theory.category.{(max u₁ v₁) (max u₁ v₁)+1} D] (c : @category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} C (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} C _inst_1)) X Y → @category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁)+1} D (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁)+1} D (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁)+1} D _inst_2)) (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞))) P Q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞) (Type (max u₁ v₁)) category_theory.types.{(max u₁ v₁)} (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞) P'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type v₁}, ulift.{u₁ v₁} α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₁}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞))) P Q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v₁} {β : Type (max u₁ v₁)}, prod.{v₁ (max u₁ v₁)} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type (v₁+1)} [𝒟 : category_theory.category.{v₁ v₁+1} D] {F G : @category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₁ v₁+1} D (@category_theory.category_struct.to_has_hom.{v₁ v₁+1} D (@category_theory.category.to_category_struct.{v₁ v₁+1} D 𝒟)) (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u₁} {β : Type (max v₁ u₁ (v₁+1))}, prod.{u₁ (max v₁ u₁ (v₁+1))} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u₁} {β : Type (max v₁ u₁ (v₁+1))}, prod.{u₁ (max v₁ u₁ (v₁+1))} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type (v₁+1)} [_inst_2 : category_theory.category.{v₁ v₁+1} D] (c : @category_theory.functor.{v₁ v₁ u₁ v₁+1} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₁ v₁+1} D (@category_theory.category_struct.to_has_hom.{v₁ v₁+1} D (@category_theory.category.to_category_struct.{v₁ v₁+1} D _inst_2)) (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞))) P Q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v₁} {β : Type (max u₁ v₁)}, prod.{v₁ (max u₁ v₁)} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞) (Type (max u₁ v₁)) category_theory.types.{(max u₁ v₁)} (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞) P'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v₁}, ulift.{u₁ v₁} α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type v₁} {a : α}, @eq.{v₁+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137  def yoneda_pairing : Cᵒᵖ × (Cᵒᵖ ⥤ Type v₁) ⥤ Type (max u₁ v₁) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁ → Type (max v₁ u₁ (v₁+1)) → Type (max u₁ v₁ u₁ (v₁+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type (v₁+1)) [_inst_2 : category_theory.category.{v₁ v₁+1} D], Type (max v₁ u₁ (v₁+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='Π (C : Type (max u₁ v₁ u₁ (v₁+1))) [_inst_1 : category_theory.category.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} C] (D : Type ((max u₁ v₁)+1)) [_inst_2 : category_theory.category.{(max u₁ v₁) (max u₁ v₁)+1} D], Type (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138  functor.prod yoneda.op (𝟭 (Cᵒᵖ ⥤ Type v₁)) ⋙ functor.hom (Cᵒᵖ ⥤ Type v₁)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.yoneda'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.functor.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/products/basic.lean&#x27;, &#x27;line&#x27;: 126, &#x27;column&#x27;: 21}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 26, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 21}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 74, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/hom_functor.lean&#x27;, &#x27;line&#x27;: 24, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {A : Type u₁} [𝒜 : category_theory.category.{v₁ u₁} A] {B : Type u₂} [ℬ : category_theory.category.{v₂ u₂} B] {C : Type u₃} [𝒞 : category_theory.category.{v₃ u₃} C] {D : Type u₄} [𝒟 : category_theory.category.{v₄ u₄} D], @category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ → @category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 → @category_theory.functor.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)} (prod.{u₁ u₃} A C) (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞) (prod.{u₂ u₄} B D) (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type (max v₁ u₁ (v₁+1))} [𝒟 : category_theory.category.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} D], @category_theory.functor.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 D 𝒟 → @category_theory.functor.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (opposite.{(max v₁ u₁ (v₁+1))+1} D) (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} D 𝒟)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (C : Type (max v₁ u₁ (v₁+1))) [𝒞 : category_theory.category.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} C], @category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))} C 𝒞 C 𝒞'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type (v₁+1)) [_inst_2 : category_theory.category.{v₁ v₁+1} D], Type (max v₁ u₁ (v₁+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Π {C : Type (max u₁ v₁ u₁ (v₁+1))} [𝒞 : category_theory.category.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} C] {D : Type (max v₁ u₁ (v₁+1))} [𝒟 : category_theory.category.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} D] {E : Type ((max u₁ v₁)+1)} [ℰ : category_theory.category.{(max u₁ v₁) (max u₁ v₁)+1} E], @category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))} C 𝒞 D 𝒟 → @category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max v₁ u₁ (v₁+1)) (max u₁ v₁)+1} D 𝒟 E ℰ → @category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1} C 𝒞 E ℰ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u) [𝒞 : category_theory.category.{v u} C], @category_theory.functor.{v v u v+1} (prod.{u u} (opposite.{u+1} C) C) (@category_theory.uniform_prod.{v u} (opposite.{u+1} C) (@category_theory.category.opposite.{v u} C 𝒞) C 𝒞) (Type v) category_theory.types.{v}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type (v₁+1)) [_inst_2 : category_theory.category.{v₁ v₁+1} D], Type (max v₁ u₁ (v₁+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The cartesian product of two functors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`𝟭 C` is the identity functor on a category `C`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`F ⋙ G` is the composition of a functor `F` and a functor `G` (`F` first, then `G`).'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`functor.hom` is the hom-pairing, sending (X,Y) to X → Y, contravariant in X and covariant in Y.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140  @[simp] lemma yoneda_pairing_map</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141    (P Q : Cᵒᵖ × (Cᵒᵖ ⥤ Type v₁)) (α : P ⟶ Q) (β : (yoneda_pairing C).obj P) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='P'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.yoneda_pairing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='P'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;line&#x27;: 137, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁ → Type (max v₁ u₁ (v₁+1)) → Type (max u₁ v₁ u₁ (v₁+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type (v₁+1)) [_inst_2 : category_theory.category.{v₁ v₁+1} D], Type (max v₁ u₁ (v₁+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max u₁ v₁ u₁ (v₁+1))} [c : category_theory.has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} obj], obj → obj → Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='Π (C : Type u₁) [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞) (Type (max u₁ v₁)) category_theory.types.{(max u₁ v₁)}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max u₁ v₁ u₁ (v₁+1))} [_inst_1 : category_theory.category.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} C] {D : Type ((max u₁ v₁)+1)} [_inst_2 : category_theory.category.{(max u₁ v₁) (max u₁ v₁)+1} D], @category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142    (yoneda_pairing C).map α β = yoneda.map α.1.unop ≫ β ≫ α.2 := rfl</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.yoneda_pairing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.yoneda'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom.unop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.category_struct.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='rfl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 137, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 26, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 187, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (C : Type u₁) [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞) (Type (max u₁ v₁)) category_theory.types.{(max u₁ v₁)}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max u₁ v₁ u₁ (v₁+1))} [_inst_1 : category_theory.category.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} C] {D : Type ((max u₁ v₁)+1)} [_inst_2 : category_theory.category.{(max u₁ v₁) (max u₁ v₁)+1} D] (c : @category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} C (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} C (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} C _inst_1)) X Y → @category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁)+1} D (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁)+1} D (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁)+1} D _inst_2)) (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞))) P Q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞) (Type (max u₁ v₁)) category_theory.types.{(max u₁ v₁)} (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞) P'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type (max u₁ v₁)}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type (max v₁ u₁ (v₁+1))} [_inst_2 : category_theory.category.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} D] (c : @category_theory.functor.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} D (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} D (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} D _inst_2)) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞))) P Q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v₁} {β : Type (max u₁ v₁)}, prod.{v₁ (max u₁ v₁)} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.has_hom.{v₁ u₁} C] {X Y : opposite.{u₁+1} C}, @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.has_hom.opposite.{v₁ u₁} C 𝒞) X Y → @category_theory.has_hom.hom.{v₁ u₁} C 𝒞 (@opposite.unop.{u₁+1} C Y) (@opposite.unop.{u₁+1} C X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {obj : Type (max v₁ u₁ (v₁+1))} [c : category_theory.category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} obj (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} obj c) X Y → @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} obj (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} obj c) Y Z → @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} obj (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞) (Type (max u₁ v₁)) category_theory.types.{(max u₁ v₁)} (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞) P'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v₁ u₁ (v₁+1))} [c : category_theory.category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} obj] {X Y Z : obj}, @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} obj (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} obj c) X Y → @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} obj (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} obj c) Y Z → @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} obj (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} obj c) X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞))) P Q'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v₁} {β : Type (max u₁ v₁)}, prod.{v₁ (max u₁ v₁)} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='∀ {α : Type (max u₁ v₁)} {a : α}, @eq.{(max u₁ v₁)+1} α a a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144  def yoneda_lemma : yoneda_pairing C ≅ yoneda_evaluation C :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='category_theory.yoneda_pairing'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.yoneda_evaluation'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='red'><a title='{&#x27;line&#x27;: 137, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 130, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='Π (C : Type u₁) [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞) (Type (max u₁ v₁)) category_theory.types.{(max u₁ v₁)}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))} [_inst_1 : category_theory.category.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁) (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))} C], C → C → Type (max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞) (Type (max u₁ v₁)) category_theory.types.{(max u₁ v₁)}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145  { hom :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146    { app := λ F x, ulift.up ((x.app F.1) (𝟙 (unop F.1))),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ulift.up'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='category_theory.category_struct.id'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='opposite.unop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 993, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 48, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞) (Type (max u₁ v₁)) category_theory.types.{(max u₁ v₁)} (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type s}, α → ulift.{r s} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞) (Type (max u₁ v₁)) category_theory.types.{(max u₁ v₁)} (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type (v₁+1)} [𝒟 : category_theory.category.{v₁ v₁+1} D] {F G : @category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₁ v₁+1} D (@category_theory.category_struct.to_has_hom.{v₁ v₁+1} D (@category_theory.category.to_category_struct.{v₁ v₁+1} D 𝒟)) (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u₁} {β : Type (max v₁ u₁ (v₁+1))}, prod.{u₁ (max v₁ u₁ (v₁+1))} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {obj : Type u₁} [c : category_theory.category_struct.{v₁ u₁} obj] (X : obj), @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj c) X X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u}, opposite.{u} α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u₁} {β : Type (max v₁ u₁ (v₁+1))}, prod.{u₁ (max v₁ u₁ (v₁+1))} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147      naturality&#x27; :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148      begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C
⊢ ∀
  ⦃X Y :
    prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
         (Type v₁)
         category_theory.types.{v₁})⦄
  (f :
    @category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
      (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}))
      (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
         (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
               (Type v₁)
               category_theory.types.{v₁}))
         (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)))
      X
      Y),
    @eq.{(max u₁ v₁)+1}
      (@category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
         (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
            (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
               category_theory.types.{(max u₁ v₁)}))
         (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
            X)
         (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
            Y))
      (@category_theory.category_struct.comp.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
         (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)})
         (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
            X)
         (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
            Y)
         (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
            Y)
         (@category_theory.functor.map.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
            X
            Y
            f)
         (λ
          (x :
            @category_theory.functor.obj.{(max u₁ v₁)
              (max u₁ v₁)
              (max u₁ v₁ u₁ (v₁+1))
              (max u₁ v₁)+1}
              (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                    (Type v₁)
                    category_theory.types.{v₁}))
              (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
              (Type (max u₁ v₁))
              category_theory.types.{(max u₁ v₁)}
              (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
              Y),
            @ulift.up.{u₁ v₁}
              (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
                 (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁}))
                 (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                 (Type v₁)
                 category_theory.types.{v₁}
                 (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                    (Type v₁)
                    category_theory.types.{v₁})
                 Y)
              (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                 (Type v₁)
                 category_theory.types.{v₁}
                 (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁})
                    (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                       (opposite.{(max v₁ u₁ (v₁+1))+1}
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁})
                       (@category_theory.functor.obj.{(max u₁ v₁)
                          (max u₁ v₁)
                          (max u₁ v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))}
                          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                          (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                             (opposite.{(max v₁ u₁ (v₁+1))+1}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.prod.{(max u₁ v₁)
                             (max u₁ v₁)
                             (max v₁ u₁ (v₁+1))
                             (max v₁ u₁ (v₁+1))}
                             (opposite.{(max v₁ u₁ (v₁+1))+1}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.prod.{v₁
                             (max u₁ v₁)
                             (max u₁ v₁)
                             (max u₁ v₁)
                             u₁
                             (max v₁ u₁ (v₁+1))
                             (max v₁ u₁ (v₁+1))
                             (max v₁ u₁ (v₁+1))}
                             (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (opposite.{(max v₁ u₁ (v₁+1))+1}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                             (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})))
                          Y)))
                 (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                    (opposite.{(max v₁ u₁ (v₁+1))+1}
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}))
                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁})
                    (@category_theory.functor.obj.{(max u₁ v₁)
                       (max u₁ v₁)
                       (max u₁ v₁ u₁ (v₁+1))
                       (max v₁ u₁ (v₁+1))}
                       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                       (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.prod.{(max u₁ v₁)
                          (max u₁ v₁)
                          (max v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))}
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.functor.prod.{v₁
                          (max u₁ v₁)
                          (max u₁ v₁)
                          (max u₁ v₁)
                          u₁
                          (max v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))}
                          (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                          (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})))
                       Y))
                 x
                 (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁})
                    Y)
                 (@category_theory.category_struct.id.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C
                       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          Y))))))
      (@category_theory.category_struct.comp.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
         (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)})
         (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
            X)
         (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
            X)
         (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
            Y)
         (λ
          (x :
            @category_theory.functor.obj.{(max u₁ v₁)
              (max u₁ v₁)
              (max u₁ v₁ u₁ (v₁+1))
              (max u₁ v₁)+1}
              (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                    (Type v₁)
                    category_theory.types.{v₁}))
              (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
              (Type (max u₁ v₁))
              category_theory.types.{(max u₁ v₁)}
              (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
              X),
            @ulift.up.{u₁ v₁}
              (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
                 (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁}))
                 (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                 (Type v₁)
                 category_theory.types.{v₁}
                 (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                    (Type v₁)
                    category_theory.types.{v₁})
                 X)
              (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                 (Type v₁)
                 category_theory.types.{v₁}
                 (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁})
                    (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                       (opposite.{(max v₁ u₁ (v₁+1))+1}
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁})
                       (@category_theory.functor.obj.{(max u₁ v₁)
                          (max u₁ v₁)
                          (max u₁ v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))}
                          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                          (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                             (opposite.{(max v₁ u₁ (v₁+1))+1}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.prod.{(max u₁ v₁)
                             (max u₁ v₁)
                             (max v₁ u₁ (v₁+1))
                             (max v₁ u₁ (v₁+1))}
                             (opposite.{(max v₁ u₁ (v₁+1))+1}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.prod.{v₁
                             (max u₁ v₁)
                             (max u₁ v₁)
                             (max u₁ v₁)
                             u₁
                             (max v₁ u₁ (v₁+1))
                             (max v₁ u₁ (v₁+1))
                             (max v₁ u₁ (v₁+1))}
                             (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (opposite.{(max v₁ u₁ (v₁+1))+1}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                             (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})))
                          X)))
                 (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                    (opposite.{(max v₁ u₁ (v₁+1))+1}
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}))
                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁})
                    (@category_theory.functor.obj.{(max u₁ v₁)
                       (max u₁ v₁)
                       (max u₁ v₁ u₁ (v₁+1))
                       (max v₁ u₁ (v₁+1))}
                       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                       (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.prod.{(max u₁ v₁)
                          (max u₁ v₁)
                          (max v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))}
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.functor.prod.{v₁
                          (max u₁ v₁)
                          (max u₁ v₁)
                          (max u₁ v₁)
                          u₁
                          (max v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))}
                          (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                          (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})))
                       X))
                 x
                 (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁})
                    X)
                 (@category_theory.category_struct.id.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C
                       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          X)))))
         (@category_theory.functor.map.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
            X
            Y
            f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149        intros X Y f, ext, dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C
⊢ ∀
  ⦃X Y :
    prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
         (Type v₁)
         category_theory.types.{v₁})⦄
  (f :
    @category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
      (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}))
      (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
         (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
               (Type v₁)
               category_theory.types.{v₁}))
         (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)))
      X
      Y),
    @eq.{(max u₁ v₁)+1}
      (@category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
         (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
            (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
               category_theory.types.{(max u₁ v₁)}))
         (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
            X)
         (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
            Y))
      (@category_theory.category_struct.comp.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
         (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)})
         (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
            X)
         (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
            Y)
         (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
            Y)
         (@category_theory.functor.map.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
            X
            Y
            f)
         (λ
          (x :
            @category_theory.functor.obj.{(max u₁ v₁)
              (max u₁ v₁)
              (max u₁ v₁ u₁ (v₁+1))
              (max u₁ v₁)+1}
              (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                    (Type v₁)
                    category_theory.types.{v₁}))
              (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
              (Type (max u₁ v₁))
              category_theory.types.{(max u₁ v₁)}
              (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
              Y),
            @ulift.up.{u₁ v₁}
              (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
                 (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁}))
                 (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                 (Type v₁)
                 category_theory.types.{v₁}
                 (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                    (Type v₁)
                    category_theory.types.{v₁})
                 Y)
              (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                 (Type v₁)
                 category_theory.types.{v₁}
                 (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁})
                    (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                       (opposite.{(max v₁ u₁ (v₁+1))+1}
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁})
                       (@category_theory.functor.obj.{(max u₁ v₁)
                          (max u₁ v₁)
                          (max u₁ v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))}
                          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                          (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                             (opposite.{(max v₁ u₁ (v₁+1))+1}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.prod.{(max u₁ v₁)
                             (max u₁ v₁)
                             (max v₁ u₁ (v₁+1))
                             (max v₁ u₁ (v₁+1))}
                             (opposite.{(max v₁ u₁ (v₁+1))+1}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.prod.{v₁
                             (max u₁ v₁)
                             (max u₁ v₁)
                             (max u₁ v₁)
                             u₁
                             (max v₁ u₁ (v₁+1))
                             (max v₁ u₁ (v₁+1))
                             (max v₁ u₁ (v₁+1))}
                             (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (opposite.{(max v₁ u₁ (v₁+1))+1}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                             (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})))
                          Y)))
                 (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                    (opposite.{(max v₁ u₁ (v₁+1))+1}
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}))
                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁})
                    (@category_theory.functor.obj.{(max u₁ v₁)
                       (max u₁ v₁)
                       (max u₁ v₁ u₁ (v₁+1))
                       (max v₁ u₁ (v₁+1))}
                       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                       (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.prod.{(max u₁ v₁)
                          (max u₁ v₁)
                          (max v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))}
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.functor.prod.{v₁
                          (max u₁ v₁)
                          (max u₁ v₁)
                          (max u₁ v₁)
                          u₁
                          (max v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))}
                          (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                          (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})))
                       Y))
                 x
                 (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁})
                    Y)
                 (@category_theory.category_struct.id.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C
                       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          Y))))))
      (@category_theory.category_struct.comp.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
         (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)})
         (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
            X)
         (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
            X)
         (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
            Y)
         (λ
          (x :
            @category_theory.functor.obj.{(max u₁ v₁)
              (max u₁ v₁)
              (max u₁ v₁ u₁ (v₁+1))
              (max u₁ v₁)+1}
              (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                    (Type v₁)
                    category_theory.types.{v₁}))
              (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
              (Type (max u₁ v₁))
              category_theory.types.{(max u₁ v₁)}
              (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
              X),
            @ulift.up.{u₁ v₁}
              (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
                 (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁}))
                 (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                 (Type v₁)
                 category_theory.types.{v₁}
                 (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                    (Type v₁)
                    category_theory.types.{v₁})
                 X)
              (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                 (Type v₁)
                 category_theory.types.{v₁}
                 (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁})
                    (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                       (opposite.{(max v₁ u₁ (v₁+1))+1}
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁})
                       (@category_theory.functor.obj.{(max u₁ v₁)
                          (max u₁ v₁)
                          (max u₁ v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))}
                          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                          (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                             (opposite.{(max v₁ u₁ (v₁+1))+1}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.prod.{(max u₁ v₁)
                             (max u₁ v₁)
                             (max v₁ u₁ (v₁+1))
                             (max v₁ u₁ (v₁+1))}
                             (opposite.{(max v₁ u₁ (v₁+1))+1}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.prod.{v₁
                             (max u₁ v₁)
                             (max u₁ v₁)
                             (max u₁ v₁)
                             u₁
                             (max v₁ u₁ (v₁+1))
                             (max v₁ u₁ (v₁+1))
                             (max v₁ u₁ (v₁+1))}
                             (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (opposite.{(max v₁ u₁ (v₁+1))+1}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                             (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})))
                          X)))
                 (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                    (opposite.{(max v₁ u₁ (v₁+1))+1}
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}))
                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁})
                    (@category_theory.functor.obj.{(max u₁ v₁)
                       (max u₁ v₁)
                       (max u₁ v₁ u₁ (v₁+1))
                       (max v₁ u₁ (v₁+1))}
                       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                       (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.prod.{(max u₁ v₁)
                          (max u₁ v₁)
                          (max v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))}
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.functor.prod.{v₁
                          (max u₁ v₁)
                          (max u₁ v₁)
                          (max u₁ v₁)
                          u₁
                          (max v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))}
                          (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                          (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})))
                       X))
                 x
                 (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁})
                    X)
                 (@category_theory.category_struct.id.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                    (@opposite.unop.{u₁+1} C
                       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          X)))))
         (@category_theory.functor.map.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
            X
            Y
            f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
f :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}))
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)))
    X
    Y
⊢ @eq.{(max u₁ v₁)+1}
    (@category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
       (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
          (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
             category_theory.types.{(max u₁ v₁)}))
       (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)}
          (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
          X)
       (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)}
          (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
          Y))
    (@category_theory.category_struct.comp.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)})
       (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)}
          (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
          X)
       (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)}
          (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
          Y)
       (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)}
          (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
          Y)
       (@category_theory.functor.map.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)}
          (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
          X
          Y
          f)
       (λ
        (x :
          @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
            Y),
          @ulift.up.{u₁ v₁}
            (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
               (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁}))
               (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
               (Type v₁)
               category_theory.types.{v₁}
               (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               Y)
            (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
               (Type v₁)
               category_theory.types.{v₁}
               (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.obj.{(max u₁ v₁)
                        (max u₁ v₁)
                        (max u₁ v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                        (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.prod.{(max u₁ v₁)
                           (max u₁ v₁)
                           (max v₁ u₁ (v₁+1))
                           (max v₁ u₁ (v₁+1))}
                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.prod.{v₁
                           (max u₁ v₁)
                           (max u₁ v₁)
                           (max u₁ v₁)
                           u₁
                           (max v₁ u₁ (v₁+1))
                           (max v₁ u₁ (v₁+1))
                           (max v₁ u₁ (v₁+1))}
                           (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                           (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})))
                        Y)))
               (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@category_theory.functor.obj.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod.{(max u₁ v₁)
                        (max u₁ v₁)
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.prod.{v₁
                        (max u₁ v₁)
                        (max u₁ v₁)
                        (max u₁ v₁)
                        u₁
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                        (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})))
                     Y))
               x
               (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  Y)
               (@category_theory.category_struct.id.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                  (@opposite.unop.{u₁+1} C
                     (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        Y))))))
    (@category_theory.category_struct.comp.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)})
       (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)}
          (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
          X)
       (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)}
          (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
          X)
       (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)}
          (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
          Y)
       (λ
        (x :
          @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
            X),
          @ulift.up.{u₁ v₁}
            (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
               (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁}))
               (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
               (Type v₁)
               category_theory.types.{v₁}
               (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               X)
            (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
               (Type v₁)
               category_theory.types.{v₁}
               (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.obj.{(max u₁ v₁)
                        (max u₁ v₁)
                        (max u₁ v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                        (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.prod.{(max u₁ v₁)
                           (max u₁ v₁)
                           (max v₁ u₁ (v₁+1))
                           (max v₁ u₁ (v₁+1))}
                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.prod.{v₁
                           (max u₁ v₁)
                           (max u₁ v₁)
                           (max u₁ v₁)
                           u₁
                           (max v₁ u₁ (v₁+1))
                           (max v₁ u₁ (v₁+1))
                           (max v₁ u₁ (v₁+1))}
                           (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                           (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})))
                        X)))
               (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@category_theory.functor.obj.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod.{(max u₁ v₁)
                        (max u₁ v₁)
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.prod.{v₁
                        (max u₁ v₁)
                        (max u₁ v₁)
                        (max u₁ v₁)
                        u₁
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                        (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})))
                     X))
               x
               (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  X)
               (@category_theory.category_struct.id.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                  (@opposite.unop.{u₁+1} C
                     (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        X)))))
       (@category_theory.functor.map.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)}
          (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
          X
          Y
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
f :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}))
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)))
    X
    Y,
x :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
    X
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}))
       (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       Y)
    (@ulift.down.{u₁ v₁}
       (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@category_theory.category_struct.comp.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
          (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
             category_theory.types.{(max u₁ v₁)})
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max u₁ v₁)+1}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (Type (max u₁ v₁))
             category_theory.types.{(max u₁ v₁)}
             (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
             X)
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max u₁ v₁)+1}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (Type (max u₁ v₁))
             category_theory.types.{(max u₁ v₁)}
             (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
             Y)
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max u₁ v₁)+1}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (Type (max u₁ v₁))
             category_theory.types.{(max u₁ v₁)}
             (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
             Y)
          (@category_theory.functor.map.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max u₁ v₁)+1}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (Type (max u₁ v₁))
             category_theory.types.{(max u₁ v₁)}
             (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
             X
             Y
             f)
          (λ
           (x :
             @category_theory.functor.obj.{(max u₁ v₁)
               (max u₁ v₁)
               (max u₁ v₁ u₁ (v₁+1))
               (max u₁ v₁)+1}
               (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁}))
               (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
               (Type (max u₁ v₁))
               category_theory.types.{(max u₁ v₁)}
               (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
               Y),
             @ulift.up.{u₁ v₁}
               (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}
                  (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  Y)
               (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}
                  (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.obj.{(max u₁ v₁)
                           (max u₁ v₁)
                           (max u₁ v₁ u₁ (v₁+1))
                           (max v₁ u₁ (v₁+1))}
                           (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                           (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                              (opposite.{(max v₁ u₁ (v₁+1))+1}
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.prod.{(max u₁ v₁)
                              (max u₁ v₁)
                              (max v₁ u₁ (v₁+1))
                              (max v₁ u₁ (v₁+1))}
                              (opposite.{(max v₁ u₁ (v₁+1))+1}
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.prod.{v₁
                              (max u₁ v₁)
                              (max u₁ v₁)
                              (max u₁ v₁)
                              u₁
                              (max v₁ u₁ (v₁+1))
                              (max v₁ u₁ (v₁+1))
                              (max v₁ u₁ (v₁+1))}
                              (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (opposite.{(max v₁ u₁ (v₁+1))+1}
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                              (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})))
                           Y)))
                  (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.obj.{(max u₁ v₁)
                        (max u₁ v₁)
                        (max u₁ v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                        (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.prod.{(max u₁ v₁)
                           (max u₁ v₁)
                           (max v₁ u₁ (v₁+1))
                           (max v₁ u₁ (v₁+1))}
                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.prod.{v₁
                           (max u₁ v₁)
                           (max u₁ v₁)
                           (max u₁ v₁)
                           u₁
                           (max v₁ u₁ (v₁+1))
                           (max v₁ u₁ (v₁+1))
                           (max v₁ u₁ (v₁+1))}
                           (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                           (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})))
                        Y))
                  x
                  (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     Y)
                  (@category_theory.category_struct.id.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                     (@opposite.unop.{u₁+1} C
                        (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           Y)))))
          x))
    (@ulift.down.{u₁ v₁}
       (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@category_theory.category_struct.comp.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
          (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
             category_theory.types.{(max u₁ v₁)})
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max u₁ v₁)+1}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (Type (max u₁ v₁))
             category_theory.types.{(max u₁ v₁)}
             (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
             X)
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max u₁ v₁)+1}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (Type (max u₁ v₁))
             category_theory.types.{(max u₁ v₁)}
             (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
             X)
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max u₁ v₁)+1}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (Type (max u₁ v₁))
             category_theory.types.{(max u₁ v₁)}
             (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
             Y)
          (λ
           (x :
             @category_theory.functor.obj.{(max u₁ v₁)
               (max u₁ v₁)
               (max u₁ v₁ u₁ (v₁+1))
               (max u₁ v₁)+1}
               (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁}))
               (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
               (Type (max u₁ v₁))
               category_theory.types.{(max u₁ v₁)}
               (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
               X),
             @ulift.up.{u₁ v₁}
               (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}
                  (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  X)
               (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}
                  (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.obj.{(max u₁ v₁)
                           (max u₁ v₁)
                           (max u₁ v₁ u₁ (v₁+1))
                           (max v₁ u₁ (v₁+1))}
                           (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                           (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                              (opposite.{(max v₁ u₁ (v₁+1))+1}
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.prod.{(max u₁ v₁)
                              (max u₁ v₁)
                              (max v₁ u₁ (v₁+1))
                              (max v₁ u₁ (v₁+1))}
                              (opposite.{(max v₁ u₁ (v₁+1))+1}
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.prod.{v₁
                              (max u₁ v₁)
                              (max u₁ v₁)
                              (max u₁ v₁)
                              u₁
                              (max v₁ u₁ (v₁+1))
                              (max v₁ u₁ (v₁+1))
                              (max v₁ u₁ (v₁+1))}
                              (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (opposite.{(max v₁ u₁ (v₁+1))+1}
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                              (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})))
                           X)))
                  (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.obj.{(max u₁ v₁)
                        (max u₁ v₁)
                        (max u₁ v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                        (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.prod.{(max u₁ v₁)
                           (max u₁ v₁)
                           (max v₁ u₁ (v₁+1))
                           (max v₁ u₁ (v₁+1))}
                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.prod.{v₁
                           (max u₁ v₁)
                           (max u₁ v₁)
                           (max u₁ v₁)
                           u₁
                           (max v₁ u₁ (v₁+1))
                           (max v₁ u₁ (v₁+1))
                           (max v₁ u₁ (v₁+1))}
                           (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                           (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})))
                        X))
                  x
                  (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     X)
                  (@category_theory.category_struct.id.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                     (@opposite.unop.{u₁+1} C
                        (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           X)))))
          (@category_theory.functor.map.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max u₁ v₁)+1}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (Type (max u₁ v₁))
             category_theory.types.{(max u₁ v₁)}
             (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
             X
             Y
             f)
          x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
f :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}))
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)))
    X
    Y,
x :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
    X
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          X)
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.snd.{v₁ (max u₁ v₁)}
          (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          f)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)))
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          x
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y))
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y))
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X))
             (@category_theory.category_struct.id.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                (@opposite.unop.{u₁+1} C
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y)))
             (@category_theory.has_hom.hom.unop.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y)
                (@prod.fst.{v₁ (max u₁ v₁)}
                   (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                         (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                      (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         X)
                      (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         Y))
                   (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})))
                      (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         X)
                      (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         Y))
                   f)))))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          X)
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.snd.{v₁ (max u₁ v₁)}
          (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          f)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          (@prod.fst.{v₁ (max u₁ v₁)}
             (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y))
             (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})))
                (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)
                (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y))
             f)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}
             (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                (@opposite.unop.{u₁+1} C
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             x
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@category_theory.category_struct.id.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                (@opposite.unop.{u₁+1} C
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150        erw [category.id_comp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.category.id_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₁) [c : category_theory.category.{v₁ u₁} obj] {X Y : obj} (f : @category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y), @eq.{v₁+1} (@category_theory.has_hom.hom.{v₁ u₁} obj (@category_theory.category_struct.to_has_hom.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c)) X Y) (@category_theory.category_struct.comp.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) X X Y (@category_theory.category_struct.id.{v₁ u₁} obj (@category_theory.category.to_category_struct.{v₁ u₁} obj c) X) f) f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
f :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}))
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)))
    X
    Y,
x :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
    X
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          X)
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.snd.{v₁ (max u₁ v₁)}
          (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          f)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)))
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          x
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y))
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y))
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X))
             (@category_theory.category_struct.id.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                (@opposite.unop.{u₁+1} C
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y)))
             (@category_theory.has_hom.hom.unop.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y)
                (@prod.fst.{v₁ (max u₁ v₁)}
                   (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                         (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                      (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         X)
                      (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         Y))
                   (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})))
                      (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         X)
                      (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         Y))
                   f)))))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          X)
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.snd.{v₁ (max u₁ v₁)}
          (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          f)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          (@prod.fst.{v₁ (max u₁ v₁)}
             (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y))
             (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})))
                (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)
                (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y))
             f)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}
             (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                (@opposite.unop.{u₁+1} C
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             x
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@category_theory.category_struct.id.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                (@opposite.unop.{u₁+1} C
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
f :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}))
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)))
    X
    Y,
x :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
    X
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          X)
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.snd.{v₁ (max u₁ v₁)}
          (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          f)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)))
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          x
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          (@category_theory.has_hom.hom.unop.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y)
             (@prod.fst.{v₁ (max u₁ v₁)}
                (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})))
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                f))))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          X)
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.snd.{v₁ (max u₁ v₁)}
          (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          f)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          (@prod.fst.{v₁ (max u₁ v₁)}
             (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y))
             (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})))
                (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)
                (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y))
             f)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}
             (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                (@opposite.unop.{u₁+1} C
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             x
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@category_theory.category_struct.id.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                (@opposite.unop.{u₁+1} C
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151             ←functor_to_types.naturality,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='category_theory.functor_to_types.naturality'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/types.lean&#x27;, &#x27;line&#x27;: 42, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (F G : @category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) {X Y : C} (σ : @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}))) F G) (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y) (x : @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F X), @eq.{v₁+1} (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} G Y) (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F G σ Y (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F X Y f x)) (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} G X Y f (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F G σ X x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
f :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}))
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)))
    X
    Y,
x :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
    X
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          X)
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.snd.{v₁ (max u₁ v₁)}
          (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          f)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)))
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          x
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          (@category_theory.has_hom.hom.unop.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y)
             (@prod.fst.{v₁ (max u₁ v₁)}
                (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})))
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                f))))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          X)
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.snd.{v₁ (max u₁ v₁)}
          (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          f)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          (@prod.fst.{v₁ (max u₁ v₁)}
             (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y))
             (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})))
                (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)
                (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y))
             f)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}
             (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                (@opposite.unop.{u₁+1} C
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             x
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@category_theory.category_struct.id.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                (@opposite.unop.{u₁+1} C
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
f :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}))
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)))
    X
    Y,
x :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
    X
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          X)
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.snd.{v₁ (max u₁ v₁)}
          (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          f)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)))
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          x
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          (@category_theory.has_hom.hom.unop.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y)
             (@prod.fst.{v₁ (max u₁ v₁)}
                (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})))
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                f))))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          X)
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.snd.{v₁ (max u₁ v₁)}
          (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          f)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)))
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          x
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}
             (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                (@opposite.unop.{u₁+1} C
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y)
             (@prod.fst.{v₁ (max u₁ v₁)}
                (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})))
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                f)
             (@category_theory.category_struct.id.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                (@opposite.unop.{u₁+1} C
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152             obj_map_id,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.yoneda.obj_map_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 46, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {X Y : C} (f : @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.has_hom.opposite.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))) (@opposite.op.{u₁+1} C X) (@opposite.op.{u₁+1} C Y)), @eq.{v₁+1} (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁} (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.yoneda.{v₁ u₁} C 𝒞) X) (@opposite.op.{u₁+1} C Y)) (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁} (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.yoneda.{v₁ u₁} C 𝒞) X) (@opposite.op.{u₁+1} C X) (@opposite.op.{u₁+1} C Y) f (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X)) (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁} (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.yoneda.{v₁ u₁} C 𝒞) (@opposite.unop.{u₁+1} C (@opposite.op.{u₁+1} C Y))) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.yoneda.{v₁ u₁} C 𝒞) (@opposite.unop.{u₁+1} C (@opposite.op.{u₁+1} C X))) (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.yoneda.{v₁ u₁} C 𝒞) (@opposite.unop.{u₁+1} C (@opposite.op.{u₁+1} C Y)) (@opposite.unop.{u₁+1} C (@opposite.op.{u₁+1} C X)) (@category_theory.has_hom.hom.unop.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@opposite.op.{u₁+1} C X) (@opposite.op.{u₁+1} C Y) f)) (@opposite.op.{u₁+1} C Y) (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
f :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}))
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)))
    X
    Y,
x :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
    X
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          X)
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.snd.{v₁ (max u₁ v₁)}
          (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          f)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)))
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          x
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          (@category_theory.has_hom.hom.unop.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y)
             (@prod.fst.{v₁ (max u₁ v₁)}
                (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})))
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                f))))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          X)
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.snd.{v₁ (max u₁ v₁)}
          (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          f)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)))
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          x
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}
             (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                (@opposite.unop.{u₁+1} C
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y)
             (@prod.fst.{v₁ (max u₁ v₁)}
                (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})))
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                f)
             (@category_theory.category_struct.id.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                (@opposite.unop.{u₁+1} C
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
f :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}))
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)))
    X
    Y,
x :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
    X
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          X)
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.snd.{v₁ (max u₁ v₁)}
          (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          f)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)))
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          x
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          (@category_theory.has_hom.hom.unop.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y)
             (@prod.fst.{v₁ (max u₁ v₁)}
                (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})))
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                f))))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          X)
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.snd.{v₁ (max u₁ v₁)}
          (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          f)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)))
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          x
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}
             (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                (@opposite.unop.{u₁+1} C
                   (@opposite.op.{u₁+1} C
                      (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         Y))))
             (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                (@opposite.unop.{u₁+1} C
                   (@opposite.op.{u₁+1} C
                      (@opposite.unop.{u₁+1} C
                         (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            X)))))
             (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                (@opposite.unop.{u₁+1} C
                   (@opposite.op.{u₁+1} C
                      (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         Y)))
                (@opposite.unop.{u₁+1} C
                   (@opposite.op.{u₁+1} C
                      (@opposite.unop.{u₁+1} C
                         (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            X))))
                (@category_theory.has_hom.hom.unop.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (@opposite.op.{u₁+1} C
                      (@opposite.unop.{u₁+1} C
                         (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            X)))
                   (@opposite.op.{u₁+1} C
                      (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         Y))
                   (@prod.fst.{v₁ (max u₁ v₁)}
                      (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                            (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                         (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            X)
                         (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            Y))
                      (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})))
                         (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            X)
                         (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            Y))
                      f)))
             (@opposite.op.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y))
             (@category_theory.category_struct.id.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153             functor_to_types.naturality,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.functor_to_types.naturality'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/types.lean&#x27;, &#x27;line&#x27;: 42, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (F G : @category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) {X Y : C} (σ : @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}))) F G) (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y) (x : @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F X), @eq.{v₁+1} (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} G Y) (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F G σ Y (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F X Y f x)) (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} G X Y f (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F G σ X x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
f :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}))
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)))
    X
    Y,
x :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
    X
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          X)
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.snd.{v₁ (max u₁ v₁)}
          (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          f)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)))
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          x
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          (@category_theory.has_hom.hom.unop.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y)
             (@prod.fst.{v₁ (max u₁ v₁)}
                (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})))
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                f))))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          X)
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.snd.{v₁ (max u₁ v₁)}
          (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          f)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)))
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          x
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}
             (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                (@opposite.unop.{u₁+1} C
                   (@opposite.op.{u₁+1} C
                      (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         Y))))
             (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                (@opposite.unop.{u₁+1} C
                   (@opposite.op.{u₁+1} C
                      (@opposite.unop.{u₁+1} C
                         (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            X)))))
             (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                (@opposite.unop.{u₁+1} C
                   (@opposite.op.{u₁+1} C
                      (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         Y)))
                (@opposite.unop.{u₁+1} C
                   (@opposite.op.{u₁+1} C
                      (@opposite.unop.{u₁+1} C
                         (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            X))))
                (@category_theory.has_hom.hom.unop.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (@opposite.op.{u₁+1} C
                      (@opposite.unop.{u₁+1} C
                         (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            X)))
                   (@opposite.op.{u₁+1} C
                      (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         Y))
                   (@prod.fst.{v₁ (max u₁ v₁)}
                      (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                         (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                            (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                         (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            X)
                         (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            Y))
                      (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})))
                         (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            X)
                         (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            Y))
                      f)))
             (@opposite.op.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y))
             (@category_theory.category_struct.id.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
f :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}))
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)))
    X
    Y,
x :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
    X
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          X)
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.snd.{v₁ (max u₁ v₁)}
          (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          f)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)))
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          x
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          (@category_theory.has_hom.hom.unop.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y)
             (@prod.fst.{v₁ (max u₁ v₁)}
                (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})))
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                f))))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          X)
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.snd.{v₁ (max u₁ v₁)}
          (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          f)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}
             (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                (@opposite.unop.{u₁+1} C
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             x
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y)
             (@category_theory.has_hom.hom.unop.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (@opposite.op.{u₁+1} C
                   (@opposite.unop.{u₁+1} C
                      (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         X)))
                (@opposite.op.{u₁+1} C
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                (@prod.fst.{v₁ (max u₁ v₁)}
                   (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                         (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                      (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         X)
                      (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         Y))
                   (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})))
                      (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         X)
                      (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         Y))
                   f)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154             functor_to_types.map_id]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.functor_to_types.map_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/types.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (F : @category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) {X : C} (a : @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F X), @eq.{v₁+1} (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F X) (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F X X (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X) a) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
f :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}))
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)))
    X
    Y,
x :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
    X
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          X)
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.snd.{v₁ (max u₁ v₁)}
          (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          f)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)))
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          x
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          (@category_theory.has_hom.hom.unop.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y)
             (@prod.fst.{v₁ (max u₁ v₁)}
                (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})))
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                f))))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          X)
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.snd.{v₁ (max u₁ v₁)}
          (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          f)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}
             (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                (@opposite.unop.{u₁+1} C
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             x
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y)
             (@category_theory.has_hom.hom.unop.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (@opposite.op.{u₁+1} C
                   (@opposite.unop.{u₁+1} C
                      (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         X)))
                (@opposite.op.{u₁+1} C
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                (@prod.fst.{v₁ (max u₁ v₁)}
                   (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                         (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                      (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         X)
                      (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         Y))
                   (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})))
                      (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         X)
                      (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         Y))
                   f)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
f :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}))
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)))
    X
    Y,
x :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
    X
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          X)
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.snd.{v₁ (max u₁ v₁)}
          (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          f)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)))
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          x
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y))
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y))
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X))
             (@category_theory.category_struct.id.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                (@opposite.unop.{u₁+1} C
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y)))
             (@category_theory.has_hom.hom.unop.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y)
                (@prod.fst.{v₁ (max u₁ v₁)}
                   (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                         (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                      (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         X)
                      (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         Y))
                   (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})))
                      (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         X)
                      (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         Y))
                   f)))))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          X)
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.snd.{v₁ (max u₁ v₁)}
          (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          f)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          (@prod.fst.{v₁ (max u₁ v₁)}
             (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y))
             (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})))
                (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)
                (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y))
             f)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}
             (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                (@opposite.unop.{u₁+1} C
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             x
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@category_theory.category_struct.id.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                (@opposite.unop.{u₁+1} C
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155      end },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
f :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}))
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)))
    X
    Y,
x :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
    X
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          X)
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.snd.{v₁ (max u₁ v₁)}
          (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          f)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)))
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          x
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          (@category_theory.category_struct.comp.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y))
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y))
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X))
             (@category_theory.category_struct.id.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                (@opposite.unop.{u₁+1} C
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y)))
             (@category_theory.has_hom.hom.unop.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y)
                (@prod.fst.{v₁ (max u₁ v₁)}
                   (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                         (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                      (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         X)
                      (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         Y))
                   (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})))
                      (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         X)
                      (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         Y))
                   f)))))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          X)
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.snd.{v₁ (max u₁ v₁)}
          (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          f)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          (@prod.fst.{v₁ (max u₁ v₁)}
             (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y))
             (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})))
                (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)
                (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y))
             f)
          (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}
             (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.yoneda.{v₁ u₁} C 𝒞)
                (@opposite.unop.{u₁+1} C
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             x
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@category_theory.category_struct.id.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                (@opposite.unop.{u₁+1} C
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156    inv :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157    { app := λ F x,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞) (Type (max u₁ v₁)) category_theory.types.{(max u₁ v₁)} (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158      { app := λ X a, (F.2.map a.op) x.down,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.has_hom.hom.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='ulift.down'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/opposites.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 993, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='green'><a title='opposite.{u₁+1} C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁} (@opposite.unop.{(max v₁ u₁ (v₁+1))+1} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))} (opposite.{(max v₁ u₁ (v₁+1))+1} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞) (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))} (opposite.{(max v₁ u₁ (v₁+1))+1} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.prod.{(max u₁ v₁) (max u₁ v₁) (max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))} (opposite.{(max v₁ u₁ (v₁+1))+1} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.functor.prod.{v₁ (max u₁ v₁) (max u₁ v₁) (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (opposite.{(max v₁ u₁ (v₁+1))+1} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.yoneda.{v₁ u₁} C 𝒞)) (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}))) F))) X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u₁} {β : Type (max v₁ u₁ (v₁+1))}, prod.{u₁ (max v₁ u₁ (v₁+1))} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type (v₁+1)} [_inst_2 : category_theory.category.{v₁ v₁+1} D] (c : @category_theory.functor.{v₁ v₁ u₁ v₁+1} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₁ v₁+1} D (@category_theory.category_struct.to_has_hom.{v₁ v₁+1} D (@category_theory.category.to_category_struct.{v₁ v₁+1} D _inst_2)) (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁} (@opposite.unop.{(max v₁ u₁ (v₁+1))+1} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))} (opposite.{(max v₁ u₁ (v₁+1))+1} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞) (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))} (opposite.{(max v₁ u₁ (v₁+1))+1} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.prod.{(max u₁ v₁) (max u₁ v₁) (max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))} (opposite.{(max v₁ u₁ (v₁+1))+1} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.functor.prod.{v₁ (max u₁ v₁) (max u₁ v₁) (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (opposite.{(max v₁ u₁ (v₁+1))+1} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.yoneda.{v₁ u₁} C 𝒞)) (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}))) F))) X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.has_hom.{v₁ u₁} C] {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C 𝒞 X Y → @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.has_hom.opposite.{v₁ u₁} C 𝒞) (@opposite.op.{u₁+1} C Y) (@opposite.op.{u₁+1} C X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞) (Type (max u₁ v₁)) category_theory.types.{(max u₁ v₁)} (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞) F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v₁}, ulift.{u₁ v₁} α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159        naturality&#x27; :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160        begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
F :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
x :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
    F
⊢ ∀ ⦃X Y : opposite.{u₁+1} C⦄
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
         (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
      X
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ v₁+1} (Type v₁)
         (@category_theory.category_struct.to_has_hom.{v₁ v₁+1} (Type v₁)
            (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁}))
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@category_theory.functor.obj.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod.{(max u₁ v₁)
                        (max u₁ v₁)
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.prod.{v₁
                        (max u₁ v₁)
                        (max u₁ v₁)
                        (max u₁ v₁)
                        u₁
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                        (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})))
                     F)))
            X)
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
               (opposite.{(max v₁ u₁ (v₁+1))+1}
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁}))
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@category_theory.functor.obj.{(max u₁ v₁)
                  (max u₁ v₁)
                  (max u₁ v₁ u₁ (v₁+1))
                  (max v₁ u₁ (v₁+1))}
                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                  (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.functor.prod.{v₁
                     (max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁)
                     u₁
                     (max v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})))
                  F))
            Y))
      (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
         (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@category_theory.functor.obj.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod.{(max u₁ v₁)
                        (max u₁ v₁)
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.prod.{v₁
                        (max u₁ v₁)
                        (max u₁ v₁)
                        (max u₁ v₁)
                        u₁
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                        (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})))
                     F)))
            X)
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@category_theory.functor.obj.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod.{(max u₁ v₁)
                        (max u₁ v₁)
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.prod.{v₁
                        (max u₁ v₁)
                        (max u₁ v₁)
                        (max u₁ v₁)
                        u₁
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                        (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})))
                     F)))
            Y)
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
               (opposite.{(max v₁ u₁ (v₁+1))+1}
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁}))
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@category_theory.functor.obj.{(max u₁ v₁)
                  (max u₁ v₁)
                  (max u₁ v₁ u₁ (v₁+1))
                  (max v₁ u₁ (v₁+1))}
                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                  (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.functor.prod.{v₁
                     (max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁)
                     u₁
                     (max v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})))
                  F))
            Y)
         (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@category_theory.functor.obj.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod.{(max u₁ v₁)
                        (max u₁ v₁)
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.prod.{v₁
                        (max u₁ v₁)
                        (max u₁ v₁)
                        (max u₁ v₁)
                        u₁
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                        (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})))
                     F)))
            X
            Y
            f)
         (λ
          (a :
            @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
              (Type v₁)
              category_theory.types.{v₁}
              (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                    (Type v₁)
                    category_theory.types.{v₁})
                 (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                    (opposite.{(max v₁ u₁ (v₁+1))+1}
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}))
                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁})
                    (@category_theory.functor.obj.{(max u₁ v₁)
                       (max u₁ v₁)
                       (max u₁ v₁ u₁ (v₁+1))
                       (max v₁ u₁ (v₁+1))}
                       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                       (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.prod.{(max u₁ v₁)
                          (max u₁ v₁)
                          (max v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))}
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.functor.prod.{v₁
                          (max u₁ v₁)
                          (max u₁ v₁)
                          (max u₁ v₁)
                          u₁
                          (max v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))}
                          (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                          (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})))
                       F)))
              Y),
            @category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
              (Type v₁)
              category_theory.types.{v₁}
              (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                    (Type v₁)
                    category_theory.types.{v₁})
                 F)
              (@opposite.op.{u₁+1} C
                 (@opposite.unop.{u₁+1} C
                    (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁})
                       F)))
              Y
              (@category_theory.has_hom.hom.op.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C Y)
                 (@opposite.unop.{u₁+1} C
                    (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁})
                       F))
                 a)
              (@ulift.down.{u₁ v₁}
                 (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
                    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}))
                    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                    (Type v₁)
                    category_theory.types.{v₁}
                    (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁})
                    F)
                 x)))
      (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
         (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@category_theory.functor.obj.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod.{(max u₁ v₁)
                        (max u₁ v₁)
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.prod.{v₁
                        (max u₁ v₁)
                        (max u₁ v₁)
                        (max u₁ v₁)
                        u₁
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                        (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})))
                     F)))
            X)
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
               (opposite.{(max v₁ u₁ (v₁+1))+1}
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁}))
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@category_theory.functor.obj.{(max u₁ v₁)
                  (max u₁ v₁)
                  (max u₁ v₁ u₁ (v₁+1))
                  (max v₁ u₁ (v₁+1))}
                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                  (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.functor.prod.{v₁
                     (max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁)
                     u₁
                     (max v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})))
                  F))
            X)
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
               (opposite.{(max v₁ u₁ (v₁+1))+1}
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁}))
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@category_theory.functor.obj.{(max u₁ v₁)
                  (max u₁ v₁)
                  (max u₁ v₁ u₁ (v₁+1))
                  (max v₁ u₁ (v₁+1))}
                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                  (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.functor.prod.{v₁
                     (max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁)
                     u₁
                     (max v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})))
                  F))
            Y)
         (λ
          (a :
            @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
              (Type v₁)
              category_theory.types.{v₁}
              (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                    (Type v₁)
                    category_theory.types.{v₁})
                 (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                    (opposite.{(max v₁ u₁ (v₁+1))+1}
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}))
                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁})
                    (@category_theory.functor.obj.{(max u₁ v₁)
                       (max u₁ v₁)
                       (max u₁ v₁ u₁ (v₁+1))
                       (max v₁ u₁ (v₁+1))}
                       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                       (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.prod.{(max u₁ v₁)
                          (max u₁ v₁)
                          (max v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))}
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.functor.prod.{v₁
                          (max u₁ v₁)
                          (max u₁ v₁)
                          (max u₁ v₁)
                          u₁
                          (max v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))}
                          (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                          (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})))
                       F)))
              X),
            @category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
              (Type v₁)
              category_theory.types.{v₁}
              (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                    (Type v₁)
                    category_theory.types.{v₁})
                 F)
              (@opposite.op.{u₁+1} C
                 (@opposite.unop.{u₁+1} C
                    (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁})
                       F)))
              X
              …
              …)
         …)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161          intros X Y f, ext, dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
F :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
x :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
    F
⊢ ∀ ⦃X Y : opposite.{u₁+1} C⦄
  (f :
    @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
      (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
         (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
      X
      Y),
    @eq.{v₁+1}
      (@category_theory.has_hom.hom.{v₁ v₁+1} (Type v₁)
         (@category_theory.category_struct.to_has_hom.{v₁ v₁+1} (Type v₁)
            (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁}))
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@category_theory.functor.obj.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod.{(max u₁ v₁)
                        (max u₁ v₁)
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.prod.{v₁
                        (max u₁ v₁)
                        (max u₁ v₁)
                        (max u₁ v₁)
                        u₁
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                        (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})))
                     F)))
            X)
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
               (opposite.{(max v₁ u₁ (v₁+1))+1}
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁}))
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@category_theory.functor.obj.{(max u₁ v₁)
                  (max u₁ v₁)
                  (max u₁ v₁ u₁ (v₁+1))
                  (max v₁ u₁ (v₁+1))}
                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                  (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.functor.prod.{v₁
                     (max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁)
                     u₁
                     (max v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})))
                  F))
            Y))
      (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
         (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@category_theory.functor.obj.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod.{(max u₁ v₁)
                        (max u₁ v₁)
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.prod.{v₁
                        (max u₁ v₁)
                        (max u₁ v₁)
                        (max u₁ v₁)
                        u₁
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                        (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})))
                     F)))
            X)
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@category_theory.functor.obj.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod.{(max u₁ v₁)
                        (max u₁ v₁)
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.prod.{v₁
                        (max u₁ v₁)
                        (max u₁ v₁)
                        (max u₁ v₁)
                        u₁
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                        (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})))
                     F)))
            Y)
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
               (opposite.{(max v₁ u₁ (v₁+1))+1}
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁}))
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@category_theory.functor.obj.{(max u₁ v₁)
                  (max u₁ v₁)
                  (max u₁ v₁ u₁ (v₁+1))
                  (max v₁ u₁ (v₁+1))}
                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                  (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.functor.prod.{v₁
                     (max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁)
                     u₁
                     (max v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})))
                  F))
            Y)
         (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@category_theory.functor.obj.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod.{(max u₁ v₁)
                        (max u₁ v₁)
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.prod.{v₁
                        (max u₁ v₁)
                        (max u₁ v₁)
                        (max u₁ v₁)
                        u₁
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                        (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})))
                     F)))
            X
            Y
            f)
         (λ
          (a :
            @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
              (Type v₁)
              category_theory.types.{v₁}
              (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                    (Type v₁)
                    category_theory.types.{v₁})
                 (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                    (opposite.{(max v₁ u₁ (v₁+1))+1}
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}))
                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁})
                    (@category_theory.functor.obj.{(max u₁ v₁)
                       (max u₁ v₁)
                       (max u₁ v₁ u₁ (v₁+1))
                       (max v₁ u₁ (v₁+1))}
                       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                       (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.prod.{(max u₁ v₁)
                          (max u₁ v₁)
                          (max v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))}
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.functor.prod.{v₁
                          (max u₁ v₁)
                          (max u₁ v₁)
                          (max u₁ v₁)
                          u₁
                          (max v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))}
                          (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                          (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})))
                       F)))
              Y),
            @category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
              (Type v₁)
              category_theory.types.{v₁}
              (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                    (Type v₁)
                    category_theory.types.{v₁})
                 F)
              (@opposite.op.{u₁+1} C
                 (@opposite.unop.{u₁+1} C
                    (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁})
                       F)))
              Y
              (@category_theory.has_hom.hom.op.{v₁ u₁} C
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                    (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                 (@opposite.unop.{u₁+1} C Y)
                 (@opposite.unop.{u₁+1} C
                    (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁})
                       F))
                 a)
              (@ulift.down.{u₁ v₁}
                 (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
                    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}))
                    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                    (Type v₁)
                    category_theory.types.{v₁}
                    (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁})
                    F)
                 x)))
      (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
         (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@category_theory.functor.obj.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod.{(max u₁ v₁)
                        (max u₁ v₁)
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.prod.{v₁
                        (max u₁ v₁)
                        (max u₁ v₁)
                        (max u₁ v₁)
                        u₁
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                        (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})))
                     F)))
            X)
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
               (opposite.{(max v₁ u₁ (v₁+1))+1}
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁}))
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@category_theory.functor.obj.{(max u₁ v₁)
                  (max u₁ v₁)
                  (max u₁ v₁ u₁ (v₁+1))
                  (max v₁ u₁ (v₁+1))}
                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                  (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.functor.prod.{v₁
                     (max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁)
                     u₁
                     (max v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})))
                  F))
            X)
         (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
               (opposite.{(max v₁ u₁ (v₁+1))+1}
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁}))
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@category_theory.functor.obj.{(max u₁ v₁)
                  (max u₁ v₁)
                  (max u₁ v₁ u₁ (v₁+1))
                  (max v₁ u₁ (v₁+1))}
                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                  (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.functor.prod.{v₁
                     (max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁)
                     u₁
                     (max v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})))
                  F))
            Y)
         (λ
          (a :
            @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
              (Type v₁)
              category_theory.types.{v₁}
              (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                    (Type v₁)
                    category_theory.types.{v₁})
                 (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                    (opposite.{(max v₁ u₁ (v₁+1))+1}
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}))
                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁})
                    (@category_theory.functor.obj.{(max u₁ v₁)
                       (max u₁ v₁)
                       (max u₁ v₁ u₁ (v₁+1))
                       (max v₁ u₁ (v₁+1))}
                       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                       (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.prod.{(max u₁ v₁)
                          (max u₁ v₁)
                          (max v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))}
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.functor.prod.{v₁
                          (max u₁ v₁)
                          (max u₁ v₁)
                          (max u₁ v₁)
                          u₁
                          (max v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))}
                          (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                          (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})))
                       F)))
              X),
            @category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
              (Type v₁)
              category_theory.types.{v₁}
              (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                    (Type v₁)
                    category_theory.types.{v₁})
                 F)
              (@opposite.op.{u₁+1} C
                 (@opposite.unop.{u₁+1} C
                    (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁})
                       F)))
              X
              …
              …)
         …)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
F :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
x :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
    F,
X Y : opposite.{u₁+1} C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
    X
    Y
⊢ @eq.{v₁+1}
    (@category_theory.has_hom.hom.{v₁ v₁+1} (Type v₁)
       (@category_theory.category_struct.to_has_hom.{v₁ v₁+1} (Type v₁)
          (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁}))
       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.obj.{(max u₁ v₁)
                   (max u₁ v₁)
                   (max u₁ v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))}
                   (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                   (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.prod.{(max u₁ v₁)
                      (max u₁ v₁)
                      (max v₁ u₁ (v₁+1))
                      (max v₁ u₁ (v₁+1))}
                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.prod.{v₁
                      (max u₁ v₁)
                      (max u₁ v₁)
                      (max u₁ v₁)
                      u₁
                      (max v₁ u₁ (v₁+1))
                      (max v₁ u₁ (v₁+1))
                      (max v₁ u₁ (v₁+1))}
                      (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                      (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})))
                   F)))
          X)
       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
             (opposite.{(max v₁ u₁ (v₁+1))+1}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.obj.{(max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod.{(max u₁ v₁)
                   (max u₁ v₁)
                   (max v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))}
                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.prod.{v₁
                   (max u₁ v₁)
                   (max u₁ v₁)
                   (max u₁ v₁)
                   u₁
                   (max v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))}
                   (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                   (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})))
                F))
          Y))
    (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
       (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.obj.{(max u₁ v₁)
                   (max u₁ v₁)
                   (max u₁ v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))}
                   (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                   (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.prod.{(max u₁ v₁)
                      (max u₁ v₁)
                      (max v₁ u₁ (v₁+1))
                      (max v₁ u₁ (v₁+1))}
                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.prod.{v₁
                      (max u₁ v₁)
                      (max u₁ v₁)
                      (max u₁ v₁)
                      u₁
                      (max v₁ u₁ (v₁+1))
                      (max v₁ u₁ (v₁+1))
                      (max v₁ u₁ (v₁+1))}
                      (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                      (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})))
                   F)))
          X)
       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.obj.{(max u₁ v₁)
                   (max u₁ v₁)
                   (max u₁ v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))}
                   (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                   (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.prod.{(max u₁ v₁)
                      (max u₁ v₁)
                      (max v₁ u₁ (v₁+1))
                      (max v₁ u₁ (v₁+1))}
                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.prod.{v₁
                      (max u₁ v₁)
                      (max u₁ v₁)
                      (max u₁ v₁)
                      u₁
                      (max v₁ u₁ (v₁+1))
                      (max v₁ u₁ (v₁+1))
                      (max v₁ u₁ (v₁+1))}
                      (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                      (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})))
                   F)))
          Y)
       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
             (opposite.{(max v₁ u₁ (v₁+1))+1}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.obj.{(max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod.{(max u₁ v₁)
                   (max u₁ v₁)
                   (max v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))}
                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.prod.{v₁
                   (max u₁ v₁)
                   (max u₁ v₁)
                   (max u₁ v₁)
                   u₁
                   (max v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))}
                   (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                   (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})))
                F))
          Y)
       (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.obj.{(max u₁ v₁)
                   (max u₁ v₁)
                   (max u₁ v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))}
                   (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                   (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.prod.{(max u₁ v₁)
                      (max u₁ v₁)
                      (max v₁ u₁ (v₁+1))
                      (max v₁ u₁ (v₁+1))}
                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.prod.{v₁
                      (max u₁ v₁)
                      (max u₁ v₁)
                      (max u₁ v₁)
                      u₁
                      (max v₁ u₁ (v₁+1))
                      (max v₁ u₁ (v₁+1))
                      (max v₁ u₁ (v₁+1))}
                      (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                      (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})))
                   F)))
          X
          Y
          f)
       (λ
        (a :
          @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@category_theory.functor.obj.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod.{(max u₁ v₁)
                        (max u₁ v₁)
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.prod.{v₁
                        (max u₁ v₁)
                        (max u₁ v₁)
                        (max u₁ v₁)
                        u₁
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                        (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})))
                     F)))
            Y),
          @category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               F)
            (@opposite.op.{u₁+1} C
               (@opposite.unop.{u₁+1} C
                  (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     F)))
            Y
            (@category_theory.has_hom.hom.op.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C Y)
               (@opposite.unop.{u₁+1} C
                  (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     F))
               a)
            (@ulift.down.{u₁ v₁}
               (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}
                  (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  F)
               x)))
    (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
       (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.obj.{(max u₁ v₁)
                   (max u₁ v₁)
                   (max u₁ v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))}
                   (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                   (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.prod.{(max u₁ v₁)
                      (max u₁ v₁)
                      (max v₁ u₁ (v₁+1))
                      (max v₁ u₁ (v₁+1))}
                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.prod.{v₁
                      (max u₁ v₁)
                      (max u₁ v₁)
                      (max u₁ v₁)
                      u₁
                      (max v₁ u₁ (v₁+1))
                      (max v₁ u₁ (v₁+1))
                      (max v₁ u₁ (v₁+1))}
                      (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                      (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})))
                   F)))
          X)
       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
             (opposite.{(max v₁ u₁ (v₁+1))+1}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.obj.{(max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod.{(max u₁ v₁)
                   (max u₁ v₁)
                   (max v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))}
                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.prod.{v₁
                   (max u₁ v₁)
                   (max u₁ v₁)
                   (max u₁ v₁)
                   u₁
                   (max v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))}
                   (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                   (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})))
                F))
          X)
       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
             (opposite.{(max v₁ u₁ (v₁+1))+1}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.obj.{(max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod.{(max u₁ v₁)
                   (max u₁ v₁)
                   (max v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))}
                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.prod.{v₁
                   (max u₁ v₁)
                   (max u₁ v₁)
                   (max u₁ v₁)
                   u₁
                   (max v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))}
                   (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                   (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})))
                F))
          Y)
       (λ
        (a :
          @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@category_theory.functor.obj.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod.{(max u₁ v₁)
                        (max u₁ v₁)
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.prod.{v₁
                        (max u₁ v₁)
                        (max u₁ v₁)
                        (max u₁ v₁)
                        u₁
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                        (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})))
                     F)))
            X),
          @category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               F)
            (@opposite.op.{u₁+1} C
               (@opposite.unop.{u₁+1} C
                  (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     F)))
            X
            (@category_theory.has_hom.hom.op.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C X)
               (@opposite.unop.{u₁+1} C …)
               a)
            …)
       …)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
F :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
x :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
    F,
X Y : opposite.{u₁+1} C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
    X
    Y,
x_1 :
  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
    (Type v₁)
    category_theory.types.{v₁}
    (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
          (opposite.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max v₁ u₁ (v₁+1))}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod.{(max u₁ v₁) (max u₁ v₁) (max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.prod.{v₁
                (max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁)
                u₁
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             F)))
    X
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
          (opposite.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max v₁ u₁ (v₁+1))}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod.{(max u₁ v₁) (max u₁ v₁) (max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.prod.{v₁
                (max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁)
                u₁
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             F))
       Y)
    (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
       (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.obj.{(max u₁ v₁)
                   (max u₁ v₁)
                   (max u₁ v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))}
                   (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                   (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.prod.{(max u₁ v₁)
                      (max u₁ v₁)
                      (max v₁ u₁ (v₁+1))
                      (max v₁ u₁ (v₁+1))}
                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.prod.{v₁
                      (max u₁ v₁)
                      (max u₁ v₁)
                      (max u₁ v₁)
                      u₁
                      (max v₁ u₁ (v₁+1))
                      (max v₁ u₁ (v₁+1))
                      (max v₁ u₁ (v₁+1))}
                      (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                      (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})))
                   F)))
          X)
       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.obj.{(max u₁ v₁)
                   (max u₁ v₁)
                   (max u₁ v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))}
                   (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                   (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.prod.{(max u₁ v₁)
                      (max u₁ v₁)
                      (max v₁ u₁ (v₁+1))
                      (max v₁ u₁ (v₁+1))}
                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.prod.{v₁
                      (max u₁ v₁)
                      (max u₁ v₁)
                      (max u₁ v₁)
                      u₁
                      (max v₁ u₁ (v₁+1))
                      (max v₁ u₁ (v₁+1))
                      (max v₁ u₁ (v₁+1))}
                      (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                      (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})))
                   F)))
          Y)
       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
             (opposite.{(max v₁ u₁ (v₁+1))+1}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.obj.{(max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod.{(max u₁ v₁)
                   (max u₁ v₁)
                   (max v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))}
                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.prod.{v₁
                   (max u₁ v₁)
                   (max u₁ v₁)
                   (max u₁ v₁)
                   u₁
                   (max v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))}
                   (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                   (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})))
                F))
          Y)
       (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.obj.{(max u₁ v₁)
                   (max u₁ v₁)
                   (max u₁ v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))}
                   (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                   (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.prod.{(max u₁ v₁)
                      (max u₁ v₁)
                      (max v₁ u₁ (v₁+1))
                      (max v₁ u₁ (v₁+1))}
                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.prod.{v₁
                      (max u₁ v₁)
                      (max u₁ v₁)
                      (max u₁ v₁)
                      u₁
                      (max v₁ u₁ (v₁+1))
                      (max v₁ u₁ (v₁+1))
                      (max v₁ u₁ (v₁+1))}
                      (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                      (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})))
                   F)))
          X
          Y
          f)
       (λ
        (a :
          @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@category_theory.functor.obj.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod.{(max u₁ v₁)
                        (max u₁ v₁)
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.prod.{v₁
                        (max u₁ v₁)
                        (max u₁ v₁)
                        (max u₁ v₁)
                        u₁
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                        (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})))
                     F)))
            Y),
          @category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               F)
            (@opposite.op.{u₁+1} C
               (@opposite.unop.{u₁+1} C
                  (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     F)))
            Y
            (@category_theory.has_hom.hom.op.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C Y)
               (@opposite.unop.{u₁+1} C
                  (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     F))
               a)
            (@ulift.down.{u₁ v₁}
               (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}
                  (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  F)
               x))
       x_1)
    (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
       (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁) category_theory.types.{v₁})
       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.obj.{(max u₁ v₁)
                   (max u₁ v₁)
                   (max u₁ v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))}
                   (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                   (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.prod.{(max u₁ v₁)
                      (max u₁ v₁)
                      (max v₁ u₁ (v₁+1))
                      (max v₁ u₁ (v₁+1))}
                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.prod.{v₁
                      (max u₁ v₁)
                      (max u₁ v₁)
                      (max u₁ v₁)
                      u₁
                      (max v₁ u₁ (v₁+1))
                      (max v₁ u₁ (v₁+1))
                      (max v₁ u₁ (v₁+1))}
                      (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                      (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})))
                   F)))
          X)
       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
             (opposite.{(max v₁ u₁ (v₁+1))+1}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.obj.{(max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod.{(max u₁ v₁)
                   (max u₁ v₁)
                   (max v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))}
                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.prod.{v₁
                   (max u₁ v₁)
                   (max u₁ v₁)
                   (max u₁ v₁)
                   u₁
                   (max v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))}
                   (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                   (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})))
                F))
          X)
       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
             (opposite.{(max v₁ u₁ (v₁+1))+1}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.obj.{(max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod.{(max u₁ v₁)
                   (max u₁ v₁)
                   (max v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))}
                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.prod.{v₁
                   (max u₁ v₁)
                   (max u₁ v₁)
                   (max u₁ v₁)
                   u₁
                   (max v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))}
                   (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                   (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})))
                F))
          Y)
       (λ
        (a :
          @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@category_theory.functor.obj.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod.{(max u₁ v₁)
                        (max u₁ v₁)
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.prod.{v₁
                        (max u₁ v₁)
                        (max u₁ v₁)
                        (max u₁ v₁)
                        u₁
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                        (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})))
                     F)))
            X),
          @category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               F)
            (@opposite.op.{u₁+1} C
               (@opposite.unop.{u₁+1} C
                  (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     F)))
            X
            (@category_theory.has_hom.hom.op.{v₁ u₁} C
               (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                  (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
               (@opposite.unop.{u₁+1} C X)
               (@opposite.unop.{u₁+1} C
                  (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     F))
               a)
            (@ulift.down.{u₁ v₁}
               (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}
                  (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  F)
               x))
       (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
             (opposite.{(max v₁ u₁ (v₁+1))+1}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.obj.{(max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod.{(max u₁ v₁)
                   (max u₁ v₁)
                   (max v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))}
                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.prod.{v₁
                   (max u₁ v₁)
                   (max u₁ v₁)
                   (max u₁ v₁)
                   u₁
                   (max v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))}
                   (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} … … (Type v₁)
                         category_theory.types.{v₁})
                      …)
                   …)
                F))
          X
          Y
          f)
       x_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
F :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
x :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
    F,
X Y : opposite.{u₁+1} C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
    X
    Y,
x_1 :
  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
    (Type v₁)
    category_theory.types.{v₁}
    (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
          (opposite.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max v₁ u₁ (v₁+1))}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod.{(max u₁ v₁) (max u₁ v₁) (max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.prod.{v₁
                (max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁)
                u₁
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             F)))
    X
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          F)
       Y)
    (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          F)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          F)
       Y
       (@category_theory.category_struct.comp.{v₁ u₁} (opposite.{u₁+1} C)
          (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞))
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             F)
          X
          Y
          (@category_theory.has_hom.hom.op.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@opposite.unop.{u₁+1} C X)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   F))
             x_1)
          f)
       (@ulift.down.{u₁ v₁}
          (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                F)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                F))
          x))
    (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          F)
       X
       Y
       f
       (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             F)
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             F)
          X
          (@category_theory.has_hom.hom.op.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@opposite.unop.{u₁+1} C X)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   F))
             x_1)
          (@ulift.down.{u₁ v₁}
             (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}
                (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   F)
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   F))
             x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162          rw [functor_to_types.map_comp]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='category_theory.functor_to_types.map_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/types.lean&#x27;, &#x27;line&#x27;: 36, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (F : @category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) {X Y Z : C} (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y) (g : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Y Z) (a : @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F X), @eq.{v₁+1} (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F Z) (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F X Z (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X Y Z f g) a) (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F Y Z g (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F X Y f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
F :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
x :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
    F,
X Y : opposite.{u₁+1} C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
    X
    Y,
x_1 :
  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
    (Type v₁)
    category_theory.types.{v₁}
    (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
          (opposite.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max v₁ u₁ (v₁+1))}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod.{(max u₁ v₁) (max u₁ v₁) (max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.prod.{v₁
                (max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁)
                u₁
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             F)))
    X
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          F)
       Y)
    (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          F)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          F)
       Y
       (@category_theory.category_struct.comp.{v₁ u₁} (opposite.{u₁+1} C)
          (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞))
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             F)
          X
          Y
          (@category_theory.has_hom.hom.op.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@opposite.unop.{u₁+1} C X)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   F))
             x_1)
          f)
       (@ulift.down.{u₁ v₁}
          (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                F)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                F))
          x))
    (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          F)
       X
       Y
       f
       (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             F)
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             F)
          X
          (@category_theory.has_hom.hom.op.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@opposite.unop.{u₁+1} C X)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   F))
             x_1)
          (@ulift.down.{u₁ v₁}
             (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}
                (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   F)
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   F))
             x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
F :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
x :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
    F,
X Y : opposite.{u₁+1} C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
    X
    Y,
x_1 :
  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
    (Type v₁)
    category_theory.types.{v₁}
    (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
          (opposite.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max v₁ u₁ (v₁+1))}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod.{(max u₁ v₁) (max u₁ v₁) (max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.prod.{v₁
                (max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁)
                u₁
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             F)))
    X
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          F)
       Y)
    (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          F)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          F)
       Y
       (@category_theory.category_struct.comp.{v₁ u₁} (opposite.{u₁+1} C)
          (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞))
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             F)
          X
          Y
          (@category_theory.has_hom.hom.op.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@opposite.unop.{u₁+1} C X)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   F))
             x_1)
          f)
       (@ulift.down.{u₁ v₁}
          (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                F)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                F))
          x))
    (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          F)
       X
       Y
       f
       (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             F)
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             F)
          X
          (@category_theory.has_hom.hom.op.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@opposite.unop.{u₁+1} C X)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   F))
             x_1)
          (@ulift.down.{u₁ v₁}
             (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}
                (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   F)
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   F))
             x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163        end },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
F :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
x :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
    F,
X Y : opposite.{u₁+1} C,
f :
  @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
       (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
    X
    Y,
x_1 :
  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
    (Type v₁)
    category_theory.types.{v₁}
    (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
          (opposite.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max v₁ u₁ (v₁+1))}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod.{(max u₁ v₁) (max u₁ v₁) (max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.prod.{v₁
                (max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁)
                u₁
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             F)))
    X
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          F)
       Y)
    (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          F)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          F)
       Y
       (@category_theory.category_struct.comp.{v₁ u₁} (opposite.{u₁+1} C)
          (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞))
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             F)
          X
          Y
          (@category_theory.has_hom.hom.op.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@opposite.unop.{u₁+1} C X)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   F))
             x_1)
          f)
       (@ulift.down.{u₁ v₁}
          (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                F)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                F))
          x))
    (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          F)
       X
       Y
       f
       (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             F)
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             F)
          X
          (@category_theory.has_hom.hom.op.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@opposite.unop.{u₁+1} C X)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   F))
             x_1)
          (@ulift.down.{u₁ v₁}
             (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}
                (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   F)
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   F))
             x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164      naturality&#x27; :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165      begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C
⊢ ∀
  ⦃X Y :
    prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
         (Type v₁)
         category_theory.types.{v₁})⦄
  (f :
    @category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
      (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}))
      (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
         (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
               (Type v₁)
               category_theory.types.{v₁}))
         (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)))
      X
      Y),
    @eq.{(max u₁ v₁)+1}
      (@category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
         (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
            (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
               category_theory.types.{(max u₁ v₁)}))
         (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
            X)
         (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
            Y))
      (@category_theory.category_struct.comp.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
         (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)})
         (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
            X)
         (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
            Y)
         (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
            Y)
         (@category_theory.functor.map.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
            X
            Y
            f)
         (λ
          (x :
            @category_theory.functor.obj.{(max u₁ v₁)
              (max u₁ v₁)
              (max u₁ v₁ u₁ (v₁+1))
              (max u₁ v₁)+1}
              (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                    (Type v₁)
                    category_theory.types.{v₁}))
              (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
              (Type (max u₁ v₁))
              category_theory.types.{(max u₁ v₁)}
              (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
              Y),
            @category_theory.nat_trans.mk.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
              (Type v₁)
              category_theory.types.{v₁}
              (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                    (Type v₁)
                    category_theory.types.{v₁})
                 (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                    (opposite.{(max v₁ u₁ (v₁+1))+1}
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}))
                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁})
                    (@category_theory.functor.obj.{(max u₁ v₁)
                       (max u₁ v₁)
                       (max u₁ v₁ u₁ (v₁+1))
                       (max v₁ u₁ (v₁+1))}
                       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                       (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.prod.{(max u₁ v₁)
                          (max u₁ v₁)
                          (max v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))}
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.functor.prod.{v₁
                          (max u₁ v₁)
                          (max u₁ v₁)
                          (max u₁ v₁)
                          u₁
                          (max v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))}
                          (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                          (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})))
                       Y)))
              (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                 (opposite.{(max v₁ u₁ (v₁+1))+1}
                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁}))
                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                    (Type v₁)
                    category_theory.types.{v₁})
                 (@category_theory.functor.obj.{(max u₁ v₁)
                    (max u₁ v₁)
                    (max u₁ v₁ u₁ (v₁+1))
                    (max v₁ u₁ (v₁+1))}
                    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}))
                    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                    (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                       (opposite.{(max v₁ u₁ (v₁+1))+1}
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}))
                    (@category_theory.prod.{(max u₁ v₁)
                       (max u₁ v₁)
                       (max v₁ u₁ (v₁+1))
                       (max v₁ u₁ (v₁+1))}
                       (opposite.{(max v₁ u₁ (v₁+1))+1}
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁})
                       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}))
                    (@category_theory.functor.prod.{v₁
                       (max u₁ v₁)
                       (max u₁ v₁)
                       (max u₁ v₁)
                       u₁
                       (max v₁ u₁ (v₁+1))
                       (max v₁ u₁ (v₁+1))
                       (max v₁ u₁ (v₁+1))}
                       (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (opposite.{(max v₁ u₁ (v₁+1))+1}
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁})
                       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁})
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁})
                       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁})
                       (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                       (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})))
                    Y))
              (λ (X : opposite.{u₁+1} C)
               (a :
                 @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}
                   (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                         (opposite.{(max v₁ u₁ (v₁+1))+1}
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁}))
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.obj.{(max u₁ v₁)
                            (max u₁ v₁)
                            (max u₁ v₁ u₁ (v₁+1))
                            (max v₁ u₁ (v₁+1))}
                            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁}))
                            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                            (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                               (opposite.{(max v₁ u₁ (v₁+1))+1}
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁}))
                            (@category_theory.prod.{(max u₁ v₁)
                               (max u₁ v₁)
                               (max v₁ u₁ (v₁+1))
                               (max v₁ u₁ (v₁+1))}
                               (opposite.{(max v₁ u₁ (v₁+1))+1}
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁}))
                            (@category_theory.functor.prod.{v₁
                               (max u₁ v₁)
                               (max u₁ v₁)
                               (max u₁ v₁)
                               u₁
                               (max v₁ u₁ (v₁+1))
                               (max v₁ u₁ (v₁+1))
                               (max v₁ u₁ (v₁+1))}
                               (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (opposite.{(max v₁ u₁ (v₁+1))+1}
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                               (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})))
                            Y)))
                   X),
                 @category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y)
                   (@opposite.op.{u₁+1} C
                      (@opposite.unop.{u₁+1} C
                         (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            Y)))
                   X
                   (@category_theory.has_hom.hom.op.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      (@opposite.unop.{u₁+1} C X)
                      (@opposite.unop.{u₁+1} C
                         (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            Y))
                      a)
                   (@ulift.down.{u₁ v₁}
                      (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
                         (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁}))
                         (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}
                         (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         Y)
                      x))
              (λ (X Y_1 : opposite.{u₁+1} C)
               (f :
                 @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                   X
                   Y_1),
                 @funext.{v₁+1 v₁+1}
                   (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}
                      (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                            (opposite.{(max v₁ u₁ (v₁+1))+1}
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁}))
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            (@category_theory.functor.obj.{(max u₁ v₁)
                               (max u₁ v₁)
                               (max u₁ v₁ u₁ (v₁+1))
                               (max v₁ u₁ (v₁+1))}
                               (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                               (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.prod.{(max u₁ v₁)
                                  (max u₁ v₁)
                                  (max v₁ u₁ (v₁+1))
                                  (max v₁ u₁ (v₁+1))}
                                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.functor.prod.{v₁
                                  (max u₁ v₁)
                                  (max u₁ v₁)
                                  (max u₁ v₁)
                                  u₁
                                  (max v₁ u₁ (v₁+1))
                                  (max v₁ u₁ (v₁+1))
                                  (max v₁ u₁ (v₁+1))}
                                  (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                     𝒞
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                  (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})))
                               Y)))
                      X)
                   (λ
                    (x :
                      @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}
                        (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                              (opposite.{(max v₁ u₁ (v₁+1))+1}
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.obj.{(max u₁ v₁)
                                 (max u₁ v₁)
                                 (max u₁ v₁ u₁ (v₁+1))
                                 (max v₁ u₁ (v₁+1))}
                                 (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁}))
                                 (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                 (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                    (opposite.{(max v₁ u₁ (v₁+1))+1}
                                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁}))
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁}))
                                 (@category_theory.prod.{(max u₁ v₁)
                                    (max u₁ v₁)
                                    (max v₁ u₁ (v₁+1))
                                    (max v₁ u₁ (v₁+1))}
                                    (opposite.{(max v₁ u₁ (v₁+1))+1}
                                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁}))
                                    (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁})
                                       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁}))
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁}))
                                 (@category_theory.functor.prod.{v₁
                                    (max u₁ v₁)
                                    (max u₁ v₁)
                                    (max u₁ v₁)
                                    u₁
                                    (max v₁ u₁ (v₁+1))
                                    (max v₁ u₁ (v₁+1))
                                    (max v₁ u₁ (v₁+1))}
                                    (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (opposite.{(max v₁ u₁ (v₁+1))+1}
                                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁}))
                                    (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁})
                                       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁}))
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                       𝒞
                                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁})
                                       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁})
                                       (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁})
                                       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁})))
                                 Y)))
                        X),
                      @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}
                        (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.obj.{(max u₁ v₁)
                              (max u₁ v₁)
                              (max u₁ v₁ u₁ (v₁+1))
                              (max v₁ u₁ (v₁+1))}
                              (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                              (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                 (opposite.{(max v₁ u₁ (v₁+1))+1}
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁}))
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.prod.{(max u₁ v₁)
                                 (max u₁ v₁)
                                 (max v₁ u₁ (v₁+1))
                                 (max v₁ u₁ (v₁+1))}
                                 (opposite.{(max v₁ u₁ (v₁+1))+1}
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁}))
                                 (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁}))
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.functor.prod.{v₁
                                 (max u₁ v₁)
                                 (max u₁ v₁)
                                 (max u₁ v₁)
                                 u₁
                                 (max v₁ u₁ (v₁+1))
                                 (max v₁ u₁ (v₁+1))
                                 (max v₁ u₁ (v₁+1))}
                                 (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (opposite.{(max v₁ u₁ (v₁+1))+1}
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁}))
                                 (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁}))
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                    𝒞
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                 (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})))
                              Y))
                        Y_1)
                   (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                      (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}
                         (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                               (opposite.{(max v₁ u₁ (v₁+1))+1}
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.functor.obj.{(max u₁ v₁)
                                  (max u₁ v₁)
                                  (max u₁ v₁ u₁ (v₁+1))
                                  (max v₁ u₁ (v₁+1))}
                                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                  (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.prod.{(max u₁ v₁)
                                     (max u₁ v₁)
                                     (max v₁ u₁ (v₁+1))
                                     (max v₁ u₁ (v₁+1))}
                                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.prod.{v₁
                                     (max u₁ v₁)
                                     (max u₁ v₁)
                                     (max u₁ v₁)
                                     u₁
                                     (max v₁ u₁ (v₁+1))
                                     (max v₁ u₁ (v₁+1))
                                     (max v₁ u₁ (v₁+1))}
                                     (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                        𝒞
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                     (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})))
                                  Y)))
                         X)
                      (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}
                         (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                               (opposite.{(max v₁ u₁ (v₁+1))+1}
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.functor.obj.{(max u₁ v₁)
                                  (max u₁ v₁)
                                  (max u₁ v₁ u₁ (v₁+1))
                                  (max v₁ u₁ (v₁+1))}
                                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                  (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.prod.{(max u₁ v₁)
                                     (max u₁ v₁)
                                     (max v₁ u₁ (v₁+1))
                                     (max v₁ u₁ (v₁+1))}
                                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.prod.{v₁
                                     (max u₁ v₁)
                                     (max u₁ v₁)
                                     (max u₁ v₁)
                                     u₁
                                     (max v₁ u₁ (v₁+1))
                                     (max v₁ u₁ (v₁+1))
                                     (max v₁ u₁ (v₁+1))}
                                     (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                        𝒞
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                     (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})))
                                  Y)))
                         Y_1)
                      (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}
                         (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                            (opposite.{(max v₁ u₁ (v₁+1))+1}
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁}))
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            (@category_theory.functor.obj.{(max u₁ v₁)
                               (max u₁ v₁)
                               (max u₁ v₁ u₁ (v₁+1))
                               (max v₁ u₁ (v₁+1))}
                               (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                               (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.prod.{(max u₁ v₁)
                                  (max u₁ v₁)
                                  (max v₁ u₁ (v₁+1))
                                  (max v₁ u₁ (v₁+1))}
                                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.functor.prod.{v₁
                                  (max u₁ v₁)
                                  (max u₁ v₁)
                                  (max u₁ v₁)
                                  u₁
                                  (max v₁ u₁ (v₁+1))
                                  (max v₁ u₁ (v₁+1))
                                  (max v₁ u₁ (v₁+1))}
                                  (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                     𝒞
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                  (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})))
                               Y))
                         Y_1)
                      (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}
                         (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                               (opposite.{(max v₁ u₁ (v₁+1))+1}
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.functor.obj.{(max u₁ v₁)
                                  (max u₁ v₁)
                                  (max u₁ v₁ u₁ (v₁+1))
                                  (max v₁ u₁ (v₁+1))}
                                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                  (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.prod.{(max u₁ v₁)
                                     (max u₁ v₁)
                                     (max v₁ u₁ (v₁+1))
                                     (max v₁ u₁ (v₁+1))}
                                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.prod.{v₁
                                     (max u₁ v₁)
                                     (max u₁ v₁)
                                     (max u₁ v₁)
                                     u₁
                                     (max v₁ u₁ (v₁+1))
                                     (max v₁ u₁ (v₁+1))
                                     (max v₁ u₁ (v₁+1))}
                                     (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                        𝒞
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                     (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})))
                                  Y)))
                         X
                         Y_1
                         f)
                      (λ
                       (a :
                         @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}
                           (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                 (opposite.{(max v₁ u₁ (v₁+1))+1}
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁}))
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.obj.{(max u₁ v₁)
                                    (max u₁ v₁)
                                    (max u₁ v₁ u₁ (v₁+1))
                                    (max v₁ u₁ (v₁+1))}
                                    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁}))
                                    …
                                    …
                                    …
                                    …
                                    Y)))
                           Y_1), …))
                   …
                   …)))
      …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166        intros X Y f, ext, dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 131, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) (@lean.parser.many.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state) lean.parser.alternative name interactive.types.ident_) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `intro` tactic. The tactic `intros` will keep introducing new hypotheses until the goal target is not a Pi/forall or let binder.

The variant `intros h₁ ... hₙ` introduces `n` new hypotheses using the given identifiers to name them.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='intros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id*&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C
⊢ ∀
  ⦃X Y :
    prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
         (Type v₁)
         category_theory.types.{v₁})⦄
  (f :
    @category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
      (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}))
      (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
         (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
               (Type v₁)
               category_theory.types.{v₁}))
         (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)))
      X
      Y),
    @eq.{(max u₁ v₁)+1}
      (@category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
         (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
            (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
               category_theory.types.{(max u₁ v₁)}))
         (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
            X)
         (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
            Y))
      (@category_theory.category_struct.comp.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
         (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)})
         (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
            X)
         (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
            Y)
         (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
            Y)
         (@category_theory.functor.map.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
            X
            Y
            f)
         (λ
          (x :
            @category_theory.functor.obj.{(max u₁ v₁)
              (max u₁ v₁)
              (max u₁ v₁ u₁ (v₁+1))
              (max u₁ v₁)+1}
              (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                    (Type v₁)
                    category_theory.types.{v₁}))
              (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
              (Type (max u₁ v₁))
              category_theory.types.{(max u₁ v₁)}
              (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
              Y),
            @category_theory.nat_trans.mk.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
              (Type v₁)
              category_theory.types.{v₁}
              (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                    (Type v₁)
                    category_theory.types.{v₁})
                 (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                    (opposite.{(max v₁ u₁ (v₁+1))+1}
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}))
                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁})
                    (@category_theory.functor.obj.{(max u₁ v₁)
                       (max u₁ v₁)
                       (max u₁ v₁ u₁ (v₁+1))
                       (max v₁ u₁ (v₁+1))}
                       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                       (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.prod.{(max u₁ v₁)
                          (max u₁ v₁)
                          (max v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))}
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.functor.prod.{v₁
                          (max u₁ v₁)
                          (max u₁ v₁)
                          (max u₁ v₁)
                          u₁
                          (max v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))}
                          (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                          (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})))
                       Y)))
              (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                 (opposite.{(max v₁ u₁ (v₁+1))+1}
                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁}))
                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                    (Type v₁)
                    category_theory.types.{v₁})
                 (@category_theory.functor.obj.{(max u₁ v₁)
                    (max u₁ v₁)
                    (max u₁ v₁ u₁ (v₁+1))
                    (max v₁ u₁ (v₁+1))}
                    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}))
                    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                    (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                       (opposite.{(max v₁ u₁ (v₁+1))+1}
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}))
                    (@category_theory.prod.{(max u₁ v₁)
                       (max u₁ v₁)
                       (max v₁ u₁ (v₁+1))
                       (max v₁ u₁ (v₁+1))}
                       (opposite.{(max v₁ u₁ (v₁+1))+1}
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁})
                       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}))
                    (@category_theory.functor.prod.{v₁
                       (max u₁ v₁)
                       (max u₁ v₁)
                       (max u₁ v₁)
                       u₁
                       (max v₁ u₁ (v₁+1))
                       (max v₁ u₁ (v₁+1))
                       (max v₁ u₁ (v₁+1))}
                       (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (opposite.{(max v₁ u₁ (v₁+1))+1}
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁})
                       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁})
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁})
                       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁})
                       (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                       (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})))
                    Y))
              (λ (X : opposite.{u₁+1} C)
               (a :
                 @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}
                   (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                         (opposite.{(max v₁ u₁ (v₁+1))+1}
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁}))
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.obj.{(max u₁ v₁)
                            (max u₁ v₁)
                            (max u₁ v₁ u₁ (v₁+1))
                            (max v₁ u₁ (v₁+1))}
                            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁}))
                            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                            (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                               (opposite.{(max v₁ u₁ (v₁+1))+1}
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁}))
                            (@category_theory.prod.{(max u₁ v₁)
                               (max u₁ v₁)
                               (max v₁ u₁ (v₁+1))
                               (max v₁ u₁ (v₁+1))}
                               (opposite.{(max v₁ u₁ (v₁+1))+1}
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁}))
                            (@category_theory.functor.prod.{v₁
                               (max u₁ v₁)
                               (max u₁ v₁)
                               (max u₁ v₁)
                               u₁
                               (max v₁ u₁ (v₁+1))
                               (max v₁ u₁ (v₁+1))
                               (max v₁ u₁ (v₁+1))}
                               (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (opposite.{(max v₁ u₁ (v₁+1))+1}
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                               (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})))
                            Y)))
                   X),
                 @category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y)
                   (@opposite.op.{u₁+1} C
                      (@opposite.unop.{u₁+1} C
                         (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            Y)))
                   X
                   (@category_theory.has_hom.hom.op.{v₁ u₁} C
                      (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                         (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                      (@opposite.unop.{u₁+1} C X)
                      (@opposite.unop.{u₁+1} C
                         (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            Y))
                      a)
                   (@ulift.down.{u₁ v₁}
                      (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
                         (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁}))
                         (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}
                         (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         Y)
                      x))
              (λ (X Y_1 : opposite.{u₁+1} C)
               (f :
                 @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                   X
                   Y_1),
                 @funext.{v₁+1 v₁+1}
                   (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}
                      (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                            (opposite.{(max v₁ u₁ (v₁+1))+1}
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁}))
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            (@category_theory.functor.obj.{(max u₁ v₁)
                               (max u₁ v₁)
                               (max u₁ v₁ u₁ (v₁+1))
                               (max v₁ u₁ (v₁+1))}
                               (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                               (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.prod.{(max u₁ v₁)
                                  (max u₁ v₁)
                                  (max v₁ u₁ (v₁+1))
                                  (max v₁ u₁ (v₁+1))}
                                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.functor.prod.{v₁
                                  (max u₁ v₁)
                                  (max u₁ v₁)
                                  (max u₁ v₁)
                                  u₁
                                  (max v₁ u₁ (v₁+1))
                                  (max v₁ u₁ (v₁+1))
                                  (max v₁ u₁ (v₁+1))}
                                  (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                     𝒞
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                  (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})))
                               Y)))
                      X)
                   (λ
                    (x :
                      @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}
                        (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                              (opposite.{(max v₁ u₁ (v₁+1))+1}
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.obj.{(max u₁ v₁)
                                 (max u₁ v₁)
                                 (max u₁ v₁ u₁ (v₁+1))
                                 (max v₁ u₁ (v₁+1))}
                                 (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁}))
                                 (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                 (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                    (opposite.{(max v₁ u₁ (v₁+1))+1}
                                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁}))
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁}))
                                 (@category_theory.prod.{(max u₁ v₁)
                                    (max u₁ v₁)
                                    (max v₁ u₁ (v₁+1))
                                    (max v₁ u₁ (v₁+1))}
                                    (opposite.{(max v₁ u₁ (v₁+1))+1}
                                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁}))
                                    (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁})
                                       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁}))
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁}))
                                 (@category_theory.functor.prod.{v₁
                                    (max u₁ v₁)
                                    (max u₁ v₁)
                                    (max u₁ v₁)
                                    u₁
                                    (max v₁ u₁ (v₁+1))
                                    (max v₁ u₁ (v₁+1))
                                    (max v₁ u₁ (v₁+1))}
                                    (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (opposite.{(max v₁ u₁ (v₁+1))+1}
                                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁}))
                                    (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁})
                                       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁}))
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                       𝒞
                                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁})
                                       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁})
                                       (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁})
                                       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁})))
                                 Y)))
                        X),
                      @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}
                        (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.obj.{(max u₁ v₁)
                              (max u₁ v₁)
                              (max u₁ v₁ u₁ (v₁+1))
                              (max v₁ u₁ (v₁+1))}
                              (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                              (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                 (opposite.{(max v₁ u₁ (v₁+1))+1}
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁}))
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.prod.{(max u₁ v₁)
                                 (max u₁ v₁)
                                 (max v₁ u₁ (v₁+1))
                                 (max v₁ u₁ (v₁+1))}
                                 (opposite.{(max v₁ u₁ (v₁+1))+1}
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁}))
                                 (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁}))
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.functor.prod.{v₁
                                 (max u₁ v₁)
                                 (max u₁ v₁)
                                 (max u₁ v₁)
                                 u₁
                                 (max v₁ u₁ (v₁+1))
                                 (max v₁ u₁ (v₁+1))
                                 (max v₁ u₁ (v₁+1))}
                                 (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (opposite.{(max v₁ u₁ (v₁+1))+1}
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁}))
                                 (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁}))
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                    𝒞
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                 (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})))
                              Y))
                        Y_1)
                   (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                      (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}
                         (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                               (opposite.{(max v₁ u₁ (v₁+1))+1}
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.functor.obj.{(max u₁ v₁)
                                  (max u₁ v₁)
                                  (max u₁ v₁ u₁ (v₁+1))
                                  (max v₁ u₁ (v₁+1))}
                                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                  (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.prod.{(max u₁ v₁)
                                     (max u₁ v₁)
                                     (max v₁ u₁ (v₁+1))
                                     (max v₁ u₁ (v₁+1))}
                                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.prod.{v₁
                                     (max u₁ v₁)
                                     (max u₁ v₁)
                                     (max u₁ v₁)
                                     u₁
                                     (max v₁ u₁ (v₁+1))
                                     (max v₁ u₁ (v₁+1))
                                     (max v₁ u₁ (v₁+1))}
                                     (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                        𝒞
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                     (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})))
                                  Y)))
                         X)
                      (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}
                         (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                               (opposite.{(max v₁ u₁ (v₁+1))+1}
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.functor.obj.{(max u₁ v₁)
                                  (max u₁ v₁)
                                  (max u₁ v₁ u₁ (v₁+1))
                                  (max v₁ u₁ (v₁+1))}
                                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                  (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.prod.{(max u₁ v₁)
                                     (max u₁ v₁)
                                     (max v₁ u₁ (v₁+1))
                                     (max v₁ u₁ (v₁+1))}
                                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.prod.{v₁
                                     (max u₁ v₁)
                                     (max u₁ v₁)
                                     (max u₁ v₁)
                                     u₁
                                     (max v₁ u₁ (v₁+1))
                                     (max v₁ u₁ (v₁+1))
                                     (max v₁ u₁ (v₁+1))}
                                     (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                        𝒞
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                     (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})))
                                  Y)))
                         Y_1)
                      (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}
                         (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                            (opposite.{(max v₁ u₁ (v₁+1))+1}
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁}))
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            (@category_theory.functor.obj.{(max u₁ v₁)
                               (max u₁ v₁)
                               (max u₁ v₁ u₁ (v₁+1))
                               (max v₁ u₁ (v₁+1))}
                               (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                               (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.prod.{(max u₁ v₁)
                                  (max u₁ v₁)
                                  (max v₁ u₁ (v₁+1))
                                  (max v₁ u₁ (v₁+1))}
                                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.functor.prod.{v₁
                                  (max u₁ v₁)
                                  (max u₁ v₁)
                                  (max u₁ v₁)
                                  u₁
                                  (max v₁ u₁ (v₁+1))
                                  (max v₁ u₁ (v₁+1))
                                  (max v₁ u₁ (v₁+1))}
                                  (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                     𝒞
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                  (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})))
                               Y))
                         Y_1)
                      (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}
                         (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                               (opposite.{(max v₁ u₁ (v₁+1))+1}
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.functor.obj.{(max u₁ v₁)
                                  (max u₁ v₁)
                                  (max u₁ v₁ u₁ (v₁+1))
                                  (max v₁ u₁ (v₁+1))}
                                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                  (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.prod.{(max u₁ v₁)
                                     (max u₁ v₁)
                                     (max v₁ u₁ (v₁+1))
                                     (max v₁ u₁ (v₁+1))}
                                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.prod.{v₁
                                     (max u₁ v₁)
                                     (max u₁ v₁)
                                     (max u₁ v₁)
                                     u₁
                                     (max v₁ u₁ (v₁+1))
                                     (max v₁ u₁ (v₁+1))
                                     (max v₁ u₁ (v₁+1))}
                                     (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                        𝒞
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                     (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})))
                                  Y)))
                         X
                         Y_1
                         f)
                      (λ
                       (a :
                         @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}
                           (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                 (opposite.{(max v₁ u₁ (v₁+1))+1}
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁}))
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.obj.{(max u₁ v₁)
                                    (max u₁ v₁)
                                    (max u₁ v₁ u₁ (v₁+1))
                                    (max v₁ u₁ (v₁+1))}
                                    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁}))
                                    …
                                    …
                                    …
                                    …
                                    Y)))
                           Y_1), …))
                   …
                   …)))
      …'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
f :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}))
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)))
    X
    Y
⊢ @eq.{(max u₁ v₁)+1}
    (@category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
       (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
          (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
             category_theory.types.{(max u₁ v₁)}))
       (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)}
          (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
          X)
       (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)}
          (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
          Y))
    (@category_theory.category_struct.comp.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)})
       (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)}
          (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
          X)
       (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)}
          (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
          Y)
       (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)}
          (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
          Y)
       (@category_theory.functor.map.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)}
          (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
          X
          Y
          f)
       (λ
        (x :
          @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
            (Type (max u₁ v₁))
            category_theory.types.{(max u₁ v₁)}
            (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
            Y),
          @category_theory.nat_trans.mk.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
            (Type v₁)
            category_theory.types.{v₁}
            (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@category_theory.functor.obj.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod.{(max u₁ v₁)
                        (max u₁ v₁)
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.prod.{v₁
                        (max u₁ v₁)
                        (max u₁ v₁)
                        (max u₁ v₁)
                        u₁
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                        (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})))
                     Y)))
            (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
               (opposite.{(max v₁ u₁ (v₁+1))+1}
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁}))
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁})
               (@category_theory.functor.obj.{(max u₁ v₁)
                  (max u₁ v₁)
                  (max u₁ v₁ u₁ (v₁+1))
                  (max v₁ u₁ (v₁+1))}
                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                  (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.functor.prod.{v₁
                     (max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁)
                     u₁
                     (max v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                     (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})))
                  Y))
            (λ (X : opposite.{u₁+1} C)
             (a :
               @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                 (Type v₁)
                 category_theory.types.{v₁}
                 (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁})
                    (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                       (opposite.{(max v₁ u₁ (v₁+1))+1}
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁})
                       (@category_theory.functor.obj.{(max u₁ v₁)
                          (max u₁ v₁)
                          (max u₁ v₁ u₁ (v₁+1))
                          (max v₁ u₁ (v₁+1))}
                          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                          (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                             (opposite.{(max v₁ u₁ (v₁+1))+1}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.prod.{(max u₁ v₁)
                             (max u₁ v₁)
                             (max v₁ u₁ (v₁+1))
                             (max v₁ u₁ (v₁+1))}
                             (opposite.{(max v₁ u₁ (v₁+1))+1}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.prod.{v₁
                             (max u₁ v₁)
                             (max u₁ v₁)
                             (max u₁ v₁)
                             u₁
                             (max v₁ u₁ (v₁+1))
                             (max v₁ u₁ (v₁+1))
                             (max v₁ u₁ (v₁+1))}
                             (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (opposite.{(max v₁ u₁ (v₁+1))+1}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                             (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})))
                          Y)))
                 X),
               @category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                 (Type v₁)
                 category_theory.types.{v₁}
                 (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁})
                    Y)
                 (@opposite.op.{u₁+1} C
                    (@opposite.unop.{u₁+1} C
                       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          Y)))
                 X
                 (@category_theory.has_hom.hom.op.{v₁ u₁} C
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                    (@opposite.unop.{u₁+1} C X)
                    (@opposite.unop.{u₁+1} C
                       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          Y))
                    a)
                 (@ulift.down.{u₁ v₁}
                    (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
                       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁}
                       (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁})
                       Y)
                    x))
            (λ (X Y_1 : opposite.{u₁+1} C)
             (f :
               @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                 (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                    (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                 X
                 Y_1),
               @funext.{v₁+1 v₁+1}
                 (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                    (Type v₁)
                    category_theory.types.{v₁}
                    (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁})
                       (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.obj.{(max u₁ v₁)
                             (max u₁ v₁)
                             (max u₁ v₁ u₁ (v₁+1))
                             (max v₁ u₁ (v₁+1))}
                             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                             (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                (opposite.{(max v₁ u₁ (v₁+1))+1}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.prod.{(max u₁ v₁)
                                (max u₁ v₁)
                                (max v₁ u₁ (v₁+1))
                                (max v₁ u₁ (v₁+1))}
                                (opposite.{(max v₁ u₁ (v₁+1))+1}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.functor.prod.{v₁
                                (max u₁ v₁)
                                (max u₁ v₁)
                                (max u₁ v₁)
                                u₁
                                (max v₁ u₁ (v₁+1))
                                (max v₁ u₁ (v₁+1))
                                (max v₁ u₁ (v₁+1))}
                                (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (opposite.{(max v₁ u₁ (v₁+1))+1}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})))
                             Y)))
                    X)
                 (λ
                  (x :
                    @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}
                      (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                            (opposite.{(max v₁ u₁ (v₁+1))+1}
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁}))
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            (@category_theory.functor.obj.{(max u₁ v₁)
                               (max u₁ v₁)
                               (max u₁ v₁ u₁ (v₁+1))
                               (max v₁ u₁ (v₁+1))}
                               (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                               (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.prod.{(max u₁ v₁)
                                  (max u₁ v₁)
                                  (max v₁ u₁ (v₁+1))
                                  (max v₁ u₁ (v₁+1))}
                                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.functor.prod.{v₁
                                  (max u₁ v₁)
                                  (max u₁ v₁)
                                  (max u₁ v₁)
                                  u₁
                                  (max v₁ u₁ (v₁+1))
                                  (max v₁ u₁ (v₁+1))
                                  (max v₁ u₁ (v₁+1))}
                                  (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                     𝒞
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                  (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})))
                               Y)))
                      X),
                    @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}
                      (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                         (opposite.{(max v₁ u₁ (v₁+1))+1}
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁}))
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.obj.{(max u₁ v₁)
                            (max u₁ v₁)
                            (max u₁ v₁ u₁ (v₁+1))
                            (max v₁ u₁ (v₁+1))}
                            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁}))
                            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                            (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                               (opposite.{(max v₁ u₁ (v₁+1))+1}
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁}))
                            (@category_theory.prod.{(max u₁ v₁)
                               (max u₁ v₁)
                               (max v₁ u₁ (v₁+1))
                               (max v₁ u₁ (v₁+1))}
                               (opposite.{(max v₁ u₁ (v₁+1))+1}
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁}))
                            (@category_theory.functor.prod.{v₁
                               (max u₁ v₁)
                               (max u₁ v₁)
                               (max u₁ v₁)
                               u₁
                               (max v₁ u₁ (v₁+1))
                               (max v₁ u₁ (v₁+1))
                               (max v₁ u₁ (v₁+1))}
                               (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (opposite.{(max v₁ u₁ (v₁+1))+1}
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                               (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})))
                            Y))
                      Y_1)
                 (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                    (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                       category_theory.types.{v₁})
                    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁}
                       (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                             (opposite.{(max v₁ u₁ (v₁+1))+1}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.obj.{(max u₁ v₁)
                                (max u₁ v₁)
                                (max u₁ v₁ u₁ (v₁+1))
                                (max v₁ u₁ (v₁+1))}
                                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.prod.{(max u₁ v₁)
                                   (max u₁ v₁)
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.prod.{v₁
                                   (max u₁ v₁)
                                   (max u₁ v₁)
                                   (max u₁ v₁)
                                   u₁
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                      𝒞
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                   (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})))
                                Y)))
                       X)
                    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁}
                       (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                             (opposite.{(max v₁ u₁ (v₁+1))+1}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.obj.{(max u₁ v₁)
                                (max u₁ v₁)
                                (max u₁ v₁ u₁ (v₁+1))
                                (max v₁ u₁ (v₁+1))}
                                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.prod.{(max u₁ v₁)
                                   (max u₁ v₁)
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.prod.{v₁
                                   (max u₁ v₁)
                                   (max u₁ v₁)
                                   (max u₁ v₁)
                                   u₁
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                      𝒞
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                   (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})))
                                Y)))
                       Y_1)
                    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁}
                       (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.obj.{(max u₁ v₁)
                             (max u₁ v₁)
                             (max u₁ v₁ u₁ (v₁+1))
                             (max v₁ u₁ (v₁+1))}
                             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                             (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                (opposite.{(max v₁ u₁ (v₁+1))+1}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.prod.{(max u₁ v₁)
                                (max u₁ v₁)
                                (max v₁ u₁ (v₁+1))
                                (max v₁ u₁ (v₁+1))}
                                (opposite.{(max v₁ u₁ (v₁+1))+1}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.functor.prod.{v₁
                                (max u₁ v₁)
                                (max u₁ v₁)
                                (max u₁ v₁)
                                u₁
                                (max v₁ u₁ (v₁+1))
                                (max v₁ u₁ (v₁+1))
                                (max v₁ u₁ (v₁+1))}
                                (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (opposite.{(max v₁ u₁ (v₁+1))+1}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})))
                             Y))
                       Y_1)
                    (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁}
                       (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                             (opposite.{(max v₁ u₁ (v₁+1))+1}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.obj.{(max u₁ v₁)
                                (max u₁ v₁)
                                (max u₁ v₁ u₁ (v₁+1))
                                (max v₁ u₁ (v₁+1))}
                                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.prod.{(max u₁ v₁)
                                   (max u₁ v₁)
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.prod.{v₁
                                   (max u₁ v₁)
                                   (max u₁ v₁)
                                   (max u₁ v₁)
                                   u₁
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                      𝒞
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                   (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})))
                                Y)))
                       X
                       Y_1
                       f)
                    (λ
                     (a :
                       @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}
                         (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                               (opposite.{(max v₁ u₁ (v₁+1))+1}
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.functor.obj.{(max u₁ v₁)
                                  (max u₁ v₁)
                                  (max u₁ v₁ u₁ (v₁+1))
                                  (max v₁ u₁ (v₁+1))}
                                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                  (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.prod.{(max u₁ v₁)
                                     (max u₁ v₁)
                                     (max v₁ u₁ (v₁+1))
                                     (max v₁ u₁ (v₁+1))}
                                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (… … (Type v₁) category_theory.types.{v₁})
                                     …)
                                  …
                                  Y)))
                         Y_1), …))
                 …
                 …)))
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
f :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}))
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)))
    X
    Y,
x :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
    X,
x_1 : opposite.{u₁+1} C,
x_2 :
  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
    (Type v₁)
    category_theory.types.{v₁}
    (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
          (opposite.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max v₁ u₁ (v₁+1))}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod.{(max u₁ v₁) (max u₁ v₁) (max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.prod.{v₁
                (max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁)
                u₁
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             Y)))
    x_1
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
          (opposite.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max v₁ u₁ (v₁+1))}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod.{(max u₁ v₁) (max u₁ v₁) (max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.prod.{v₁
                (max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁)
                u₁
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             Y))
       x_1)
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
             (opposite.{(max v₁ u₁ (v₁+1))+1}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.obj.{(max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod.{(max u₁ v₁)
                   (max u₁ v₁)
                   (max v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))}
                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.prod.{v₁
                   (max u₁ v₁)
                   (max u₁ v₁)
                   (max u₁ v₁)
                   u₁
                   (max v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))}
                   (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                   (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})))
                Y)))
       (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
          (opposite.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max v₁ u₁ (v₁+1))}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod.{(max u₁ v₁) (max u₁ v₁) (max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.prod.{v₁
                (max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁)
                u₁
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             Y))
       (@category_theory.category_struct.comp.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
          (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
             category_theory.types.{(max u₁ v₁)})
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max u₁ v₁)+1}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (Type (max u₁ v₁))
             category_theory.types.{(max u₁ v₁)}
             (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
             X)
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max u₁ v₁)+1}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (Type (max u₁ v₁))
             category_theory.types.{(max u₁ v₁)}
             (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
             Y)
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max u₁ v₁)+1}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (Type (max u₁ v₁))
             category_theory.types.{(max u₁ v₁)}
             (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
             Y)
          (@category_theory.functor.map.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max u₁ v₁)+1}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (Type (max u₁ v₁))
             category_theory.types.{(max u₁ v₁)}
             (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
             X
             Y
             f)
          (λ
           (x :
             @category_theory.functor.obj.{(max u₁ v₁)
               (max u₁ v₁)
               (max u₁ v₁ u₁ (v₁+1))
               (max u₁ v₁)+1}
               (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁}))
               (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
               (Type (max u₁ v₁))
               category_theory.types.{(max u₁ v₁)}
               (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
               Y),
             @category_theory.nat_trans.mk.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
               (Type v₁)
               category_theory.types.{v₁}
               (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.obj.{(max u₁ v₁)
                        (max u₁ v₁)
                        (max u₁ v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                        (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.prod.{(max u₁ v₁)
                           (max u₁ v₁)
                           (max v₁ u₁ (v₁+1))
                           (max v₁ u₁ (v₁+1))}
                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.prod.{v₁
                           (max u₁ v₁)
                           (max u₁ v₁)
                           (max u₁ v₁)
                           u₁
                           (max v₁ u₁ (v₁+1))
                           (max v₁ u₁ (v₁+1))
                           (max v₁ u₁ (v₁+1))}
                           (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                           (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})))
                        Y)))
               (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@category_theory.functor.obj.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod.{(max u₁ v₁)
                        (max u₁ v₁)
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.prod.{v₁
                        (max u₁ v₁)
                        (max u₁ v₁)
                        (max u₁ v₁)
                        u₁
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                        (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})))
                     Y))
               (λ (X : opposite.{u₁+1} C)
                (a :
                  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                    (Type v₁)
                    category_theory.types.{v₁}
                    (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁})
                       (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.obj.{(max u₁ v₁)
                             (max u₁ v₁)
                             (max u₁ v₁ u₁ (v₁+1))
                             (max v₁ u₁ (v₁+1))}
                             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                             (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                (opposite.{(max v₁ u₁ (v₁+1))+1}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.prod.{(max u₁ v₁)
                                (max u₁ v₁)
                                (max v₁ u₁ (v₁+1))
                                (max v₁ u₁ (v₁+1))}
                                (opposite.{(max v₁ u₁ (v₁+1))+1}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.functor.prod.{v₁
                                (max u₁ v₁)
                                (max u₁ v₁)
                                (max u₁ v₁)
                                u₁
                                (max v₁ u₁ (v₁+1))
                                (max v₁ u₁ (v₁+1))
                                (max v₁ u₁ (v₁+1))}
                                (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (opposite.{(max v₁ u₁ (v₁+1))+1}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})))
                             Y)))
                    X),
                  @category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                    (Type v₁)
                    category_theory.types.{v₁}
                    (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁})
                       Y)
                    (@opposite.op.{u₁+1} C
                       (@opposite.unop.{u₁+1} C
                          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             Y)))
                    X
                    (@category_theory.has_hom.hom.op.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       (@opposite.unop.{u₁+1} C X)
                       (@opposite.unop.{u₁+1} C
                          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             Y))
                       a)
                    (@ulift.down.{u₁ v₁}
                       (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
                          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          Y)
                       x))
               (λ (X Y_1 : opposite.{u₁+1} C)
                (f :
                  @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                       (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                    X
                    Y_1),
                  @funext.{v₁+1 v₁+1}
                    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁}
                       (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                             (opposite.{(max v₁ u₁ (v₁+1))+1}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.obj.{(max u₁ v₁)
                                (max u₁ v₁)
                                (max u₁ v₁ u₁ (v₁+1))
                                (max v₁ u₁ (v₁+1))}
                                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.prod.{(max u₁ v₁)
                                   (max u₁ v₁)
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.prod.{v₁
                                   (max u₁ v₁)
                                   (max u₁ v₁)
                                   (max u₁ v₁)
                                   u₁
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                      𝒞
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                   (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})))
                                Y)))
                       X)
                    (λ
                     (x :
                       @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}
                         (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                               (opposite.{(max v₁ u₁ (v₁+1))+1}
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.functor.obj.{(max u₁ v₁)
                                  (max u₁ v₁)
                                  (max u₁ v₁ u₁ (v₁+1))
                                  (max v₁ u₁ (v₁+1))}
                                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                  (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.prod.{(max u₁ v₁)
                                     (max u₁ v₁)
                                     (max v₁ u₁ (v₁+1))
                                     (max v₁ u₁ (v₁+1))}
                                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.prod.{v₁
                                     (max u₁ v₁)
                                     (max u₁ v₁)
                                     (max u₁ v₁)
                                     u₁
                                     (max v₁ u₁ (v₁+1))
                                     (max v₁ u₁ (v₁+1))
                                     (max v₁ u₁ (v₁+1))}
                                     (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                        𝒞
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                     (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})))
                                  Y)))
                         X),
                       @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}
                         (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                            (opposite.{(max v₁ u₁ (v₁+1))+1}
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁}))
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            (@category_theory.functor.obj.{(max u₁ v₁)
                               (max u₁ v₁)
                               (max u₁ v₁ u₁ (v₁+1))
                               (max v₁ u₁ (v₁+1))}
                               (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                               (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.prod.{(max u₁ v₁)
                                  (max u₁ v₁)
                                  (max v₁ u₁ (v₁+1))
                                  (max v₁ u₁ (v₁+1))}
                                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.functor.prod.{v₁
                                  (max u₁ v₁)
                                  (max u₁ v₁)
                                  (max u₁ v₁)
                                  u₁
                                  (max v₁ u₁ (v₁+1))
                                  (max v₁ u₁ (v₁+1))
                                  (max v₁ u₁ (v₁+1))}
                                  (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                     𝒞
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                  (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})))
                               Y))
                         Y_1)
                    (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                       (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                          category_theory.types.{v₁})
                       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                (opposite.{(max v₁ u₁ (v₁+1))+1}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.obj.{(max u₁ v₁)
                                   (max u₁ v₁)
                                   (max u₁ v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                   (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.prod.{(max u₁ v₁)
                                      (max u₁ v₁)
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))}
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.prod.{v₁
                                      (max u₁ v₁)
                                      (max u₁ v₁)
                                      (max u₁ v₁)
                                      u₁
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))}
                                      (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))}
                                         C
                                         𝒞
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                      (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})))
                                   Y)))
                          X)
                       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                (opposite.{(max v₁ u₁ (v₁+1))+1}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.obj.{(max u₁ v₁)
                                   (max u₁ v₁)
                                   (max u₁ v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                   (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.prod.{(max u₁ v₁)
                                      (max u₁ v₁)
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))}
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.prod.{v₁
                                      (max u₁ v₁)
                                      (max u₁ v₁)
                                      (max u₁ v₁)
                                      u₁
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))}
                                      (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (… 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      …
                                      …
                                      …)
                                   Y)))
                          Y_1)
                       …
                       …
                       …)
                    …
                    …))
          x)
       x_1
       x_2)
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
f :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}))
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)))
    X
    Y,
x :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
    X,
x_1 : opposite.{u₁+1} C,
x_2 :
  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
    (Type v₁)
    category_theory.types.{v₁}
    (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
          (opposite.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max v₁ u₁ (v₁+1))}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod.{(max u₁ v₁) (max u₁ v₁) (max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.prod.{v₁
                (max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁)
                u₁
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             Y)))
    x_1
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       x_1)
    (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       x_1
       (@category_theory.has_hom.hom.op.{v₁ u₁} C
          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
          (@opposite.unop.{u₁+1} C x_1)
          (@opposite.unop.{u₁+1} C
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          x_2)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          (@prod.snd.{v₁ (max u₁ v₁)}
             (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y))
             (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})))
                (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)
                (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y))
             f)
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y)
             (@prod.fst.{v₁ (max u₁ v₁)}
                (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})))
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                f)
             (@ulift.down.{u₁ v₁}
                (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X))
                x))))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          X)
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.snd.{v₁ (max u₁ v₁)}
          (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          f)
       x_1
       (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          x_1
          (@category_theory.category_struct.comp.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y)
             x_1
             (@prod.fst.{v₁ (max u₁ v₁)}
                (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})))
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                f)
             (@category_theory.has_hom.hom.op.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (@opposite.unop.{u₁+1} C x_1)
                (@opposite.unop.{u₁+1} C
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                x_2))
          (@ulift.down.{u₁ v₁}
             (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}
                (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X))
             x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167        rw [←functor_to_types.naturality, functor_to_types.map_comp]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='category_theory.functor_to_types.naturality'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.functor_to_types.map_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/types.lean&#x27;, &#x27;line&#x27;: 42, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/types.lean&#x27;, &#x27;line&#x27;: 36, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (F G : @category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) {X Y : C} (σ : @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}))) F G) (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y) (x : @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F X), @eq.{v₁+1} (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} G Y) (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F G σ Y (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F X Y f x)) (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} G X Y f (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F G σ X x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (F : @category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) {X Y Z : C} (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y) (g : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) Y Z) (a : @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F X), @eq.{v₁+1} (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F Z) (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F X Z (@category_theory.category_struct.comp.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X Y Z f g) a) (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F Y Z g (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F X Y f a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
f :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}))
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)))
    X
    Y,
x :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
    X,
x_1 : opposite.{u₁+1} C,
x_2 :
  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
    (Type v₁)
    category_theory.types.{v₁}
    (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
          (opposite.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max v₁ u₁ (v₁+1))}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod.{(max u₁ v₁) (max u₁ v₁) (max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.prod.{v₁
                (max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁)
                u₁
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             Y)))
    x_1
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       x_1)
    (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       x_1
       (@category_theory.has_hom.hom.op.{v₁ u₁} C
          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
          (@opposite.unop.{u₁+1} C x_1)
          (@opposite.unop.{u₁+1} C
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          x_2)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          (@prod.snd.{v₁ (max u₁ v₁)}
             (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y))
             (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})))
                (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)
                (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y))
             f)
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y)
             (@prod.fst.{v₁ (max u₁ v₁)}
                (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})))
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                f)
             (@ulift.down.{u₁ v₁}
                (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X))
                x))))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          X)
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.snd.{v₁ (max u₁ v₁)}
          (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          f)
       x_1
       (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          x_1
          (@category_theory.category_struct.comp.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y)
             x_1
             (@prod.fst.{v₁ (max u₁ v₁)}
                (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})))
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                f)
             (@category_theory.has_hom.hom.op.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (@opposite.unop.{u₁+1} C x_1)
                (@opposite.unop.{u₁+1} C
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                x_2))
          (@ulift.down.{u₁ v₁}
             (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}
                (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X))
             x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
f :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}))
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)))
    X
    Y,
x :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
    X,
x_1 : opposite.{u₁+1} C,
x_2 :
  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
    (Type v₁)
    category_theory.types.{v₁}
    (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
          (opposite.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max v₁ u₁ (v₁+1))}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod.{(max u₁ v₁) (max u₁ v₁) (max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.prod.{v₁
                (max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁)
                u₁
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             Y)))
    x_1
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       x_1)
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          X)
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.snd.{v₁ (max u₁ v₁)}
          (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          f)
       x_1
       (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          x_1
          (@category_theory.has_hom.hom.op.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@opposite.unop.{u₁+1} C x_1)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y))
             x_2)
          (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y)
             (@prod.fst.{v₁ (max u₁ v₁)}
                (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})))
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                f)
             (@ulift.down.{u₁ v₁}
                (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X))
                x))))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          X)
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.snd.{v₁ (max u₁ v₁)}
          (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          f)
       x_1
       (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          x_1
          (@category_theory.category_struct.comp.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y)
             x_1
             (@prod.fst.{v₁ (max u₁ v₁)}
                (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})))
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                f)
             (@category_theory.has_hom.hom.op.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (@opposite.unop.{u₁+1} C x_1)
                (@opposite.unop.{u₁+1} C
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                x_2))
          (@ulift.down.{u₁ v₁}
             (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}
                (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X))
             x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
f :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}))
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)))
    X
    Y,
x :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
    X,
x_1 : opposite.{u₁+1} C,
x_2 :
  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
    (Type v₁)
    category_theory.types.{v₁}
    (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
          (opposite.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max v₁ u₁ (v₁+1))}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod.{(max u₁ v₁) (max u₁ v₁) (max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.prod.{v₁
                (max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁)
                u₁
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             Y)))
    x_1
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       x_1)
    (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       x_1
       (@category_theory.has_hom.hom.op.{v₁ u₁} C
          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
          (@opposite.unop.{u₁+1} C x_1)
          (@opposite.unop.{u₁+1} C
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          x_2)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          (@prod.snd.{v₁ (max u₁ v₁)}
             (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y))
             (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})))
                (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)
                (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y))
             f)
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y)
             (@prod.fst.{v₁ (max u₁ v₁)}
                (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})))
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                f)
             (@ulift.down.{u₁ v₁}
                (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X))
                x))))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          X)
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.snd.{v₁ (max u₁ v₁)}
          (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          f)
       x_1
       (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          x_1
          (@category_theory.category_struct.comp.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y)
             x_1
             (@prod.fst.{v₁ (max u₁ v₁)}
                (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})))
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                f)
             (@category_theory.has_hom.hom.op.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (@opposite.unop.{u₁+1} C x_1)
                (@opposite.unop.{u₁+1} C
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                x_2))
          (@ulift.down.{u₁ v₁}
             (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}
                (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X))
             x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168      end },</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
X Y :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
f :
  @category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}))
       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)))
    X
    Y,
x :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
    X,
x_1 : opposite.{u₁+1} C,
x_2 :
  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
    (Type v₁)
    category_theory.types.{v₁}
    (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
          (opposite.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max v₁ u₁ (v₁+1))}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod.{(max u₁ v₁) (max u₁ v₁) (max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.prod.{v₁
                (max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁)
                u₁
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             Y)))
    x_1
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       x_1)
    (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       x_1
       (@category_theory.has_hom.hom.op.{v₁ u₁} C
          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
          (@opposite.unop.{u₁+1} C x_1)
          (@opposite.unop.{u₁+1} C
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          x_2)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          (@prod.snd.{v₁ (max u₁ v₁)}
             (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y))
             (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})))
                (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)
                (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   Y))
             f)
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             Y)
          (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y)
             (@prod.fst.{v₁ (max u₁ v₁)}
                (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})))
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                f)
             (@ulift.down.{u₁ v₁}
                (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X))
                x))))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          X)
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          Y)
       (@prod.snd.{v₁ (max u₁ v₁)}
          (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y))
          f)
       x_1
       (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             X)
          x_1
          (@category_theory.category_struct.comp.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞))
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                X)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                Y)
             x_1
             (@prod.fst.{v₁ (max u₁ v₁)}
                (@category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                      (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                (@category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})))
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      X)
                   (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                f)
             (@category_theory.has_hom.hom.op.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (@opposite.unop.{u₁+1} C x_1)
                (@opposite.unop.{u₁+1} C
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      Y))
                x_2))
          (@ulift.down.{u₁ v₁}
             (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}
                (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X)
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   X))
             x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169    hom_inv_id&#x27; :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C
⊢ @eq.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)+1}
    (@category_theory.has_hom.hom.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)
       (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))}
       (@category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)})
       (@category_theory.category_struct.to_has_hom.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)
          (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))}
          (@category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (Type (max u₁ v₁))
             category_theory.types.{(max u₁ v₁)})
          (@category_theory.category.to_category_struct.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)
             (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))}
             (@category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                (Type (max u₁ v₁))
                category_theory.types.{(max u₁ v₁)})
             (@category_theory.functor.category.{(max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁ u₁ (v₁+1))
                (max u₁ v₁)+1}
                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                (Type (max u₁ v₁))
                category_theory.types.{(max u₁ v₁)})))
       (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
       (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞))
    ((λ
      (_x _x_1 _x_2 :
        @category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)})
      (α :
        @category_theory.has_hom.hom.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)
          (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))}
          (@category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (Type (max u₁ v₁))
             category_theory.types.{(max u₁ v₁)})
          (@category_theory.has_hom.mk.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)
             (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))}
             (@category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                (Type (max u₁ v₁))
                category_theory.types.{(max u₁ v₁)})
             (λ
              (F G :
                @category_theory.functor.{(max u₁ v₁)
                  (max u₁ v₁)
                  (max u₁ v₁ u₁ (v₁+1))
                  (max u₁ v₁)+1}
                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                  (Type (max u₁ v₁))
                  category_theory.types.{(max u₁ v₁)}),
                @category_theory.nat_trans.{(max u₁ v₁)
                  (max u₁ v₁)
                  (max u₁ v₁ u₁ (v₁+1))
                  (max u₁ v₁)+1}
                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                  (Type (max u₁ v₁))
                  category_theory.types.{(max u₁ v₁)}
                  F
                  G))
          _x
          _x_1)
      (β :
        @category_theory.has_hom.hom.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)
          (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))}
          (@category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (Type (max u₁ v₁))
             category_theory.types.{(max u₁ v₁)})
          (@category_theory.has_hom.mk.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)
             (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))}
             (@category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                (Type (max u₁ v₁))
                category_theory.types.{(max u₁ v₁)})
             (λ
              (F G :
                @category_theory.functor.{(max u₁ v₁)
                  (max u₁ v₁)
                  (max u₁ v₁ u₁ (v₁+1))
                  (max u₁ v₁)+1}
                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                  (Type (max u₁ v₁))
                  category_theory.types.{(max u₁ v₁)}),
                @category_theory.nat_trans.{(max u₁ v₁)
                  (max u₁ v₁)
                  (max u₁ v₁ u₁ (v₁+1))
                  (max u₁ v₁)+1}
                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                  (Type (max u₁ v₁))
                  category_theory.types.{(max u₁ v₁)}
                  F
                  G))
          _x_1
          _x_2),
        @category_theory.nat_trans.vcomp.{(max u₁ v₁)
          (max u₁ v₁)
          (max u₁ v₁ u₁ (v₁+1))
          (max u₁ v₁)+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)}
          _x
          _x_1
          _x_2
          α
          β)
       (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
       (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
       (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
       (@category_theory.nat_trans.mk.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)}
          (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
          (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
          (λ
           (F :
             prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
           (x :
             @category_theory.functor.obj.{(max u₁ v₁)
               (max u₁ v₁)
               (max u₁ v₁ u₁ (v₁+1))
               (max u₁ v₁)+1}
               (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁}))
               (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
               (Type (max u₁ v₁))
               category_theory.types.{(max u₁ v₁)}
               (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
               F),
             @ulift.up.{u₁ v₁}
               (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}
                  (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  F)
               (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}
                  (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.obj.{(max u₁ v₁)
                           (max u₁ v₁)
                           (max u₁ v₁ u₁ (v₁+1))
                           (max v₁ u₁ (v₁+1))}
                           (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                           (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                              (opposite.{(max v₁ u₁ (v₁+1))+1}
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.prod.{(max u₁ v₁)
                              (max u₁ v₁)
                              (max v₁ u₁ (v₁+1))
                              (max v₁ u₁ (v₁+1))}
                              (opposite.{(max v₁ u₁ (v₁+1))+1}
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.prod.{v₁
                              (max u₁ v₁)
                              (max u₁ v₁)
                              (max u₁ v₁)
                              u₁
                              (max v₁ u₁ (v₁+1))
                              (max v₁ u₁ (v₁+1))
                              (max v₁ u₁ (v₁+1))}
                              (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (opposite.{(max v₁ u₁ (v₁+1))+1}
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                              (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})))
                           F)))
                  (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.obj.{(max u₁ v₁)
                        (max u₁ v₁)
                        (max u₁ v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                        (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.prod.{(max u₁ v₁)
                           (max u₁ v₁)
                           (max v₁ u₁ (v₁+1))
                           (max v₁ u₁ (v₁+1))}
                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.prod.{v₁
                           (max u₁ v₁)
                           (max u₁ v₁)
                           (max u₁ v₁)
                           u₁
                           (max v₁ u₁ (v₁+1))
                           (max v₁ u₁ (v₁+1))
                           (max v₁ u₁ (v₁+1))}
                           (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                           (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})))
                        F))
                  x
                  (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     F)
                  (@category_theory.category_struct.id.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                     (@opposite.unop.{u₁+1} C
                        (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           F)))))
          (λ
           (X Y :
             prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
           (f :
             @category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
               (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁}))
               (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)))
               X
               Y),
             @funext.{(max u₁ v₁)+1 (max u₁ v₁)+1}
               (@category_theory.functor.obj.{(max u₁ v₁)
                  (max u₁ v₁)
                  (max u₁ v₁ u₁ (v₁+1))
                  (max u₁ v₁)+1}
                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                  (Type (max u₁ v₁))
                  category_theory.types.{(max u₁ v₁)}
                  (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                  X)
               (λ
                (x :
                  @category_theory.functor.obj.{(max u₁ v₁)
                    (max u₁ v₁)
                    (max u₁ v₁ u₁ (v₁+1))
                    (max u₁ v₁)+1}
                    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}))
                    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                    (Type (max u₁ v₁))
                    category_theory.types.{(max u₁ v₁)}
                    (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                    X),
                  @category_theory.functor.obj.{(max u₁ v₁)
                    (max u₁ v₁)
                    (max u₁ v₁ u₁ (v₁+1))
                    (max u₁ v₁)+1}
                    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}))
                    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                    (Type (max u₁ v₁))
                    category_theory.types.{(max u₁ v₁)}
                    (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
                    Y)
               (@category_theory.category_struct.comp.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
                  (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁)+1}
                     (Type (max u₁ v₁))
                     category_theory.types.{(max u₁ v₁)})
                  (@category_theory.functor.obj.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max u₁ v₁)+1}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (Type (max u₁ v₁))
                     category_theory.types.{(max u₁ v₁)}
                     (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                     X)
                  (@category_theory.functor.obj.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max u₁ v₁)+1}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (Type (max u₁ v₁))
                     category_theory.types.{(max u₁ v₁)}
                     (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                     Y)
                  (@category_theory.functor.obj.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max u₁ v₁)+1}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (Type (max u₁ v₁))
                     category_theory.types.{(max u₁ v₁)}
                     (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
                     Y)
                  (@category_theory.functor.map.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max u₁ v₁)+1}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (Type (max u₁ v₁))
                     category_theory.types.{(max u₁ v₁)}
                     (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                     X
                     Y
                     f)
                  (λ
                   (x :
                     @category_theory.functor.obj.{(max u₁ v₁)
                       (max u₁ v₁)
                       (max u₁ v₁ u₁ (v₁+1))
                       (max u₁ v₁)+1}
                       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                       (Type (max u₁ v₁))
                       category_theory.types.{(max u₁ v₁)}
                       (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                       Y),
                     @ulift.up.{u₁ v₁}
                       (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
                          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          Y)
                       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                (opposite.{(max v₁ u₁ (v₁+1))+1}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.obj.{(max u₁ v₁)
                                   (max u₁ v₁)
                                   (max u₁ v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                   (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.prod.{(max u₁ v₁)
                                      (max u₁ v₁)
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))}
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.prod.{v₁
                                      (max u₁ v₁)
                                      (max u₁ v₁)
                                      (max u₁ v₁)
                                      u₁
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))}
                                      (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))}
                                         C
                                         𝒞
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                      (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})))
                                   Y)))
                          (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                             (opposite.{(max v₁ u₁ (v₁+1))+1}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.obj.{(max u₁ v₁)
                                (max u₁ v₁)
                                (max u₁ v₁ u₁ (v₁+1))
                                (max v₁ u₁ (v₁+1))}
                                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.prod.{(max u₁ v₁)
                                   (max u₁ v₁)
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.prod.{v₁
                                   (max u₁ v₁)
                                   (max u₁ v₁)
                                   (max u₁ v₁)
                                   u₁
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                      𝒞
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                   (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})))
                                Y))
                          x
                          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             Y)
                          (@category_theory.category_struct.id.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C
                                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   Y))))))
               (@category_theory.category_struct.comp.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
                  (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁)+1}
                     (Type (max u₁ v₁))
                     category_theory.types.{(max u₁ v₁)})
                  (@category_theory.functor.obj.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max u₁ v₁)+1}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (Type (max u₁ v₁))
                     category_theory.types.{(max u₁ v₁)}
                     (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                     X)
                  (@category_theory.functor.obj.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max u₁ v₁)+1}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (Type (max u₁ v₁))
                     category_theory.types.{(max u₁ v₁)}
                     (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
                     X)
                  (@category_theory.functor.obj.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max u₁ v₁)+1}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (Type (max u₁ v₁))
                     category_theory.types.{(max u₁ v₁)}
                     (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
                     Y)
                  (λ
                   (x :
                     @category_theory.functor.obj.{(max u₁ v₁)
                       (max u₁ v₁)
                       (max u₁ v₁ u₁ (v₁+1))
                       (max u₁ v₁)+1}
                       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                       (Type (max u₁ v₁))
                       category_theory.types.{(max u₁ v₁)}
                       (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                       X),
                     @ulift.up.{u₁ v₁}
                       (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
                          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          X)
                       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                (opposite.{(max v₁ u₁ (v₁+1))+1}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.obj.{(max u₁ v₁)
                                   (max u₁ v₁)
                                   (max u₁ v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                   (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.prod.{(max u₁ v₁)
                                      (max u₁ v₁)
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))}
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.prod.{v₁
                                      (max u₁ v₁)
                                      (max u₁ v₁)
                                      (max u₁ v₁)
                                      u₁
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))}
                                      (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))}
                                         C
                                         𝒞
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                      (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})))
                                   X)))
                          (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                             (opposite.{(max v₁ u₁ (v₁+1))+1}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.obj.{(max u₁ v₁)
                                (max u₁ v₁)
                                (max u₁ v₁ u₁ (v₁+1))
                                (max v₁ u₁ (v₁+1))}
                                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.prod.{(max u₁ v₁)
                                   (max u₁ v₁)
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.prod.{v₁
                                   (max u₁ v₁)
                                   (max u₁ v₁)
                                   (max u₁ v₁)
                                   u₁
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                      𝒞
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                   (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})))
                                X))
                          x
                          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             X)
                          (@category_theory.category_struct.id.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C
                                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   X)))))
                  (@category_theory.functor.map.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max u₁ v₁)+1}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (Type (max u₁ v₁))
                     category_theory.types.{(max u₁ v₁)}
                     (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
                     X
                     Y
                     f))
               (λ
                (x :
                  @category_theory.functor.obj.{(max u₁ v₁)
                    (max u₁ v₁)
                    (max u₁ v₁ u₁ (v₁+1))
                    (max u₁ v₁)+1}
                    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}))
                    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                    (Type (max u₁ v₁))
                    category_theory.types.{(max u₁ v₁)}
                    (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                    X),
                  @ulift.ext.{v₁ u₁}
                    (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
                       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁}
                       (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁})
                       Y)
                    (@category_theory.category_struct.comp.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
                       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁)+1}
                          (Type (max u₁ v₁))
                          category_theory.types.{(max u₁ v₁)})
                       (@category_theory.functor.obj.{(max u₁ v₁)
                          (max u₁ v₁)
                          (max u₁ v₁ u₁ (v₁+1))
                          (max u₁ v₁)+1}
                          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                          (Type (max u₁ v₁))
                          category_theory.types.{(max u₁ v₁)}
                          (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                          X)
                       (@category_theory.functor.obj.{(max u₁ v₁)
                          (max u₁ v₁)
                          (max u₁ v₁ u₁ (v₁+1))
                          (max u₁ v₁)+1}
                          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                          (Type (max u₁ v₁))
                          category_theory.types.{(max u₁ v₁)}
                          (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                          Y)
                       (@category_theory.functor.obj.{(max u₁ v₁)
                          (max u₁ v₁)
                          (max u₁ v₁ u₁ (v₁+1))
                          (max u₁ v₁)+1}
                          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                          (Type (max u₁ v₁))
                          category_theory.types.{(max u₁ v₁)}
                          (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
                          Y)
                       (@category_theory.functor.map.{(max u₁ v₁)
                          (max u₁ v₁)
                          (max u₁ v₁ u₁ (v₁+1))
                          (max u₁ v₁)+1}
                          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                          (Type (max u₁ v₁))
                          category_theory.types.{(max u₁ v₁)}
                          (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                          X
                          Y
                          f)
                       (λ
                        (x :
                          @category_theory.functor.obj.{(max u₁ v₁)
                            (max u₁ v₁)
                            (max u₁ v₁ u₁ (v₁+1))
                            (max u₁ v₁)+1}
                            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁}))
                            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                            (Type (max u₁ v₁))
                            category_theory.types.{(max u₁ v₁)}
                            (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                            Y),
                          @ulift.up.{u₁ v₁}
                            (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
                               (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁}
                               (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               Y)
                            (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁}
                               (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.obj.{(max u₁ v₁)
                                        (max u₁ v₁)
                                        (max u₁ v₁ u₁ (v₁+1))
                                        (max v₁ u₁ (v₁+1))}
                                        (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁}))
                                        (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                        (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                 (Type v₁)
                                                 category_theory.types.{v₁}))
                                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁}))
                                        (@category_theory.prod.{(max u₁ v₁)
                                           (max u₁ v₁)
                                           (max v₁ u₁ (v₁+1))
                                           (max v₁ u₁ (v₁+1))}
                                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                 (Type v₁)
                                                 category_theory.types.{v₁}))
                                           (@category_theory.category.opposite.{(max u₁ v₁)
                                              (max v₁ u₁ (v₁+1))}
                                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                 (Type v₁)
                                                 category_theory.types.{v₁})
                                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                                 (opposite.{u₁+1} C)
                                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                 (Type v₁)
                                                 category_theory.types.{v₁}))
                                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁})
                                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                              (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁}))
                                        (@category_theory.functor.prod.{v₁
                                           (max u₁ v₁)
                                           (max u₁ v₁)
                                           (max u₁ v₁)
                                           u₁
                                           (max v₁ u₁ (v₁+1))
                                           (max v₁ u₁ (v₁+1))
                                           (max v₁ u₁ (v₁+1))}
                                           (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                 (Type v₁)
                                                 category_theory.types.{v₁}))
                                           (@category_theory.category.opposite.{(max u₁ v₁)
                                              (max v₁ u₁ (v₁+1))}
                                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                 (Type v₁)
                                                 category_theory.types.{v₁})
                                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                                 (opposite.{u₁+1} C)
                                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                 (Type v₁)
                                                 category_theory.types.{v₁}))
                                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁})
                                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                              (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁})
                                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁})
                                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                              (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁})
                                           (@category_theory.functor.op.{v₁
                                              (max u₁ v₁)
                                              u₁
                                              (max v₁ u₁ (v₁+1))}
                                              C
                                              𝒞
                                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                 (Type v₁)
                                                 category_theory.types.{v₁})
                                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                                 (opposite.{u₁+1} C)
                                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                 (Type v₁)
                                                 category_theory.types.{v₁})
                                              (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                           (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                 (Type v₁)
                                                 category_theory.types.{v₁})
                                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                                 (opposite.{u₁+1} C)
                                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                 (Type v₁)
                                                 category_theory.types.{v₁})))
                                        Y)))
                               (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (… (Type v₁) category_theory.types.{v₁})
                                  …)
                               x
                               …
                               …))
                       x)
                    …
                    …)))
       …)
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171      ext, dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C
⊢ @eq.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)+1}
    (@category_theory.has_hom.hom.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)
       (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))}
       (@category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)})
       (@category_theory.category_struct.to_has_hom.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)
          (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))}
          (@category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (Type (max u₁ v₁))
             category_theory.types.{(max u₁ v₁)})
          (@category_theory.category.to_category_struct.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)
             (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))}
             (@category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                (Type (max u₁ v₁))
                category_theory.types.{(max u₁ v₁)})
             (@category_theory.functor.category.{(max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁ u₁ (v₁+1))
                (max u₁ v₁)+1}
                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                (Type (max u₁ v₁))
                category_theory.types.{(max u₁ v₁)})))
       (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
       (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞))
    ((λ
      (_x _x_1 _x_2 :
        @category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)})
      (α :
        @category_theory.has_hom.hom.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)
          (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))}
          (@category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (Type (max u₁ v₁))
             category_theory.types.{(max u₁ v₁)})
          (@category_theory.has_hom.mk.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)
             (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))}
             (@category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                (Type (max u₁ v₁))
                category_theory.types.{(max u₁ v₁)})
             (λ
              (F G :
                @category_theory.functor.{(max u₁ v₁)
                  (max u₁ v₁)
                  (max u₁ v₁ u₁ (v₁+1))
                  (max u₁ v₁)+1}
                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                  (Type (max u₁ v₁))
                  category_theory.types.{(max u₁ v₁)}),
                @category_theory.nat_trans.{(max u₁ v₁)
                  (max u₁ v₁)
                  (max u₁ v₁ u₁ (v₁+1))
                  (max u₁ v₁)+1}
                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                  (Type (max u₁ v₁))
                  category_theory.types.{(max u₁ v₁)}
                  F
                  G))
          _x
          _x_1)
      (β :
        @category_theory.has_hom.hom.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)
          (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))}
          (@category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (Type (max u₁ v₁))
             category_theory.types.{(max u₁ v₁)})
          (@category_theory.has_hom.mk.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)
             (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))}
             (@category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                (Type (max u₁ v₁))
                category_theory.types.{(max u₁ v₁)})
             (λ
              (F G :
                @category_theory.functor.{(max u₁ v₁)
                  (max u₁ v₁)
                  (max u₁ v₁ u₁ (v₁+1))
                  (max u₁ v₁)+1}
                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                  (Type (max u₁ v₁))
                  category_theory.types.{(max u₁ v₁)}),
                @category_theory.nat_trans.{(max u₁ v₁)
                  (max u₁ v₁)
                  (max u₁ v₁ u₁ (v₁+1))
                  (max u₁ v₁)+1}
                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                  (Type (max u₁ v₁))
                  category_theory.types.{(max u₁ v₁)}
                  F
                  G))
          _x_1
          _x_2),
        @category_theory.nat_trans.vcomp.{(max u₁ v₁)
          (max u₁ v₁)
          (max u₁ v₁ u₁ (v₁+1))
          (max u₁ v₁)+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)}
          _x
          _x_1
          _x_2
          α
          β)
       (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
       (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
       (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
       (@category_theory.nat_trans.mk.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)}
          (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
          (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
          (λ
           (F :
             prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
           (x :
             @category_theory.functor.obj.{(max u₁ v₁)
               (max u₁ v₁)
               (max u₁ v₁ u₁ (v₁+1))
               (max u₁ v₁)+1}
               (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁}))
               (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
               (Type (max u₁ v₁))
               category_theory.types.{(max u₁ v₁)}
               (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
               F),
             @ulift.up.{u₁ v₁}
               (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}
                  (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  F)
               (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}
                  (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.obj.{(max u₁ v₁)
                           (max u₁ v₁)
                           (max u₁ v₁ u₁ (v₁+1))
                           (max v₁ u₁ (v₁+1))}
                           (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                           (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                              (opposite.{(max v₁ u₁ (v₁+1))+1}
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.prod.{(max u₁ v₁)
                              (max u₁ v₁)
                              (max v₁ u₁ (v₁+1))
                              (max v₁ u₁ (v₁+1))}
                              (opposite.{(max v₁ u₁ (v₁+1))+1}
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.prod.{v₁
                              (max u₁ v₁)
                              (max u₁ v₁)
                              (max u₁ v₁)
                              u₁
                              (max v₁ u₁ (v₁+1))
                              (max v₁ u₁ (v₁+1))
                              (max v₁ u₁ (v₁+1))}
                              (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (opposite.{(max v₁ u₁ (v₁+1))+1}
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                              (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})))
                           F)))
                  (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.obj.{(max u₁ v₁)
                        (max u₁ v₁)
                        (max u₁ v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                        (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.prod.{(max u₁ v₁)
                           (max u₁ v₁)
                           (max v₁ u₁ (v₁+1))
                           (max v₁ u₁ (v₁+1))}
                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.prod.{v₁
                           (max u₁ v₁)
                           (max u₁ v₁)
                           (max u₁ v₁)
                           u₁
                           (max v₁ u₁ (v₁+1))
                           (max v₁ u₁ (v₁+1))
                           (max v₁ u₁ (v₁+1))}
                           (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                           (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})))
                        F))
                  x
                  (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     F)
                  (@category_theory.category_struct.id.{v₁ u₁} C
                     (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                     (@opposite.unop.{u₁+1} C
                        (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           F)))))
          (λ
           (X Y :
             prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
           (f :
             @category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
               (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁}))
               (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)))
               X
               Y),
             @funext.{(max u₁ v₁)+1 (max u₁ v₁)+1}
               (@category_theory.functor.obj.{(max u₁ v₁)
                  (max u₁ v₁)
                  (max u₁ v₁ u₁ (v₁+1))
                  (max u₁ v₁)+1}
                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                  (Type (max u₁ v₁))
                  category_theory.types.{(max u₁ v₁)}
                  (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                  X)
               (λ
                (x :
                  @category_theory.functor.obj.{(max u₁ v₁)
                    (max u₁ v₁)
                    (max u₁ v₁ u₁ (v₁+1))
                    (max u₁ v₁)+1}
                    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}))
                    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                    (Type (max u₁ v₁))
                    category_theory.types.{(max u₁ v₁)}
                    (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                    X),
                  @category_theory.functor.obj.{(max u₁ v₁)
                    (max u₁ v₁)
                    (max u₁ v₁ u₁ (v₁+1))
                    (max u₁ v₁)+1}
                    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}))
                    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                    (Type (max u₁ v₁))
                    category_theory.types.{(max u₁ v₁)}
                    (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
                    Y)
               (@category_theory.category_struct.comp.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
                  (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁)+1}
                     (Type (max u₁ v₁))
                     category_theory.types.{(max u₁ v₁)})
                  (@category_theory.functor.obj.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max u₁ v₁)+1}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (Type (max u₁ v₁))
                     category_theory.types.{(max u₁ v₁)}
                     (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                     X)
                  (@category_theory.functor.obj.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max u₁ v₁)+1}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (Type (max u₁ v₁))
                     category_theory.types.{(max u₁ v₁)}
                     (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                     Y)
                  (@category_theory.functor.obj.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max u₁ v₁)+1}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (Type (max u₁ v₁))
                     category_theory.types.{(max u₁ v₁)}
                     (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
                     Y)
                  (@category_theory.functor.map.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max u₁ v₁)+1}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (Type (max u₁ v₁))
                     category_theory.types.{(max u₁ v₁)}
                     (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                     X
                     Y
                     f)
                  (λ
                   (x :
                     @category_theory.functor.obj.{(max u₁ v₁)
                       (max u₁ v₁)
                       (max u₁ v₁ u₁ (v₁+1))
                       (max u₁ v₁)+1}
                       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                       (Type (max u₁ v₁))
                       category_theory.types.{(max u₁ v₁)}
                       (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                       Y),
                     @ulift.up.{u₁ v₁}
                       (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
                          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          Y)
                       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                (opposite.{(max v₁ u₁ (v₁+1))+1}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.obj.{(max u₁ v₁)
                                   (max u₁ v₁)
                                   (max u₁ v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                   (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.prod.{(max u₁ v₁)
                                      (max u₁ v₁)
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))}
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.prod.{v₁
                                      (max u₁ v₁)
                                      (max u₁ v₁)
                                      (max u₁ v₁)
                                      u₁
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))}
                                      (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))}
                                         C
                                         𝒞
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                      (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})))
                                   Y)))
                          (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                             (opposite.{(max v₁ u₁ (v₁+1))+1}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.obj.{(max u₁ v₁)
                                (max u₁ v₁)
                                (max u₁ v₁ u₁ (v₁+1))
                                (max v₁ u₁ (v₁+1))}
                                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.prod.{(max u₁ v₁)
                                   (max u₁ v₁)
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.prod.{v₁
                                   (max u₁ v₁)
                                   (max u₁ v₁)
                                   (max u₁ v₁)
                                   u₁
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                      𝒞
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                   (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})))
                                Y))
                          x
                          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             Y)
                          (@category_theory.category_struct.id.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C
                                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   Y))))))
               (@category_theory.category_struct.comp.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
                  (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁)+1}
                     (Type (max u₁ v₁))
                     category_theory.types.{(max u₁ v₁)})
                  (@category_theory.functor.obj.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max u₁ v₁)+1}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (Type (max u₁ v₁))
                     category_theory.types.{(max u₁ v₁)}
                     (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                     X)
                  (@category_theory.functor.obj.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max u₁ v₁)+1}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (Type (max u₁ v₁))
                     category_theory.types.{(max u₁ v₁)}
                     (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
                     X)
                  (@category_theory.functor.obj.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max u₁ v₁)+1}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (Type (max u₁ v₁))
                     category_theory.types.{(max u₁ v₁)}
                     (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
                     Y)
                  (λ
                   (x :
                     @category_theory.functor.obj.{(max u₁ v₁)
                       (max u₁ v₁)
                       (max u₁ v₁ u₁ (v₁+1))
                       (max u₁ v₁)+1}
                       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                       (Type (max u₁ v₁))
                       category_theory.types.{(max u₁ v₁)}
                       (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                       X),
                     @ulift.up.{u₁ v₁}
                       (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
                          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          X)
                       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                (opposite.{(max v₁ u₁ (v₁+1))+1}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.obj.{(max u₁ v₁)
                                   (max u₁ v₁)
                                   (max u₁ v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                   (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.prod.{(max u₁ v₁)
                                      (max u₁ v₁)
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))}
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.prod.{v₁
                                      (max u₁ v₁)
                                      (max u₁ v₁)
                                      (max u₁ v₁)
                                      u₁
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))}
                                      (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))}
                                         C
                                         𝒞
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                      (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})))
                                   X)))
                          (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                             (opposite.{(max v₁ u₁ (v₁+1))+1}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.obj.{(max u₁ v₁)
                                (max u₁ v₁)
                                (max u₁ v₁ u₁ (v₁+1))
                                (max v₁ u₁ (v₁+1))}
                                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.prod.{(max u₁ v₁)
                                   (max u₁ v₁)
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.prod.{v₁
                                   (max u₁ v₁)
                                   (max u₁ v₁)
                                   (max u₁ v₁)
                                   u₁
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                      𝒞
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                   (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})))
                                X))
                          x
                          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             X)
                          (@category_theory.category_struct.id.{v₁ u₁} C
                             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                             (@opposite.unop.{u₁+1} C
                                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   X)))))
                  (@category_theory.functor.map.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max u₁ v₁)+1}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (Type (max u₁ v₁))
                     category_theory.types.{(max u₁ v₁)}
                     (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
                     X
                     Y
                     f))
               (λ
                (x :
                  @category_theory.functor.obj.{(max u₁ v₁)
                    (max u₁ v₁)
                    (max u₁ v₁ u₁ (v₁+1))
                    (max u₁ v₁)+1}
                    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}))
                    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                    (Type (max u₁ v₁))
                    category_theory.types.{(max u₁ v₁)}
                    (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                    X),
                  @ulift.ext.{v₁ u₁}
                    (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
                       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}))
                       (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁}
                       (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁})
                       Y)
                    (@category_theory.category_struct.comp.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
                       (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁)+1}
                          (Type (max u₁ v₁))
                          category_theory.types.{(max u₁ v₁)})
                       (@category_theory.functor.obj.{(max u₁ v₁)
                          (max u₁ v₁)
                          (max u₁ v₁ u₁ (v₁+1))
                          (max u₁ v₁)+1}
                          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                          (Type (max u₁ v₁))
                          category_theory.types.{(max u₁ v₁)}
                          (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                          X)
                       (@category_theory.functor.obj.{(max u₁ v₁)
                          (max u₁ v₁)
                          (max u₁ v₁ u₁ (v₁+1))
                          (max u₁ v₁)+1}
                          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                          (Type (max u₁ v₁))
                          category_theory.types.{(max u₁ v₁)}
                          (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                          Y)
                       (@category_theory.functor.obj.{(max u₁ v₁)
                          (max u₁ v₁)
                          (max u₁ v₁ u₁ (v₁+1))
                          (max u₁ v₁)+1}
                          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                          (Type (max u₁ v₁))
                          category_theory.types.{(max u₁ v₁)}
                          (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
                          Y)
                       (@category_theory.functor.map.{(max u₁ v₁)
                          (max u₁ v₁)
                          (max u₁ v₁ u₁ (v₁+1))
                          (max u₁ v₁)+1}
                          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                          (Type (max u₁ v₁))
                          category_theory.types.{(max u₁ v₁)}
                          (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                          X
                          Y
                          f)
                       (λ
                        (x :
                          @category_theory.functor.obj.{(max u₁ v₁)
                            (max u₁ v₁)
                            (max u₁ v₁ u₁ (v₁+1))
                            (max u₁ v₁)+1}
                            (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁}))
                            (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                            (Type (max u₁ v₁))
                            category_theory.types.{(max u₁ v₁)}
                            (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                            Y),
                          @ulift.up.{u₁ v₁}
                            (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
                               (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁}
                               (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               Y)
                            (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁}
                               (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.obj.{(max u₁ v₁)
                                        (max u₁ v₁)
                                        (max u₁ v₁ u₁ (v₁+1))
                                        (max v₁ u₁ (v₁+1))}
                                        (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁}))
                                        (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                        (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                 (Type v₁)
                                                 category_theory.types.{v₁}))
                                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁}))
                                        (@category_theory.prod.{(max u₁ v₁)
                                           (max u₁ v₁)
                                           (max v₁ u₁ (v₁+1))
                                           (max v₁ u₁ (v₁+1))}
                                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                 (Type v₁)
                                                 category_theory.types.{v₁}))
                                           (@category_theory.category.opposite.{(max u₁ v₁)
                                              (max v₁ u₁ (v₁+1))}
                                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                 (Type v₁)
                                                 category_theory.types.{v₁})
                                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                                 (opposite.{u₁+1} C)
                                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                 (Type v₁)
                                                 category_theory.types.{v₁}))
                                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁})
                                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                              (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁}))
                                        (@category_theory.functor.prod.{v₁
                                           (max u₁ v₁)
                                           (max u₁ v₁)
                                           (max u₁ v₁)
                                           u₁
                                           (max v₁ u₁ (v₁+1))
                                           (max v₁ u₁ (v₁+1))
                                           (max v₁ u₁ (v₁+1))}
                                           (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                 (Type v₁)
                                                 category_theory.types.{v₁}))
                                           (@category_theory.category.opposite.{(max u₁ v₁)
                                              (max v₁ u₁ (v₁+1))}
                                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                 (Type v₁)
                                                 category_theory.types.{v₁})
                                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                                 (opposite.{u₁+1} C)
                                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                 (Type v₁)
                                                 category_theory.types.{v₁}))
                                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁})
                                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                              (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁})
                                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁})
                                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                              (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁})
                                           (@category_theory.functor.op.{v₁
                                              (max u₁ v₁)
                                              u₁
                                              (max v₁ u₁ (v₁+1))}
                                              C
                                              𝒞
                                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                 (Type v₁)
                                                 category_theory.types.{v₁})
                                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                                 (opposite.{u₁+1} C)
                                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                 (Type v₁)
                                                 category_theory.types.{v₁})
                                              (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                           (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                 (Type v₁)
                                                 category_theory.types.{v₁})
                                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                                 (opposite.{u₁+1} C)
                                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                 (Type v₁)
                                                 category_theory.types.{v₁})))
                                        Y)))
                               (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (… (Type v₁) category_theory.types.{v₁})
                                  …)
                               x
                               …
                               …))
                       x)
                    …
                    …)))
       …)
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
x :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
x_1 :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
    x,
x_2 : opposite.{u₁+1} C,
x_3 :
  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
    (Type v₁)
    category_theory.types.{v₁}
    (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
          (opposite.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max v₁ u₁ (v₁+1))}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod.{(max u₁ v₁) (max u₁ v₁) (max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.prod.{v₁
                (max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁)
                u₁
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             x)))
    x_2
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
          (opposite.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max v₁ u₁ (v₁+1))}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod.{(max u₁ v₁) (max u₁ v₁) (max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.prod.{v₁
                (max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁)
                u₁
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             x))
       x_2)
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
             (opposite.{(max v₁ u₁ (v₁+1))+1}
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.obj.{(max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod.{(max u₁ v₁)
                   (max u₁ v₁)
                   (max v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))}
                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.prod.{v₁
                   (max u₁ v₁)
                   (max u₁ v₁)
                   (max u₁ v₁)
                   u₁
                   (max v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))
                   (max v₁ u₁ (v₁+1))}
                   (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                   (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})))
                x)))
       (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
          (opposite.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max v₁ u₁ (v₁+1))}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod.{(max u₁ v₁) (max u₁ v₁) (max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.prod.{v₁
                (max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁)
                u₁
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             x))
       (@category_theory.nat_trans.app.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)}
          (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
          (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
          ((λ
            (_x _x_1 _x_2 :
              @category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                (Type (max u₁ v₁))
                category_theory.types.{(max u₁ v₁)})
            (α :
              @category_theory.has_hom.hom.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)
                (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))}
                (@category_theory.functor.{(max u₁ v₁)
                   (max u₁ v₁)
                   (max u₁ v₁ u₁ (v₁+1))
                   (max u₁ v₁)+1}
                   (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                   (Type (max u₁ v₁))
                   category_theory.types.{(max u₁ v₁)})
                (@category_theory.has_hom.mk.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)
                   (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))}
                   (@category_theory.functor.{(max u₁ v₁)
                      (max u₁ v₁)
                      (max u₁ v₁ u₁ (v₁+1))
                      (max u₁ v₁)+1}
                      (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                      (Type (max u₁ v₁))
                      category_theory.types.{(max u₁ v₁)})
                   (λ
                    (F G :
                      @category_theory.functor.{(max u₁ v₁)
                        (max u₁ v₁)
                        (max u₁ v₁ u₁ (v₁+1))
                        (max u₁ v₁)+1}
                        (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                        (Type (max u₁ v₁))
                        category_theory.types.{(max u₁ v₁)}),
                      @category_theory.nat_trans.{(max u₁ v₁)
                        (max u₁ v₁)
                        (max u₁ v₁ u₁ (v₁+1))
                        (max u₁ v₁)+1}
                        (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                        (Type (max u₁ v₁))
                        category_theory.types.{(max u₁ v₁)}
                        F
                        G))
                _x
                _x_1)
            (β :
              @category_theory.has_hom.hom.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)
                (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))}
                (@category_theory.functor.{(max u₁ v₁)
                   (max u₁ v₁)
                   (max u₁ v₁ u₁ (v₁+1))
                   (max u₁ v₁)+1}
                   (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                   (Type (max u₁ v₁))
                   category_theory.types.{(max u₁ v₁)})
                (@category_theory.has_hom.mk.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)
                   (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))}
                   (@category_theory.functor.{(max u₁ v₁)
                      (max u₁ v₁)
                      (max u₁ v₁ u₁ (v₁+1))
                      (max u₁ v₁)+1}
                      (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}))
                      (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                      (Type (max u₁ v₁))
                      category_theory.types.{(max u₁ v₁)})
                   (λ
                    (F G :
                      @category_theory.functor.{(max u₁ v₁)
                        (max u₁ v₁)
                        (max u₁ v₁ u₁ (v₁+1))
                        (max u₁ v₁)+1}
                        (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                        (Type (max u₁ v₁))
                        category_theory.types.{(max u₁ v₁)}),
                      @category_theory.nat_trans.{(max u₁ v₁)
                        (max u₁ v₁)
                        (max u₁ v₁ u₁ (v₁+1))
                        (max u₁ v₁)+1}
                        (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                        (Type (max u₁ v₁))
                        category_theory.types.{(max u₁ v₁)}
                        F
                        G))
                _x_1
                _x_2),
              @category_theory.nat_trans.vcomp.{(max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁ u₁ (v₁+1))
                (max u₁ v₁)+1}
                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                (Type (max u₁ v₁))
                category_theory.types.{(max u₁ v₁)}
                _x
                _x_1
                _x_2
                α
                β)
             (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
             (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
             (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
             (@category_theory.nat_trans.mk.{(max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁ u₁ (v₁+1))
                (max u₁ v₁)+1}
                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                (Type (max u₁ v₁))
                category_theory.types.{(max u₁ v₁)}
                (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
                (λ
                 (F :
                   prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                 (x :
                   @category_theory.functor.obj.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max u₁ v₁)+1}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (Type (max u₁ v₁))
                     category_theory.types.{(max u₁ v₁)}
                     (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                     F),
                   @ulift.up.{u₁ v₁}
                     (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
                        (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}
                        (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        F)
                     (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}
                        (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                              (opposite.{(max v₁ u₁ (v₁+1))+1}
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.obj.{(max u₁ v₁)
                                 (max u₁ v₁)
                                 (max u₁ v₁ u₁ (v₁+1))
                                 (max v₁ u₁ (v₁+1))}
                                 (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁}))
                                 (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                 (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                    (opposite.{(max v₁ u₁ (v₁+1))+1}
                                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁}))
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁}))
                                 (@category_theory.prod.{(max u₁ v₁)
                                    (max u₁ v₁)
                                    (max v₁ u₁ (v₁+1))
                                    (max v₁ u₁ (v₁+1))}
                                    (opposite.{(max v₁ u₁ (v₁+1))+1}
                                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁}))
                                    (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁})
                                       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁}))
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁}))
                                 (@category_theory.functor.prod.{v₁
                                    (max u₁ v₁)
                                    (max u₁ v₁)
                                    (max u₁ v₁)
                                    u₁
                                    (max v₁ u₁ (v₁+1))
                                    (max v₁ u₁ (v₁+1))
                                    (max v₁ u₁ (v₁+1))}
                                    (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (opposite.{(max v₁ u₁ (v₁+1))+1}
                                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁}))
                                    (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁})
                                       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁}))
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                       𝒞
                                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁})
                                       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁})
                                       (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                    (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁})
                                       (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                          (Type v₁)
                                          category_theory.types.{v₁})))
                                 F)))
                        (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.obj.{(max u₁ v₁)
                              (max u₁ v₁)
                              (max u₁ v₁ u₁ (v₁+1))
                              (max v₁ u₁ (v₁+1))}
                              (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                              (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                 (opposite.{(max v₁ u₁ (v₁+1))+1}
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁}))
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.prod.{(max u₁ v₁)
                                 (max u₁ v₁)
                                 (max v₁ u₁ (v₁+1))
                                 (max v₁ u₁ (v₁+1))}
                                 (opposite.{(max v₁ u₁ (v₁+1))+1}
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁}))
                                 (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁}))
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.functor.prod.{v₁
                                 (max u₁ v₁)
                                 (max u₁ v₁)
                                 (max u₁ v₁)
                                 u₁
                                 (max v₁ u₁ (v₁+1))
                                 (max v₁ u₁ (v₁+1))
                                 (max v₁ u₁ (v₁+1))}
                                 (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (opposite.{(max v₁ u₁ (v₁+1))+1}
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁}))
                                 (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁}))
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                    𝒞
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                 (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})))
                              F))
                        x
                        (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           F)
                        (@category_theory.category_struct.id.{v₁ u₁} C
                           (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                           (@opposite.unop.{u₁+1} C
                              (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 F)))))
                (λ
                 (X Y :
                   prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                 (f :
                   @category_theory.has_hom.hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
                        (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))}
                           (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)))
                     X
                     Y),
                   @funext.{(max u₁ v₁)+1 (max u₁ v₁)+1}
                     (@category_theory.functor.obj.{(max u₁ v₁)
                        (max u₁ v₁)
                        (max u₁ v₁ u₁ (v₁+1))
                        (max u₁ v₁)+1}
                        (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                        (Type (max u₁ v₁))
                        category_theory.types.{(max u₁ v₁)}
                        (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                        X)
                     (λ
                      (x :
                        @category_theory.functor.obj.{(max u₁ v₁)
                          (max u₁ v₁)
                          (max u₁ v₁ u₁ (v₁+1))
                          (max u₁ v₁)+1}
                          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                          (Type (max u₁ v₁))
                          category_theory.types.{(max u₁ v₁)}
                          (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                          X),
                        @category_theory.functor.obj.{(max u₁ v₁)
                          (max u₁ v₁)
                          (max u₁ v₁ u₁ (v₁+1))
                          (max u₁ v₁)+1}
                          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                          (Type (max u₁ v₁))
                          category_theory.types.{(max u₁ v₁)}
                          (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
                          Y)
                     (@category_theory.category_struct.comp.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
                        (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁)+1}
                           (Type (max u₁ v₁))
                           category_theory.types.{(max u₁ v₁)})
                        (@category_theory.functor.obj.{(max u₁ v₁)
                           (max u₁ v₁)
                           (max u₁ v₁ u₁ (v₁+1))
                           (max u₁ v₁)+1}
                           (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                           (Type (max u₁ v₁))
                           category_theory.types.{(max u₁ v₁)}
                           (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                           X)
                        (@category_theory.functor.obj.{(max u₁ v₁)
                           (max u₁ v₁)
                           (max u₁ v₁ u₁ (v₁+1))
                           (max u₁ v₁)+1}
                           (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                           (Type (max u₁ v₁))
                           category_theory.types.{(max u₁ v₁)}
                           (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                           Y)
                        (@category_theory.functor.obj.{(max u₁ v₁)
                           (max u₁ v₁)
                           (max u₁ v₁ u₁ (v₁+1))
                           (max u₁ v₁)+1}
                           (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                           (Type (max u₁ v₁))
                           category_theory.types.{(max u₁ v₁)}
                           (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
                           Y)
                        (@category_theory.functor.map.{(max u₁ v₁)
                           (max u₁ v₁)
                           (max u₁ v₁ u₁ (v₁+1))
                           (max u₁ v₁)+1}
                           (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                           (Type (max u₁ v₁))
                           category_theory.types.{(max u₁ v₁)}
                           (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                           X
                           Y
                           f)
                        (λ
                         (x :
                           @category_theory.functor.obj.{(max u₁ v₁)
                             (max u₁ v₁)
                             (max u₁ v₁ u₁ (v₁+1))
                             (max u₁ v₁)+1}
                             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                             (Type (max u₁ v₁))
                             category_theory.types.{(max u₁ v₁)}
                             (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                             Y),
                           @ulift.up.{u₁ v₁}
                             (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
                                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}
                                (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                Y)
                             (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}
                                (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.obj.{(max u₁ v₁)
                                         (max u₁ v₁)
                                         (max u₁ v₁ u₁ (v₁+1))
                                         (max v₁ u₁ (v₁+1))}
                                         (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁}))
                                         (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                         (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                            (opposite.{(max v₁ u₁ (v₁+1))+1}
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁}))
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁}))
                                         (@category_theory.prod.{(max u₁ v₁)
                                            (max u₁ v₁)
                                            (max v₁ u₁ (v₁+1))
                                            (max v₁ u₁ (v₁+1))}
                                            (opposite.{(max v₁ u₁ (v₁+1))+1}
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁}))
                                            (@category_theory.category.opposite.{(max u₁ v₁)
                                               (max v₁ u₁ (v₁+1))}
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁})
                                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                                  (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁}))
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                               (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁}))
                                         (@category_theory.functor.prod.{v₁
                                            (max u₁ v₁)
                                            (max u₁ v₁)
                                            (max u₁ v₁)
                                            u₁
                                            (max v₁ u₁ (v₁+1))
                                            (max v₁ u₁ (v₁+1))
                                            (max v₁ u₁ (v₁+1))}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (opposite.{(max v₁ u₁ (v₁+1))+1}
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁}))
                                            (@category_theory.category.opposite.{(max u₁ v₁)
                                               (max v₁ u₁ (v₁+1))}
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁})
                                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                                  (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁}))
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                               (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                               (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.op.{v₁
                                               (max u₁ v₁)
                                               u₁
                                               (max v₁ u₁ (v₁+1))}
                                               C
                                               𝒞
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁})
                                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                                  (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁})
                                               (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                            (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁})
                                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                                  (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁})))
                                         Y)))
                                (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.obj.{(max u₁ v₁)
                                      (max u₁ v₁)
                                      (max u₁ v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))}
                                      (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                      (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                         (opposite.{(max v₁ u₁ (v₁+1))+1}
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁}))
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.prod.{(max u₁ v₁)
                                         (max u₁ v₁)
                                         (max v₁ u₁ (v₁+1))
                                         (max v₁ u₁ (v₁+1))}
                                         (opposite.{(max v₁ u₁ (v₁+1))+1}
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁}))
                                         (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                               (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁}))
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.prod.{v₁
                                         (max u₁ v₁)
                                         (max u₁ v₁)
                                         (max u₁ v₁)
                                         u₁
                                         (max v₁ u₁ (v₁+1))
                                         (max v₁ u₁ (v₁+1))
                                         (max v₁ u₁ (v₁+1))}
                                         (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (opposite.{(max v₁ u₁ (v₁+1))+1}
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁}))
                                         (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                               (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁}))
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.op.{v₁
                                            (max u₁ v₁)
                                            u₁
                                            (max v₁ u₁ (v₁+1))}
                                            C
                                            𝒞
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                               (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                         (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                               (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})))
                                      Y))
                                x
                                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   Y)
                                (@category_theory.category_struct.id.{v₁ u₁} C
                                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
                                   (@opposite.unop.{u₁+1} C
                                      (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         Y))))))
                     (@category_theory.category_struct.comp.{(max u₁ v₁) (max u₁ v₁)+1} (Type (max u₁ v₁))
                        (@category_theory.category.to_category_struct.{(max u₁ v₁) (max u₁ v₁)+1}
                           (Type (max u₁ v₁))
                           category_theory.types.{(max u₁ v₁)})
                        (@category_theory.functor.obj.{(max u₁ v₁)
                           (max u₁ v₁)
                           (max u₁ v₁ u₁ (v₁+1))
                           (max u₁ v₁)+1}
                           (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                           (Type (max u₁ v₁))
                           category_theory.types.{(max u₁ v₁)}
                           (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                           X)
                        (@category_theory.functor.obj.{(max u₁ v₁)
                           (max u₁ v₁)
                           (max u₁ v₁ u₁ (v₁+1))
                           (max u₁ v₁)+1}
                           (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                           (Type (max u₁ v₁))
                           category_theory.types.{(max u₁ v₁)}
                           (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
                           X)
                        (@category_theory.functor.obj.{(max u₁ v₁)
                           (max u₁ v₁)
                           (max u₁ v₁ u₁ (v₁+1))
                           (max u₁ v₁)+1}
                           (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                           (Type (max u₁ v₁))
                           category_theory.types.{(max u₁ v₁)}
                           (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
                           Y)
                        (λ
                         (x :
                           @category_theory.functor.obj.{(max u₁ v₁)
                             (max u₁ v₁)
                             (max u₁ v₁ u₁ (v₁+1))
                             (max u₁ v₁)+1}
                             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                             (Type (max u₁ v₁))
                             category_theory.types.{(max u₁ v₁)}
                             (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                             X),
                           @ulift.up.{u₁ v₁}
                             (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
                                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}
                                (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                X)
                             (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}
                                (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.obj.{(max u₁ v₁)
                                         (max u₁ v₁)
                                         (max u₁ v₁ u₁ (v₁+1))
                                         (max v₁ u₁ (v₁+1))}
                                         (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁}))
                                         (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                         (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                            (opposite.{(max v₁ u₁ (v₁+1))+1}
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁}))
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁}))
                                         (@category_theory.prod.{(max u₁ v₁)
                                            (max u₁ v₁)
                                            (max v₁ u₁ (v₁+1))
                                            (max v₁ u₁ (v₁+1))}
                                            (opposite.{(max v₁ u₁ (v₁+1))+1}
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁}))
                                            (@category_theory.category.opposite.{(max u₁ v₁)
                                               (max v₁ u₁ (v₁+1))}
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁})
                                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                                  (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁}))
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                               (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁}))
                                         (@category_theory.functor.prod.{v₁
                                            (max u₁ v₁)
                                            (max u₁ v₁)
                                            (max u₁ v₁)
                                            u₁
                                            (max v₁ u₁ (v₁+1))
                                            (max v₁ u₁ (v₁+1))
                                            (max v₁ u₁ (v₁+1))}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (opposite.{(max v₁ u₁ (v₁+1))+1}
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁}))
                                            (@category_theory.category.opposite.{(max u₁ v₁)
                                               (max v₁ u₁ (v₁+1))}
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁})
                                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                                  (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁}))
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                               (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                               (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.op.{v₁
                                               (max u₁ v₁)
                                               u₁
                                               (max v₁ u₁ (v₁+1))}
                                               C
                                               𝒞
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁})
                                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                                  (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁})
                                               (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                            (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁})
                                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                                  (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁})))
                                         X)))
                                (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.obj.{(max u₁ v₁)
                                      (max u₁ v₁)
                                      (max u₁ v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))}
                                      (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                      (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                         (opposite.{(max v₁ u₁ (v₁+1))+1}
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁}))
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.prod.{(max u₁ v₁)
                                         (max u₁ v₁)
                                         (max v₁ u₁ (v₁+1))
                                         (max v₁ u₁ (v₁+1))}
                                         (opposite.{(max v₁ u₁ (v₁+1))+1}
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁}))
                                         (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                               (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁}))
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (… … … … … … … … … …)
                                      X))
                                x
                                …
                                …))
                        …)
                     …))
             …)
          x
          x_1)
       x_2
       x_3)
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
x :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
x_1 :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
    x,
x_2 : opposite.{u₁+1} C,
x_3 :
  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
    (Type v₁)
    category_theory.types.{v₁}
    (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
          (opposite.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max v₁ u₁ (v₁+1))}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod.{(max u₁ v₁) (max u₁ v₁) (max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.prod.{v₁
                (max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁)
                u₁
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             x)))
    x_2
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       x_2)
    (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       x_2
       (@category_theory.has_hom.hom.op.{v₁ u₁} C
          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
          (@opposite.unop.{u₁+1} C x_2)
          (@opposite.unop.{u₁+1} C
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                x))
          x_3)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   x)))
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             x)
          x_1
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             x)
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   x)))))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                x)))
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       x_1
       x_2
       x_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172      erw [←functor_to_types.naturality,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='category_theory.functor_to_types.naturality'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/types.lean&#x27;, &#x27;line&#x27;: 42, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (F G : @category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) {X Y : C} (σ : @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}))) F G) (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y) (x : @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F X), @eq.{v₁+1} (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} G Y) (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F G σ Y (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F X Y f x)) (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} G X Y f (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F G σ X x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
x :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
x_1 :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
    x,
x_2 : opposite.{u₁+1} C,
x_3 :
  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
    (Type v₁)
    category_theory.types.{v₁}
    (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
          (opposite.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max v₁ u₁ (v₁+1))}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod.{(max u₁ v₁) (max u₁ v₁) (max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.prod.{v₁
                (max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁)
                u₁
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             x)))
    x_2
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       x_2)
    (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       x_2
       (@category_theory.has_hom.hom.op.{v₁ u₁} C
          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
          (@opposite.unop.{u₁+1} C x_2)
          (@opposite.unop.{u₁+1} C
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                x))
          x_3)
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   x)))
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             x)
          x_1
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             x)
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   x)))))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                x)))
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       x_1
       x_2
       x_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
x :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
x_1 :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
    x,
x_2 : opposite.{u₁+1} C,
x_3 :
  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
    (Type v₁)
    category_theory.types.{v₁}
    (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
          (opposite.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max v₁ u₁ (v₁+1))}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod.{(max u₁ v₁) (max u₁ v₁) (max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.prod.{v₁
                (max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁)
                u₁
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             x)))
    x_2
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       x_2)
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                x)))
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       x_1
       x_2
       (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   x)))
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             x)
          x_2
          (@category_theory.has_hom.hom.op.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@opposite.unop.{u₁+1} C x_2)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   x))
             x_3)
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   x)))))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                x)))
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       x_1
       x_2
       x_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173           obj_map_id,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='category_theory.yoneda.obj_map_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 46, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {X Y : C} (f : @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C) (@category_theory.has_hom.opposite.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))) (@opposite.op.{u₁+1} C X) (@opposite.op.{u₁+1} C Y)), @eq.{v₁+1} (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁} (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.yoneda.{v₁ u₁} C 𝒞) X) (@opposite.op.{u₁+1} C Y)) (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁} (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.yoneda.{v₁ u₁} C 𝒞) X) (@opposite.op.{u₁+1} C X) (@opposite.op.{u₁+1} C Y) f (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X)) (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁} (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.yoneda.{v₁ u₁} C 𝒞) (@opposite.unop.{u₁+1} C (@opposite.op.{u₁+1} C Y))) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.yoneda.{v₁ u₁} C 𝒞) (@opposite.unop.{u₁+1} C (@opposite.op.{u₁+1} C X))) (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.yoneda.{v₁ u₁} C 𝒞) (@opposite.unop.{u₁+1} C (@opposite.op.{u₁+1} C Y)) (@opposite.unop.{u₁+1} C (@opposite.op.{u₁+1} C X)) (@category_theory.has_hom.hom.unop.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) (@opposite.op.{u₁+1} C X) (@opposite.op.{u₁+1} C Y) f)) (@opposite.op.{u₁+1} C Y) (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) Y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
x :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
x_1 :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
    x,
x_2 : opposite.{u₁+1} C,
x_3 :
  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
    (Type v₁)
    category_theory.types.{v₁}
    (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
          (opposite.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max v₁ u₁ (v₁+1))}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod.{(max u₁ v₁) (max u₁ v₁) (max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.prod.{v₁
                (max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁)
                u₁
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             x)))
    x_2
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       x_2)
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                x)))
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       x_1
       x_2
       (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   x)))
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             x)
          x_2
          (@category_theory.has_hom.hom.op.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@opposite.unop.{u₁+1} C x_2)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   x))
             x_3)
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   x)))))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                x)))
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       x_1
       x_2
       x_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
x :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
x_1 :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
    x,
x_2 : opposite.{u₁+1} C,
x_3 :
  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
    (Type v₁)
    category_theory.types.{v₁}
    (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
          (opposite.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max v₁ u₁ (v₁+1))}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod.{(max u₁ v₁) (max u₁ v₁) (max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.prod.{v₁
                (max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁)
                u₁
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             x)))
    x_2
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       x_2)
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                x)))
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       x_1
       x_2
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C (@opposite.op.{u₁+1} C (@opposite.unop.{u₁+1} C x_2))))
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C
                (@opposite.op.{u₁+1} C
                   (@opposite.unop.{u₁+1} C
                      (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         x)))))
          (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C (@opposite.op.{u₁+1} C (@opposite.unop.{u₁+1} C x_2)))
             (@opposite.unop.{u₁+1} C
                (@opposite.op.{u₁+1} C
                   (@opposite.unop.{u₁+1} C
                      (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         x))))
             (@category_theory.has_hom.hom.unop.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (@opposite.op.{u₁+1} C
                   (@opposite.unop.{u₁+1} C
                      (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         x)))
                (@opposite.op.{u₁+1} C (@opposite.unop.{u₁+1} C x_2))
                (@category_theory.has_hom.hom.op.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (@opposite.unop.{u₁+1} C x_2)
                   (@opposite.unop.{u₁+1} C
                      (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         x))
                   x_3)))
          (@opposite.op.{u₁+1} C (@opposite.unop.{u₁+1} C x_2))
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C x_2))))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                x)))
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       x_1
       x_2
       x_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174           functor_to_types.naturality,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='category_theory.functor_to_types.naturality'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/types.lean&#x27;, &#x27;line&#x27;: 42, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (F G : @category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) {X Y : C} (σ : @category_theory.has_hom.hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}))) F G) (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y) (x : @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F X), @eq.{v₁+1} (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} G Y) (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F G σ Y (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F X Y f x)) (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} G X Y f (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F G σ X x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
x :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
x_1 :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
    x,
x_2 : opposite.{u₁+1} C,
x_3 :
  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
    (Type v₁)
    category_theory.types.{v₁}
    (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
          (opposite.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max v₁ u₁ (v₁+1))}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod.{(max u₁ v₁) (max u₁ v₁) (max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.prod.{v₁
                (max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁)
                u₁
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             x)))
    x_2
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       x_2)
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                x)))
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       x_1
       x_2
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C (@opposite.op.{u₁+1} C (@opposite.unop.{u₁+1} C x_2))))
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C
                (@opposite.op.{u₁+1} C
                   (@opposite.unop.{u₁+1} C
                      (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         x)))))
          (@category_theory.functor.map.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C (@opposite.op.{u₁+1} C (@opposite.unop.{u₁+1} C x_2)))
             (@opposite.unop.{u₁+1} C
                (@opposite.op.{u₁+1} C
                   (@opposite.unop.{u₁+1} C
                      (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         x))))
             (@category_theory.has_hom.hom.unop.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (@opposite.op.{u₁+1} C
                   (@opposite.unop.{u₁+1} C
                      (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         x)))
                (@opposite.op.{u₁+1} C (@opposite.unop.{u₁+1} C x_2))
                (@category_theory.has_hom.hom.op.{v₁ u₁} C
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                      (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                   (@opposite.unop.{u₁+1} C x_2)
                   (@opposite.unop.{u₁+1} C
                      (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁})
                         x))
                   x_3)))
          (@opposite.op.{u₁+1} C (@opposite.unop.{u₁+1} C x_2))
          (@category_theory.category_struct.id.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C x_2))))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                x)))
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       x_1
       x_2
       x_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
x :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
x_1 :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
    x,
x_2 : opposite.{u₁+1} C,
x_3 :
  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
    (Type v₁)
    category_theory.types.{v₁}
    (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
          (opposite.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max v₁ u₁ (v₁+1))}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod.{(max u₁ v₁) (max u₁ v₁) (max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.prod.{v₁
                (max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁)
                u₁
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             x)))
    x_2
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       x_2)
    (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       x_2
       x_2
       (@category_theory.category_struct.id.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C x_2))
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   x)))
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             x)
          x_1
          x_2
          (@category_theory.has_hom.hom.unop.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@opposite.op.{u₁+1} C
                (@opposite.unop.{u₁+1} C
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      x)))
             (@opposite.op.{u₁+1} C (@opposite.unop.{u₁+1} C x_2))
             (@category_theory.has_hom.hom.op.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (@opposite.unop.{u₁+1} C x_2)
                (@opposite.unop.{u₁+1} C
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      x))
                x_3))))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                x)))
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       x_1
       x_2
       x_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175           functor_to_types.map_id],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='category_theory.functor_to_types.map_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/types.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 403, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (F : @category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) {X : C} (a : @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F X), @eq.{v₁+1} (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F X) (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F X X (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X) a) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.semireducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `erewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='erw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
x :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
x_1 :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
    x,
x_2 : opposite.{u₁+1} C,
x_3 :
  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
    (Type v₁)
    category_theory.types.{v₁}
    (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
          (opposite.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max v₁ u₁ (v₁+1))}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod.{(max u₁ v₁) (max u₁ v₁) (max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.prod.{v₁
                (max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁)
                u₁
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             x)))
    x_2
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       x_2)
    (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       x_2
       x_2
       (@category_theory.category_struct.id.{v₁ u₁} C
          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C x_2))
       (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             (@category_theory.yoneda.{v₁ u₁} C 𝒞)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   x)))
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             x)
          x_1
          x_2
          (@category_theory.has_hom.hom.unop.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@opposite.op.{u₁+1} C
                (@opposite.unop.{u₁+1} C
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      x)))
             (@opposite.op.{u₁+1} C (@opposite.unop.{u₁+1} C x_2))
             (@category_theory.has_hom.hom.op.{v₁ u₁} C
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                   (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                (@opposite.unop.{u₁+1} C x_2)
                (@opposite.unop.{u₁+1} C
                   (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁})
                      x))
                x_3))))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                x)))
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       x_1
       x_2
       x_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
x :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
x_1 :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
    x,
x_2 : opposite.{u₁+1} C,
x_3 :
  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
    (Type v₁)
    category_theory.types.{v₁}
    (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
          (opposite.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max v₁ u₁ (v₁+1))}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod.{(max u₁ v₁) (max u₁ v₁) (max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.prod.{v₁
                (max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁)
                u₁
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             x)))
    x_2
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       x_2)
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                x)))
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       x_1
       x_2
       (@category_theory.has_hom.hom.unop.{v₁ u₁} C
          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
          (@opposite.op.{u₁+1} C
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   x)))
          (@opposite.op.{u₁+1} C (@opposite.unop.{u₁+1} C x_2))
          (@category_theory.has_hom.hom.op.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@opposite.unop.{u₁+1} C x_2)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   x))
             x_3)))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                x)))
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       x_1
       x_2
       x_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176      refl,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1263, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Shorter name for the tactic `reflexivity`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
x :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
x_1 :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
    x,
x_2 : opposite.{u₁+1} C,
x_3 :
  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
    (Type v₁)
    category_theory.types.{v₁}
    (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
          (opposite.{(max v₁ u₁ (v₁+1))+1}
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.obj.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max v₁ u₁ (v₁+1))}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod.{(max u₁ v₁) (max u₁ v₁) (max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.functor.prod.{v₁
                (max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁)
                u₁
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))
                (max v₁ u₁ (v₁+1))}
                (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (opposite.{(max v₁ u₁ (v₁+1))+1}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})))
             x)))
    x_2
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       x_2)
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                x)))
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       x_1
       x_2
       (@category_theory.has_hom.hom.unop.{v₁ u₁} C
          (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
             (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
          (@opposite.op.{u₁+1} C
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   x)))
          (@opposite.op.{u₁+1} C (@opposite.unop.{u₁+1} C x_2))
          (@category_theory.has_hom.hom.op.{v₁ u₁} C
             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
             (@opposite.unop.{u₁+1} C x_2)
             (@opposite.unop.{u₁+1} C
                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁})
                   x))
             x_3)))
    (@category_theory.nat_trans.app.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          (@category_theory.yoneda.{v₁ u₁} C 𝒞)
          (@opposite.unop.{u₁+1} C
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                x)))
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       x_1
       x_2
       x_3)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177    end,</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178    inv_hom_id&#x27; :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C
⊢ @eq.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)+1}
    (@category_theory.has_hom.hom.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)
       (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))}
       (@category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)})
       (@category_theory.category_struct.to_has_hom.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)
          (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))}
          (@category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (Type (max u₁ v₁))
             category_theory.types.{(max u₁ v₁)})
          (@category_theory.category.to_category_struct.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)
             (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))}
             (@category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                (Type (max u₁ v₁))
                category_theory.types.{(max u₁ v₁)})
             (@category_theory.functor.category.{(max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁ u₁ (v₁+1))
                (max u₁ v₁)+1}
                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                (Type (max u₁ v₁))
                category_theory.types.{(max u₁ v₁)})))
       (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
       (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞))
    (@category_theory.category_struct.comp.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)
       (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))}
       (@category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)})
       (@category_theory.category.to_category_struct.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)
          (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))}
          (@category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (Type (max u₁ v₁))
             category_theory.types.{(max u₁ v₁)})
          (@category_theory.functor.category.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max u₁ v₁)+1}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (Type (max u₁ v₁))
             category_theory.types.{(max u₁ v₁)}))
       (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
       (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
       (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
       (@category_theory.nat_trans.mk.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)}
          (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
          (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
          (λ
           (F :
             prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
           (x :
             @category_theory.functor.obj.{(max u₁ v₁)
               (max u₁ v₁)
               (max u₁ v₁ u₁ (v₁+1))
               (max u₁ v₁)+1}
               (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁}))
               (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
               (Type (max u₁ v₁))
               category_theory.types.{(max u₁ v₁)}
               (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
               F),
             @category_theory.nat_trans.mk.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
               (Type v₁)
               category_theory.types.{v₁}
               (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.obj.{(max u₁ v₁)
                        (max u₁ v₁)
                        (max u₁ v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                        (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.prod.{(max u₁ v₁)
                           (max u₁ v₁)
                           (max v₁ u₁ (v₁+1))
                           (max v₁ u₁ (v₁+1))}
                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.prod.{v₁
                           (max u₁ v₁)
                           (max u₁ v₁)
                           (max u₁ v₁)
                           u₁
                           (max v₁ u₁ (v₁+1))
                           (max v₁ u₁ (v₁+1))
                           (max v₁ u₁ (v₁+1))}
                           (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                           (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})))
                        F)))
               (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@category_theory.functor.obj.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod.{(max u₁ v₁)
                        (max u₁ v₁)
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.prod.{v₁
                        (max u₁ v₁)
                        (max u₁ v₁)
                        (max u₁ v₁)
                        u₁
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                        (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})))
                     F))
               (λ (X : opposite.{u₁+1} C)
                (a :
                  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                    (Type v₁)
                    category_theory.types.{v₁}
                    (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁})
                       (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.obj.{(max u₁ v₁)
                             (max u₁ v₁)
                             (max u₁ v₁ u₁ (v₁+1))
                             (max v₁ u₁ (v₁+1))}
                             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                             (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                (opposite.{(max v₁ u₁ (v₁+1))+1}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.prod.{(max u₁ v₁)
                                (max u₁ v₁)
                                (max v₁ u₁ (v₁+1))
                                (max v₁ u₁ (v₁+1))}
                                (opposite.{(max v₁ u₁ (v₁+1))+1}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.functor.prod.{v₁
                                (max u₁ v₁)
                                (max u₁ v₁)
                                (max u₁ v₁)
                                u₁
                                (max v₁ u₁ (v₁+1))
                                (max v₁ u₁ (v₁+1))
                                (max v₁ u₁ (v₁+1))}
                                (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (opposite.{(max v₁ u₁ (v₁+1))+1}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})))
                             F)))
                    X),
                  @category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                    (Type v₁)
                    category_theory.types.{v₁}
                    (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁})
                       F)
                    (@opposite.op.{u₁+1} C
                       (@opposite.unop.{u₁+1} C
                          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             F)))
                    X
                    (@category_theory.has_hom.hom.op.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       (@opposite.unop.{u₁+1} C X)
                       (@opposite.unop.{u₁+1} C
                          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             F))
                       a)
                    (@ulift.down.{u₁ v₁}
                       (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
                          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          F)
                       x))
               (λ (X Y : opposite.{u₁+1} C)
                (f :
                  @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                       (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                    X
                    Y),
                  @funext.{v₁+1 v₁+1}
                    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁}
                       (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                             (opposite.{(max v₁ u₁ (v₁+1))+1}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.obj.{(max u₁ v₁)
                                (max u₁ v₁)
                                (max u₁ v₁ u₁ (v₁+1))
                                (max v₁ u₁ (v₁+1))}
                                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.prod.{(max u₁ v₁)
                                   (max u₁ v₁)
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.prod.{v₁
                                   (max u₁ v₁)
                                   (max u₁ v₁)
                                   (max u₁ v₁)
                                   u₁
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                      𝒞
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                   (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})))
                                F)))
                       X)
                    (λ
                     (x :
                       @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}
                         (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                               (opposite.{(max v₁ u₁ (v₁+1))+1}
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.functor.obj.{(max u₁ v₁)
                                  (max u₁ v₁)
                                  (max u₁ v₁ u₁ (v₁+1))
                                  (max v₁ u₁ (v₁+1))}
                                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                  (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.prod.{(max u₁ v₁)
                                     (max u₁ v₁)
                                     (max v₁ u₁ (v₁+1))
                                     (max v₁ u₁ (v₁+1))}
                                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.prod.{v₁
                                     (max u₁ v₁)
                                     (max u₁ v₁)
                                     (max u₁ v₁)
                                     u₁
                                     (max v₁ u₁ (v₁+1))
                                     (max v₁ u₁ (v₁+1))
                                     (max v₁ u₁ (v₁+1))}
                                     (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                        𝒞
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                     (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})))
                                  F)))
                         X),
                       @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}
                         (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                            (opposite.{(max v₁ u₁ (v₁+1))+1}
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁}))
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            (@category_theory.functor.obj.{(max u₁ v₁)
                               (max u₁ v₁)
                               (max u₁ v₁ u₁ (v₁+1))
                               (max v₁ u₁ (v₁+1))}
                               (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                               (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.prod.{(max u₁ v₁)
                                  (max u₁ v₁)
                                  (max v₁ u₁ (v₁+1))
                                  (max v₁ u₁ (v₁+1))}
                                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.functor.prod.{v₁
                                  (max u₁ v₁)
                                  (max u₁ v₁)
                                  (max u₁ v₁)
                                  u₁
                                  (max v₁ u₁ (v₁+1))
                                  (max v₁ u₁ (v₁+1))
                                  (max v₁ u₁ (v₁+1))}
                                  (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                     𝒞
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                  (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})))
                               F))
                         Y)
                    (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                       (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                          category_theory.types.{v₁})
                       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                (opposite.{(max v₁ u₁ (v₁+1))+1}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.obj.{(max u₁ v₁)
                                   (max u₁ v₁)
                                   (max u₁ v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                   (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.prod.{(max u₁ v₁)
                                      (max u₁ v₁)
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))}
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.prod.{v₁
                                      (max u₁ v₁)
                                      (max u₁ v₁)
                                      (max u₁ v₁)
                                      u₁
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))}
                                      (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))}
                                         C
                                         𝒞
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                      (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})))
                                   F)))
                          X)
                       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                (opposite.{(max v₁ u₁ (v₁+1))+1}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.obj.{(max u₁ v₁)
                                   (max u₁ v₁)
                                   (max u₁ v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                   (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.prod.{(max u₁ v₁)
                                      (max u₁ v₁)
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))}
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.prod.{v₁
                                      (max u₁ v₁)
                                      (max u₁ v₁)
                                      (max u₁ v₁)
                                      u₁
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))}
                                      (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))}
                                         C
                                         𝒞
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                      (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})))
                                   F)))
                          Y)
                       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                             (opposite.{(max v₁ u₁ (v₁+1))+1}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.obj.{(max u₁ v₁)
                                (max u₁ v₁)
                                (max u₁ v₁ u₁ (v₁+1))
                                (max v₁ u₁ (v₁+1))}
                                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.prod.{(max u₁ v₁)
                                   (max u₁ v₁)
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.prod.{v₁
                                   (max u₁ v₁)
                                   (max u₁ v₁)
                                   (max u₁ v₁)
                                   u₁
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                      𝒞
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                   (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})))
                                F))
                          Y)
                       (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                (opposite.{(max v₁ u₁ (v₁+1))+1}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.obj.{(max u₁ v₁)
                                   (max u₁ v₁)
                                   (max u₁ v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                   (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.prod.{(max u₁ v₁)
                                      (max u₁ v₁)
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))}
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.prod.{v₁
                                      (max u₁ v₁)
                                      (max u₁ v₁)
                                      (max u₁ v₁)
                                      u₁
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))}
                                      (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))}
                                         C
                                         𝒞
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                      (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})))
                                   F)))
                          X
                          Y
                          f)
                       (λ
                        (a :
                          @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}
                            (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.obj.{(max u₁ v₁)
                                     (max u₁ v₁)
                                     (max u₁ v₁ u₁ (v₁+1))
                                     (max v₁ u₁ (v₁+1))}
                                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                     (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁}))
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) …
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     …
                                     …
                                     F)))
                            Y), …))
                    …
                    …))
          …)
       …)
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180      ext, dsimp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1239, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.dsimp_config {md := tactic.transparency.reducible, max_steps := simp.default_max_steps, canonize_instances := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, eta := bool.tt, zeta := bool.tt, beta := bool.tt, proj := bool.tt, iota := bool.tt, unfold_reducible := bool.ff, memoize := bool.tt} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`dsimp` is similar to `simp`, except that it only uses definitional equalities.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='dsimp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.dsimp_config?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C
⊢ @eq.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)+1}
    (@category_theory.has_hom.hom.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)
       (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))}
       (@category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)})
       (@category_theory.category_struct.to_has_hom.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)
          (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))}
          (@category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (Type (max u₁ v₁))
             category_theory.types.{(max u₁ v₁)})
          (@category_theory.category.to_category_struct.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)
             (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))}
             (@category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                (Type (max u₁ v₁))
                category_theory.types.{(max u₁ v₁)})
             (@category_theory.functor.category.{(max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁ u₁ (v₁+1))
                (max u₁ v₁)+1}
                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                (Type (max u₁ v₁))
                category_theory.types.{(max u₁ v₁)})))
       (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
       (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞))
    (@category_theory.category_struct.comp.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)
       (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))}
       (@category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)})
       (@category_theory.category.to_category_struct.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)
          (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))}
          (@category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (Type (max u₁ v₁))
             category_theory.types.{(max u₁ v₁)})
          (@category_theory.functor.category.{(max u₁ v₁)
             (max u₁ v₁)
             (max u₁ v₁ u₁ (v₁+1))
             (max u₁ v₁)+1}
             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁}))
             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
             (Type (max u₁ v₁))
             category_theory.types.{(max u₁ v₁)}))
       (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
       (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
       (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
       (@category_theory.nat_trans.mk.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)}
          (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
          (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
          (λ
           (F :
             prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                  (Type v₁)
                  category_theory.types.{v₁}))
           (x :
             @category_theory.functor.obj.{(max u₁ v₁)
               (max u₁ v₁)
               (max u₁ v₁ u₁ (v₁+1))
               (max u₁ v₁)+1}
               (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁}))
               (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
               (Type (max u₁ v₁))
               category_theory.types.{(max u₁ v₁)}
               (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
               F),
             @category_theory.nat_trans.mk.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
               (Type v₁)
               category_theory.types.{v₁}
               (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁})
                     (@category_theory.functor.obj.{(max u₁ v₁)
                        (max u₁ v₁)
                        (max u₁ v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                        (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.prod.{(max u₁ v₁)
                           (max u₁ v₁)
                           (max v₁ u₁ (v₁+1))
                           (max v₁ u₁ (v₁+1))}
                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.prod.{v₁
                           (max u₁ v₁)
                           (max u₁ v₁)
                           (max u₁ v₁)
                           u₁
                           (max v₁ u₁ (v₁+1))
                           (max v₁ u₁ (v₁+1))
                           (max v₁ u₁ (v₁+1))}
                           (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                           (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})))
                        F)))
               (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁})
                  (@category_theory.functor.obj.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max v₁ u₁ (v₁+1))}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod.{(max u₁ v₁)
                        (max u₁ v₁)
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.functor.prod.{v₁
                        (max u₁ v₁)
                        (max u₁ v₁)
                        (max u₁ v₁)
                        u₁
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))
                        (max v₁ u₁ (v₁+1))}
                        (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                        (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})))
                     F))
               (λ (X : opposite.{u₁+1} C)
                (a :
                  @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                    (Type v₁)
                    category_theory.types.{v₁}
                    (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁})
                       (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                          (opposite.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@category_theory.functor.obj.{(max u₁ v₁)
                             (max u₁ v₁)
                             (max u₁ v₁ u₁ (v₁+1))
                             (max v₁ u₁ (v₁+1))}
                             (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                             (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                (opposite.{(max v₁ u₁ (v₁+1))+1}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.prod.{(max u₁ v₁)
                                (max u₁ v₁)
                                (max v₁ u₁ (v₁+1))
                                (max v₁ u₁ (v₁+1))}
                                (opposite.{(max v₁ u₁ (v₁+1))+1}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.functor.prod.{v₁
                                (max u₁ v₁)
                                (max u₁ v₁)
                                (max u₁ v₁)
                                u₁
                                (max v₁ u₁ (v₁+1))
                                (max v₁ u₁ (v₁+1))
                                (max v₁ u₁ (v₁+1))}
                                (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (opposite.{(max v₁ u₁ (v₁+1))+1}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})))
                             F)))
                    X),
                  @category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                    (Type v₁)
                    category_theory.types.{v₁}
                    (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁})
                       F)
                    (@opposite.op.{u₁+1} C
                       (@opposite.unop.{u₁+1} C
                          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             F)))
                    X
                    (@category_theory.has_hom.hom.op.{v₁ u₁} C
                       (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                          (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                       (@opposite.unop.{u₁+1} C X)
                       (@opposite.unop.{u₁+1} C
                          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             F))
                       a)
                    (@ulift.down.{u₁ v₁}
                       (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
                          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}))
                          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          F)
                       x))
               (λ (X Y : opposite.{u₁+1} C)
                (f :
                  @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                    (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                       (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                    X
                    Y),
                  @funext.{v₁+1 v₁+1}
                    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                       (Type v₁)
                       category_theory.types.{v₁}
                       (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁})
                          (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                             (opposite.{(max v₁ u₁ (v₁+1))+1}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.obj.{(max u₁ v₁)
                                (max u₁ v₁)
                                (max u₁ v₁ u₁ (v₁+1))
                                (max v₁ u₁ (v₁+1))}
                                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.prod.{(max u₁ v₁)
                                   (max u₁ v₁)
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.prod.{v₁
                                   (max u₁ v₁)
                                   (max u₁ v₁)
                                   (max u₁ v₁)
                                   u₁
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                      𝒞
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                   (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})))
                                F)))
                       X)
                    (λ
                     (x :
                       @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}
                         (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                               (opposite.{(max v₁ u₁ (v₁+1))+1}
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@category_theory.functor.obj.{(max u₁ v₁)
                                  (max u₁ v₁)
                                  (max u₁ v₁ u₁ (v₁+1))
                                  (max v₁ u₁ (v₁+1))}
                                  (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                  (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.prod.{(max u₁ v₁)
                                     (max u₁ v₁)
                                     (max v₁ u₁ (v₁+1))
                                     (max v₁ u₁ (v₁+1))}
                                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.prod.{v₁
                                     (max u₁ v₁)
                                     (max u₁ v₁)
                                     (max u₁ v₁)
                                     u₁
                                     (max v₁ u₁ (v₁+1))
                                     (max v₁ u₁ (v₁+1))
                                     (max v₁ u₁ (v₁+1))}
                                     (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                        𝒞
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                     (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})))
                                  F)))
                         X),
                       @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}
                         (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                            (opposite.{(max v₁ u₁ (v₁+1))+1}
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁}))
                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁})
                            (@category_theory.functor.obj.{(max u₁ v₁)
                               (max u₁ v₁)
                               (max u₁ v₁ u₁ (v₁+1))
                               (max v₁ u₁ (v₁+1))}
                               (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                               (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.prod.{(max u₁ v₁)
                                  (max u₁ v₁)
                                  (max v₁ u₁ (v₁+1))
                                  (max v₁ u₁ (v₁+1))}
                                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁}))
                               (@category_theory.functor.prod.{v₁
                                  (max u₁ v₁)
                                  (max u₁ v₁)
                                  (max u₁ v₁)
                                  u₁
                                  (max v₁ u₁ (v₁+1))
                                  (max v₁ u₁ (v₁+1))
                                  (max v₁ u₁ (v₁+1))}
                                  (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                     𝒞
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                  (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})))
                               F))
                         Y)
                    (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                       (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                          category_theory.types.{v₁})
                       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                (opposite.{(max v₁ u₁ (v₁+1))+1}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.obj.{(max u₁ v₁)
                                   (max u₁ v₁)
                                   (max u₁ v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                   (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.prod.{(max u₁ v₁)
                                      (max u₁ v₁)
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))}
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.prod.{v₁
                                      (max u₁ v₁)
                                      (max u₁ v₁)
                                      (max u₁ v₁)
                                      u₁
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))}
                                      (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))}
                                         C
                                         𝒞
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                      (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})))
                                   F)))
                          X)
                       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                (opposite.{(max v₁ u₁ (v₁+1))+1}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.obj.{(max u₁ v₁)
                                   (max u₁ v₁)
                                   (max u₁ v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                   (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.prod.{(max u₁ v₁)
                                      (max u₁ v₁)
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))}
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.prod.{v₁
                                      (max u₁ v₁)
                                      (max u₁ v₁)
                                      (max u₁ v₁)
                                      u₁
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))}
                                      (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))}
                                         C
                                         𝒞
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                      (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})))
                                   F)))
                          Y)
                       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                             (opposite.{(max v₁ u₁ (v₁+1))+1}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁}))
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.obj.{(max u₁ v₁)
                                (max u₁ v₁)
                                (max u₁ v₁ u₁ (v₁+1))
                                (max v₁ u₁ (v₁+1))}
                                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.prod.{(max u₁ v₁)
                                   (max u₁ v₁)
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.prod.{v₁
                                   (max u₁ v₁)
                                   (max u₁ v₁)
                                   (max u₁ v₁)
                                   u₁
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                      𝒞
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                   (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})))
                                F))
                          Y)
                       (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                (opposite.{(max v₁ u₁ (v₁+1))+1}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.obj.{(max u₁ v₁)
                                   (max u₁ v₁)
                                   (max u₁ v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                   (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.prod.{(max u₁ v₁)
                                      (max u₁ v₁)
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))}
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.prod.{v₁
                                      (max u₁ v₁)
                                      (max u₁ v₁)
                                      (max u₁ v₁)
                                      u₁
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))}
                                      (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))}
                                         C
                                         𝒞
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                      (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})))
                                   F)))
                          X
                          Y
                          f)
                       (λ
                        (a :
                          @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                            (Type v₁)
                            category_theory.types.{v₁}
                            (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁})
                               (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.obj.{(max u₁ v₁)
                                     (max u₁ v₁)
                                     (max u₁ v₁ u₁ (v₁+1))
                                     (max v₁ u₁ (v₁+1))}
                                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                     (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁}))
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) …
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     …
                                     …
                                     F)))
                            Y), …))
                    …
                    …))
          …)
       …)
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
x :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
x_1 :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
    x
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
       (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}))
       (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁})
       x)
    (@ulift.down.{u₁ v₁}
       (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       (@category_theory.nat_trans.app.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
          (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁}))
          (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
          (Type (max u₁ v₁))
          category_theory.types.{(max u₁ v₁)}
          (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
          (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
          (@category_theory.category_struct.comp.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)
             (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))}
             (@category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                (Type (max u₁ v₁))
                category_theory.types.{(max u₁ v₁)})
             (@category_theory.category.to_category_struct.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁)
                (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))}
                (@category_theory.functor.{(max u₁ v₁)
                   (max u₁ v₁)
                   (max u₁ v₁ u₁ (v₁+1))
                   (max u₁ v₁)+1}
                   (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                   (Type (max u₁ v₁))
                   category_theory.types.{(max u₁ v₁)})
                (@category_theory.functor.category.{(max u₁ v₁)
                   (max u₁ v₁)
                   (max u₁ v₁ u₁ (v₁+1))
                   (max u₁ v₁)+1}
                   (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                         (Type v₁)
                         category_theory.types.{v₁}))
                   (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                   (Type (max u₁ v₁))
                   category_theory.types.{(max u₁ v₁)}))
             (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
             (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
             (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
             (@category_theory.nat_trans.mk.{(max u₁ v₁)
                (max u₁ v₁)
                (max u₁ v₁ u₁ (v₁+1))
                (max u₁ v₁)+1}
                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                      (Type v₁)
                      category_theory.types.{v₁}))
                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                (Type (max u₁ v₁))
                category_theory.types.{(max u₁ v₁)}
                (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
                (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞)
                (λ
                 (F :
                   prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                        (Type v₁)
                        category_theory.types.{v₁}))
                 (x :
                   @category_theory.functor.obj.{(max u₁ v₁)
                     (max u₁ v₁)
                     (max u₁ v₁ u₁ (v₁+1))
                     (max u₁ v₁)+1}
                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁}))
                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                     (Type (max u₁ v₁))
                     category_theory.types.{(max u₁ v₁)}
                     (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
                     F),
                   @category_theory.nat_trans.mk.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                     (Type v₁)
                     category_theory.types.{v₁}
                     (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁})
                           (@category_theory.functor.obj.{(max u₁ v₁)
                              (max u₁ v₁)
                              (max u₁ v₁ u₁ (v₁+1))
                              (max v₁ u₁ (v₁+1))}
                              (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                              (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                 (opposite.{(max v₁ u₁ (v₁+1))+1}
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁}))
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.prod.{(max u₁ v₁)
                                 (max u₁ v₁)
                                 (max v₁ u₁ (v₁+1))
                                 (max v₁ u₁ (v₁+1))}
                                 (opposite.{(max v₁ u₁ (v₁+1))+1}
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁}))
                                 (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁}))
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.functor.prod.{v₁
                                 (max u₁ v₁)
                                 (max u₁ v₁)
                                 (max u₁ v₁)
                                 u₁
                                 (max v₁ u₁ (v₁+1))
                                 (max v₁ u₁ (v₁+1))
                                 (max v₁ u₁ (v₁+1))}
                                 (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (opposite.{(max v₁ u₁ (v₁+1))+1}
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁}))
                                 (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁}))
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C
                                    𝒞
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                 (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})
                                    (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                       (Type v₁)
                                       category_theory.types.{v₁})))
                              F)))
                     (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (Type v₁)
                              category_theory.types.{v₁}))
                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                           (Type v₁)
                           category_theory.types.{v₁})
                        (@category_theory.functor.obj.{(max u₁ v₁)
                           (max u₁ v₁)
                           (max u₁ v₁ u₁ (v₁+1))
                           (max v₁ u₁ (v₁+1))}
                           (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                           (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                              (opposite.{(max v₁ u₁ (v₁+1))+1}
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.prod.{(max u₁ v₁)
                              (max u₁ v₁)
                              (max v₁ u₁ (v₁+1))
                              (max v₁ u₁ (v₁+1))}
                              (opposite.{(max v₁ u₁ (v₁+1))+1}
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁}))
                           (@category_theory.functor.prod.{v₁
                              (max u₁ v₁)
                              (max u₁ v₁)
                              (max u₁ v₁)
                              u₁
                              (max v₁ u₁ (v₁+1))
                              (max v₁ u₁ (v₁+1))
                              (max v₁ u₁ (v₁+1))}
                              (opposite.{u₁+1} C)
                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                              (opposite.{(max v₁ u₁ (v₁+1))+1}
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁}))
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                 (Type v₁)
                                 category_theory.types.{v₁})
                              (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                              (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})
                                 (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                    (Type v₁)
                                    category_theory.types.{v₁})))
                           F))
                     (λ (X : opposite.{u₁+1} C)
                      (a :
                        @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                (opposite.{(max v₁ u₁ (v₁+1))+1}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@category_theory.functor.obj.{(max u₁ v₁)
                                   (max u₁ v₁)
                                   (max u₁ v₁ u₁ (v₁+1))
                                   (max v₁ u₁ (v₁+1))}
                                   (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                   (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.prod.{(max u₁ v₁)
                                      (max u₁ v₁)
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))}
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.prod.{v₁
                                      (max u₁ v₁)
                                      (max u₁ v₁)
                                      (max u₁ v₁)
                                      u₁
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))}
                                      (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.op.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))}
                                         C
                                         𝒞
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                      (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})))
                                   F)))
                          X),
                        @category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                          (Type v₁)
                          category_theory.types.{v₁}
                          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁})
                             F)
                          (@opposite.op.{u₁+1} C
                             (@opposite.unop.{u₁+1} C
                                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   F)))
                          X
                          (@category_theory.has_hom.hom.op.{v₁ u₁} C
                             (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
                                (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
                             (@opposite.unop.{u₁+1} C X)
                             (@opposite.unop.{u₁+1} C
                                (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   F))
                             a)
                          (@ulift.down.{u₁ v₁}
                             (@category_theory.functor.obj.{(max u₁ v₁) v₁ (max u₁ v₁ u₁ (v₁+1)) v₁+1}
                                (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁}))
                                (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}
                                (@category_theory.evaluation_uncurried.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                F)
                             x))
                     (λ (X Y : opposite.{u₁+1} C)
                      (f :
                        @category_theory.has_hom.hom.{v₁ u₁} (opposite.{u₁+1} C)
                          (@category_theory.category_struct.to_has_hom.{v₁ u₁} (opposite.{u₁+1} C)
                             (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)))
                          X
                          Y),
                        @funext.{v₁+1 v₁+1}
                          (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                             (Type v₁)
                             category_theory.types.{v₁}
                             (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                   (Type v₁)
                                   category_theory.types.{v₁})
                                (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.obj.{(max u₁ v₁)
                                      (max u₁ v₁)
                                      (max u₁ v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))}
                                      (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                      (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                         (opposite.{(max v₁ u₁ (v₁+1))+1}
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁}))
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.prod.{(max u₁ v₁)
                                         (max u₁ v₁)
                                         (max v₁ u₁ (v₁+1))
                                         (max v₁ u₁ (v₁+1))}
                                         (opposite.{(max v₁ u₁ (v₁+1))+1}
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁}))
                                         (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                               (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁}))
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.prod.{v₁
                                         (max u₁ v₁)
                                         (max u₁ v₁)
                                         (max u₁ v₁)
                                         u₁
                                         (max v₁ u₁ (v₁+1))
                                         (max v₁ u₁ (v₁+1))
                                         (max v₁ u₁ (v₁+1))}
                                         (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (opposite.{(max v₁ u₁ (v₁+1))+1}
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁}))
                                         (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                               (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁}))
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.op.{v₁
                                            (max u₁ v₁)
                                            u₁
                                            (max v₁ u₁ (v₁+1))}
                                            C
                                            𝒞
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                               (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                         (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                               (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})))
                                      F)))
                             X)
                          (λ
                           (x :
                             @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁}
                               (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                     (opposite.{(max v₁ u₁ (v₁+1))+1}
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@category_theory.functor.obj.{(max u₁ v₁)
                                        (max u₁ v₁)
                                        (max u₁ v₁ u₁ (v₁+1))
                                        (max v₁ u₁ (v₁+1))}
                                        (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁}))
                                        (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                        (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                 (Type v₁)
                                                 category_theory.types.{v₁}))
                                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁}))
                                        (@category_theory.prod.{(max u₁ v₁)
                                           (max u₁ v₁)
                                           (max v₁ u₁ (v₁+1))
                                           (max v₁ u₁ (v₁+1))}
                                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                 (Type v₁)
                                                 category_theory.types.{v₁}))
                                           (@category_theory.category.opposite.{(max u₁ v₁)
                                              (max v₁ u₁ (v₁+1))}
                                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                 (Type v₁)
                                                 category_theory.types.{v₁})
                                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                                 (opposite.{u₁+1} C)
                                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                 (Type v₁)
                                                 category_theory.types.{v₁}))
                                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁})
                                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                              (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁}))
                                        (@category_theory.functor.prod.{v₁
                                           (max u₁ v₁)
                                           (max u₁ v₁)
                                           (max u₁ v₁)
                                           u₁
                                           (max v₁ u₁ (v₁+1))
                                           (max v₁ u₁ (v₁+1))
                                           (max v₁ u₁ (v₁+1))}
                                           (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (opposite.{(max v₁ u₁ (v₁+1))+1}
                                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                 (Type v₁)
                                                 category_theory.types.{v₁}))
                                           (@category_theory.category.opposite.{(max u₁ v₁)
                                              (max v₁ u₁ (v₁+1))}
                                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                 (Type v₁)
                                                 category_theory.types.{v₁})
                                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                                 (opposite.{u₁+1} C)
                                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                 (Type v₁)
                                                 category_theory.types.{v₁}))
                                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁})
                                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                              (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁})
                                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁})
                                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                              (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁})
                                           (@category_theory.functor.op.{v₁
                                              (max u₁ v₁)
                                              u₁
                                              (max v₁ u₁ (v₁+1))}
                                              C
                                              𝒞
                                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                 (Type v₁)
                                                 category_theory.types.{v₁})
                                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                                 (opposite.{u₁+1} C)
                                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                 (Type v₁)
                                                 category_theory.types.{v₁})
                                              (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                           (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                 (Type v₁)
                                                 category_theory.types.{v₁})
                                              (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                                 (opposite.{u₁+1} C)
                                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                 (Type v₁)
                                                 category_theory.types.{v₁})))
                                        F)))
                               X),
                             @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                               (Type v₁)
                               category_theory.types.{v₁}
                               (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                  (opposite.{(max v₁ u₁ (v₁+1))+1}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁}))
                                  (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                     (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                     (Type v₁)
                                     category_theory.types.{v₁})
                                  (@category_theory.functor.obj.{(max u₁ v₁)
                                     (max u₁ v₁)
                                     (max u₁ v₁ u₁ (v₁+1))
                                     (max v₁ u₁ (v₁+1))}
                                     (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                     (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁}))
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.prod.{(max u₁ v₁)
                                        (max u₁ v₁)
                                        (max v₁ u₁ (v₁+1))
                                        (max v₁ u₁ (v₁+1))}
                                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁}))
                                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁})
                                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                              (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁}))
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁}))
                                     (@category_theory.functor.prod.{v₁
                                        (max u₁ v₁)
                                        (max u₁ v₁)
                                        (max u₁ v₁)
                                        u₁
                                        (max v₁ u₁ (v₁+1))
                                        (max v₁ u₁ (v₁+1))
                                        (max v₁ u₁ (v₁+1))}
                                        (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁}))
                                        (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁})
                                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                              (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁}))
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.op.{v₁
                                           (max u₁ v₁)
                                           u₁
                                           (max v₁ u₁ (v₁+1))}
                                           C
                                           𝒞
                                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁})
                                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                              (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁})
                                           (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                        (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁})
                                           (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                              (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁})))
                                     F))
                               Y)
                          (@category_theory.category_struct.comp.{v₁ v₁+1} (Type v₁)
                             (@category_theory.category.to_category_struct.{v₁ v₁+1} (Type v₁)
                                category_theory.types.{v₁})
                             (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}
                                (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.obj.{(max u₁ v₁)
                                         (max u₁ v₁)
                                         (max u₁ v₁ u₁ (v₁+1))
                                         (max v₁ u₁ (v₁+1))}
                                         (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁}))
                                         (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                         (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                            (opposite.{(max v₁ u₁ (v₁+1))+1}
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁}))
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁}))
                                         (@category_theory.prod.{(max u₁ v₁)
                                            (max u₁ v₁)
                                            (max v₁ u₁ (v₁+1))
                                            (max v₁ u₁ (v₁+1))}
                                            (opposite.{(max v₁ u₁ (v₁+1))+1}
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁}))
                                            (@category_theory.category.opposite.{(max u₁ v₁)
                                               (max v₁ u₁ (v₁+1))}
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁})
                                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                                  (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁}))
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                               (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁}))
                                         (@category_theory.functor.prod.{v₁
                                            (max u₁ v₁)
                                            (max u₁ v₁)
                                            (max u₁ v₁)
                                            u₁
                                            (max v₁ u₁ (v₁+1))
                                            (max v₁ u₁ (v₁+1))
                                            (max v₁ u₁ (v₁+1))}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (opposite.{(max v₁ u₁ (v₁+1))+1}
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁}))
                                            (@category_theory.category.opposite.{(max u₁ v₁)
                                               (max v₁ u₁ (v₁+1))}
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁})
                                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                                  (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁}))
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                               (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                               (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.op.{v₁
                                               (max u₁ v₁)
                                               u₁
                                               (max v₁ u₁ (v₁+1))}
                                               C
                                               𝒞
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁})
                                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                                  (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁})
                                               (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                            (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁})
                                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                                  (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁})))
                                         F)))
                                X)
                             (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}
                                (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.obj.{(max u₁ v₁)
                                         (max u₁ v₁)
                                         (max u₁ v₁ u₁ (v₁+1))
                                         (max v₁ u₁ (v₁+1))}
                                         (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁}))
                                         (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                         (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                            (opposite.{(max v₁ u₁ (v₁+1))+1}
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁}))
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁}))
                                         (@category_theory.prod.{(max u₁ v₁)
                                            (max u₁ v₁)
                                            (max v₁ u₁ (v₁+1))
                                            (max v₁ u₁ (v₁+1))}
                                            (opposite.{(max v₁ u₁ (v₁+1))+1}
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁}))
                                            (@category_theory.category.opposite.{(max u₁ v₁)
                                               (max v₁ u₁ (v₁+1))}
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁})
                                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                                  (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁}))
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                               (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁}))
                                         (@category_theory.functor.prod.{v₁
                                            (max u₁ v₁)
                                            (max u₁ v₁)
                                            (max u₁ v₁)
                                            u₁
                                            (max v₁ u₁ (v₁+1))
                                            (max v₁ u₁ (v₁+1))
                                            (max v₁ u₁ (v₁+1))}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (opposite.{(max v₁ u₁ (v₁+1))+1}
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁}))
                                            (@category_theory.category.opposite.{(max u₁ v₁)
                                               (max v₁ u₁ (v₁+1))}
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁})
                                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                                  (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁}))
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                               (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                               (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.op.{v₁
                                               (max u₁ v₁)
                                               u₁
                                               (max v₁ u₁ (v₁+1))}
                                               C
                                               𝒞
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁})
                                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                                  (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁})
                                               (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                            (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁})
                                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                                  (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁})))
                                         F)))
                                Y)
                             (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}
                                (@prod.snd.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                   (opposite.{(max v₁ u₁ (v₁+1))+1}
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁}))
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@category_theory.functor.obj.{(max u₁ v₁)
                                      (max u₁ v₁)
                                      (max u₁ v₁ u₁ (v₁+1))
                                      (max v₁ u₁ (v₁+1))}
                                      (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                      (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                         (opposite.{(max v₁ u₁ (v₁+1))+1}
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁}))
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.prod.{(max u₁ v₁)
                                         (max u₁ v₁)
                                         (max v₁ u₁ (v₁+1))
                                         (max v₁ u₁ (v₁+1))}
                                         (opposite.{(max v₁ u₁ (v₁+1))+1}
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁}))
                                         (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                               (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁}))
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.prod.{v₁
                                         (max u₁ v₁)
                                         (max u₁ v₁)
                                         (max u₁ v₁)
                                         u₁
                                         (max v₁ u₁ (v₁+1))
                                         (max v₁ u₁ (v₁+1))
                                         (max v₁ u₁ (v₁+1))}
                                         (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (opposite.{(max v₁ u₁ (v₁+1))+1}
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁}))
                                         (@category_theory.category.opposite.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                               (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁}))
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁})
                                         (@category_theory.functor.op.{v₁
                                            (max u₁ v₁)
                                            u₁
                                            (max v₁ u₁ (v₁+1))}
                                            C
                                            𝒞
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                               (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                         (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                               (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})))
                                      F))
                                Y)
                             (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                (Type v₁)
                                category_theory.types.{v₁}
                                (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                                   (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                      (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                      (Type v₁)
                                      category_theory.types.{v₁})
                                   (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                      (opposite.{(max v₁ u₁ (v₁+1))+1}
                                         (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (Type v₁)
                                            category_theory.types.{v₁}))
                                      (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                         (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                         (Type v₁)
                                         category_theory.types.{v₁})
                                      (@category_theory.functor.obj.{(max u₁ v₁)
                                         (max u₁ v₁)
                                         (max u₁ v₁ u₁ (v₁+1))
                                         (max v₁ u₁ (v₁+1))}
                                         (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁}))
                                         (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                         (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                            (opposite.{(max v₁ u₁ (v₁+1))+1}
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁}))
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁}))
                                         (@category_theory.prod.{(max u₁ v₁)
                                            (max u₁ v₁)
                                            (max v₁ u₁ (v₁+1))
                                            (max v₁ u₁ (v₁+1))}
                                            (opposite.{(max v₁ u₁ (v₁+1))+1}
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁}))
                                            (@category_theory.category.opposite.{(max u₁ v₁)
                                               (max v₁ u₁ (v₁+1))}
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁})
                                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                                  (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁}))
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                               (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁}))
                                         (@category_theory.functor.prod.{v₁
                                            (max u₁ v₁)
                                            (max u₁ v₁)
                                            (max u₁ v₁)
                                            u₁
                                            (max v₁ u₁ (v₁+1))
                                            (max v₁ u₁ (v₁+1))
                                            (max v₁ u₁ (v₁+1))}
                                            (opposite.{u₁+1} C)
                                            (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                            (opposite.{(max v₁ u₁ (v₁+1))+1}
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁}))
                                            (@category_theory.category.opposite.{(max u₁ v₁)
                                               (max v₁ u₁ (v₁+1))}
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁})
                                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                                  (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁}))
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                               (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                               (opposite.{u₁+1} C)
                                               (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                               (Type v₁)
                                               category_theory.types.{v₁})
                                            (@category_theory.functor.op.{v₁
                                               (max u₁ v₁)
                                               u₁
                                               (max v₁ u₁ (v₁+1))}
                                               C
                                               𝒞
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁})
                                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                                  (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁})
                                               (@category_theory.yoneda.{v₁ u₁} C 𝒞))
                                            (@category_theory.functor.id.{(max u₁ v₁) (max v₁ u₁ (v₁+1))}
                                               (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁})
                                               (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1}
                                                  (opposite.{u₁+1} C)
                                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                  (Type v₁)
                                                  category_theory.types.{v₁})))
                                         F)))
                                X
                                Y
                                f)
                             (λ
                              (a :
                                @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                  (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                  (Type v₁)
                                  category_theory.types.{v₁}
                                  (@opposite.unop.{(max v₁ u₁ (v₁+1))+1}
                                     (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                        (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                        (Type v₁)
                                        category_theory.types.{v₁})
                                     (@prod.fst.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                        (opposite.{(max v₁ u₁ (v₁+1))+1}
                                           (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                              (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                              (Type v₁)
                                              category_theory.types.{v₁}))
                                        (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                           (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                           (Type v₁)
                                           category_theory.types.{v₁})
                                        (@category_theory.functor.obj.{(max u₁ v₁)
                                           (max u₁ v₁)
                                           (max u₁ v₁ u₁ (v₁+1))
                                           (max v₁ u₁ (v₁+1))}
                                           (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                 (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                 (Type v₁)
                                                 category_theory.types.{v₁}))
                                           (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
                                           (prod.{(max v₁ u₁ (v₁+1)) (max v₁ u₁ (v₁+1))}
                                              (opposite.{(max v₁ u₁ (v₁+1))+1}
                                                 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                    (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                                                    (Type v₁)
                                                    category_theory.types.{v₁}))
                                              (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                                                 …
                                                 (Type v₁)
                                                 category_theory.types.{v₁}))
                                           …
                                           …
                                           F)))
                                  Y), …))
                          …
                          …))
                …)
             …)
          x
          x_1))
    …'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
x :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
x_1 :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
    x
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x))
    (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       (@category_theory.category_struct.id.{v₁ u₁} (opposite.{u₁+1} C)
          (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞))
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             x))
       (@ulift.down.{u₁ v₁}
          (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                x)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                x))
          x_1))
    (@ulift.down.{u₁ v₁}
       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             x)
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             x))
       x_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>181      rw [functor_to_types.map_id]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.functor_to_types.map_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/types.lean&#x27;, &#x27;line&#x27;: 39, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (F : @category_theory.functor.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁}) {X : C} (a : @category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F X), @eq.{v₁+1} (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F X) (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} C 𝒞 (Type v₁) category_theory.types.{v₁} F X X (@category_theory.category_struct.id.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞) X) a) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
x :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
x_1 :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
    x
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x))
    (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       (@category_theory.category_struct.id.{v₁ u₁} (opposite.{u₁+1} C)
          (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞))
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             x))
       (@ulift.down.{u₁ v₁}
          (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                x)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                x))
          x_1))
    (@ulift.down.{u₁ v₁}
       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             x)
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             x))
       x_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
x :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
x_1 :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
    x
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x))
    (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       (@category_theory.category_struct.id.{v₁ u₁} (opposite.{u₁+1} C)
          (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞))
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             x))
       (@ulift.down.{u₁ v₁}
          (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                x)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                x))
          x_1))
    (@ulift.down.{u₁ v₁}
       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             x)
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             x))
       x_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>182    end }.</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
x :
  prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
    (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}),
x_1 :
  @category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1}
    (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
       (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}))
    (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞)
    (Type (max u₁ v₁))
    category_theory.types.{(max u₁ v₁)}
    (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)
    x
⊢ @eq.{v₁+1}
    (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x))
    (@category_theory.functor.map.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
       (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
       (Type v₁)
       category_theory.types.{v₁}
       (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
          (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁})
          x)
       (@category_theory.category_struct.id.{v₁ u₁} (opposite.{u₁+1} C)
          (@category_theory.category.to_category_struct.{v₁ u₁} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞))
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             x))
       (@ulift.down.{u₁ v₁}
          (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
             (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
             (Type v₁)
             category_theory.types.{v₁}
             (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                x)
             (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
                (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                   (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                   (Type v₁)
                   category_theory.types.{v₁})
                x))
          x_1))
    (@ulift.down.{u₁ v₁}
       (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
          (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
          (Type v₁)
          category_theory.types.{v₁}
          (@prod.snd.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             x)
          (@prod.fst.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C)
             (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C)
                (@category_theory.category.opposite.{v₁ u₁} C 𝒞)
                (Type v₁)
                category_theory.types.{v₁})
             x))
       x_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>183  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>184  variables {C}</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>185  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>186  @[simp] def yoneda_sections (X : C) (F : Cᵒᵖ ⥤ Type v₁) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type (v₁+1)) [_inst_2 : category_theory.category.{v₁ v₁+1} D], Type (max v₁ u₁ (v₁+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>187    (yoneda.obj X ⟶ F) ≅ ulift.{u₁} (F.obj (op X)) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.yoneda'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ulift'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='opposite.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 26, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 993, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.functor.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type (max v₁ u₁ (v₁+1))} [_inst_2 : category_theory.category.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} D], @category_theory.functor.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v₁ u₁ (v₁+1))} [c : category_theory.has_hom.{(max v₁ u₁) (max v₁ u₁ (v₁+1))} obj], obj → obj → Type (max v₁ u₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type ((max v₁ u₁)+1)} [_inst_1 : category_theory.category.{(max u₁ v₁) (max v₁ u₁)+1} C], C → C → Type (max u₁ v₁)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type s → Type (max s r)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type (v₁+1)} [_inst_2 : category_theory.category.{v₁ v₁+1} D], @category_theory.functor.{v₁ v₁ u₁ v₁+1} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u}, α → opposite.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='Universe lifting operation'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>188  (yoneda_lemma C).app (op X, F)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.yoneda_lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 144, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_isomorphism.lean&#x27;, &#x27;line&#x27;: 17, &#x27;column&#x27;: 23}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [𝒞 : category_theory.category.{v₁ u₁} C], @category_theory.iso.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁) (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))} (@category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞) (Type (max u₁ v₁)) category_theory.types.{(max u₁ v₁)}) (@category_theory.functor.category.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1} (prod.{u₁ (max v₁ u₁ (v₁+1))} (opposite.{u₁+1} C) (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁})) (@category_theory.prod_category_instance_2.{v₁ u₁} C 𝒞) (Type (max u₁ v₁)) category_theory.types.{(max u₁ v₁)}) (@category_theory.yoneda_pairing.{v₁ u₁} C 𝒞) (@category_theory.yoneda_evaluation.{v₁ u₁} C 𝒞)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (max u₁ v₁ u₁ (v₁+1))} [_inst_1 : category_theory.category.{(max u₁ v₁) (max u₁ v₁ u₁ (v₁+1))} C] {D : Type ((max u₁ v₁)+1)} [_inst_2 : category_theory.category.{(max u₁ v₁) (max u₁ v₁)+1} D] {F G : @category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1} C _inst_1 D _inst_2}, @category_theory.iso.{(max (max u₁ v₁ u₁ (v₁+1)) u₁ v₁) (max (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) ((max u₁ v₁)+1))} (@category_theory.functor.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1} C _inst_1 D _inst_2) (@category_theory.functor.category.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1} C _inst_1 D _inst_2) F G → Π (X : C), @category_theory.iso.{(max u₁ v₁) (max u₁ v₁)+1} D _inst_2 (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1} C _inst_1 D _inst_2 F X) (@category_theory.functor.obj.{(max u₁ v₁) (max u₁ v₁) (max u₁ v₁ u₁ (v₁+1)) (max u₁ v₁)+1} C _inst_1 D _inst_2 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u₁} {β : Type (max v₁ u₁ (v₁+1))}, α → β → prod.{u₁ (max v₁ u₁ (v₁+1))} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Sort u}, α → opposite.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The application of a natural isomorphism to an object. We put this definition in a different namespace, so that we can use α.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>189  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>190  omit 𝒞</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>191  @[simp] def yoneda_sections_small {C : Type u₁} [small_category C] (X : C) (F : Cᵒᵖ ⥤ Type u₁) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='blue'><a title='category_theory.small_category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='opposite'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 87, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 35, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                 </code><font color='green'><a title='Type u₁ → Type (u₁+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u₁ → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{u₁ u₁} C] (D : Type (u₁+1)) [_inst_2 : category_theory.category.{u₁ u₁+1} D], Type (u₁+1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                           </code><font color='orange'><a title='A `small_category` has objects and morphisms in the same universe level.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The type of objects of the opposite of `α`; used to defined opposite category/group/...

 In order to avoid confusion between `α` and its opposite type, we
 set up the type of objects `opposite α` using the following pattern,
 which will be repeated later for the morphisms.

 1. Define `opposite α := α`.
 2. Define the isomorphisms `op : α → opposite α`, `unop : opposite α → α`.
 3. Make the definition `opposite` irreducible.

 This has the following consequences.

 * `opposite α` and `α` are distinct types in the elaborator, so you
   must use `op` and `unop` explicitly to convert between them.
 * Both `unop (op X) = X` and `op (unop X) = X` are definitional
   equalities. Notably, every object of the opposite category is
   definitionally of the form `op X`, which greatly simplifies the
   definition of the structure of the opposite category, for example.

 (If Lean supported definitional eta equality for records, we could
 achieve the same goals using a structure with one field.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>192    (yoneda.obj X ⟶ F) ≅ F.obj (op X) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='category_theory.yoneda'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.iso'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='opposite.op'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 26, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 38, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/opposite.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{u₁ u₁} C], @category_theory.functor.{u₁ u₁ u₁ u₁+1} C 𝒞 (@category_theory.functor.{u₁ u₁ u₁ u₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{u₁ u₁} C 𝒞) (Type u₁) category_theory.types.{u₁}) (@category_theory.functor.category.{u₁ u₁ u₁ u₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{u₁ u₁} C 𝒞) (Type u₁) category_theory.types.{u₁})'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{u₁ u₁} C] {D : Type (u₁+1)} [_inst_2 : category_theory.category.{u₁ u₁+1} D], @category_theory.functor.{u₁ u₁ u₁ u₁+1} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (u₁+1)} [c : category_theory.has_hom.{u₁ u₁+1} obj], obj → obj → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u₁ u₁ u₁ u₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{u₁ u₁} C _inst_1) (Type u₁) category_theory.types.{u₁}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {C : Type (u₁+1)} [_inst_1 : category_theory.category.{u₁ u₁+1} C], C → C → Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u₁ u₁ u₁ u₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{u₁ u₁} C _inst_1) (Type u₁) category_theory.types.{u₁}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{u₁ u₁} C] {D : Type (u₁+1)} [_inst_2 : category_theory.category.{u₁ u₁+1} D], @category_theory.functor.{u₁ u₁ u₁ u₁+1} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Sort u}, α → opposite.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>193  yoneda_sections X F ≪≫ ulift_trivial _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.yoneda_sections'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.iso.trans'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.ulift_trivial'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 186, &#x27;column&#x27;: 12}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/isomorphism.lean&#x27;, &#x27;line&#x27;: 90, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/types.lean&#x27;, &#x27;line&#x27;: 53, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] (X : C) (F : @category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}), @category_theory.iso.{(max u₁ v₁) (max v₁ u₁)+1} (Type (max v₁ u₁)) category_theory.types.{(max u₁ v₁)} (@category_theory.has_hom.hom.{(max v₁ u₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.category_struct.to_has_hom.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.category.to_category_struct.{(max u₁ v₁) (max v₁ u₁ (v₁+1))} (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}))) (@category_theory.functor.obj.{v₁ (max u₁ v₁) u₁ (max v₁ u₁ (v₁+1))} C 𝒞 (@category_theory.functor.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.functor.category.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁}) (@category_theory.yoneda.{v₁ u₁} C 𝒞) X) F) (ulift.{u₁ v₁} (@category_theory.functor.obj.{v₁ v₁ u₁ v₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{v₁ u₁} C 𝒞) (Type v₁) category_theory.types.{v₁} F (@opposite.op.{u₁+1} C X)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{u₁ u₁ u₁ u₁+1} (opposite.{u₁+1} C) (@category_theory.category.opposite.{u₁ u₁} C _inst_1) (Type u₁) category_theory.types.{u₁}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {C : Type (u₁+1)} [𝒞 : category_theory.category.{u₁ u₁+1} C] {X Y Z : C}, @category_theory.iso.{u₁ u₁+1} C 𝒞 X Y → @category_theory.iso.{u₁ u₁+1} C 𝒞 Y Z → @category_theory.iso.{u₁ u₁+1} C 𝒞 X Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (V : Type u), @category_theory.iso.{u u+1} (Type u) category_theory.types.{u} (ulift.{u u} V) V'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>194  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>195  end category_theory</code></pre>
</body>