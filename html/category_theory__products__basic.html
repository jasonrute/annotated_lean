<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2017 Scott Morrison. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Authors: Stephen Morgan, Scott Morrison</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  import category_theory.equivalence</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/equivalence.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import category_theory.eq_to_hom</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/eq_to_hom.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  import tactic.interactive</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  namespace category_theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  universes v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄ -- declare the `v`&#x27;s first; see `category_theory.category` for an explanation</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  section</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  variables (C : Type u₁) [𝒞 : category.{v₁} C] (D : Type u₂) [𝒟 : category.{v₂} D]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  include 𝒞 𝒟</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  `prod C D` gives the cartesian product of two categories.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  instance prod : category.{max v₁ v₂} (C × D) :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  { hom     := λ X Y, ((X.1) ⟶ (Y.1)) × ((X.2) ⟶ (Y.2)),</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23    id      := λ X, ⟨ 𝟙 (X.1), 𝟙 (X.2) ⟩,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24    comp    := λ _ _ _ f g, (f.1 ≫ g.1, f.2 ≫ g.2) }</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  -- rfl lemmas for category.prod</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  @[simp] lemma prod_id (X : C) (Y : D) : 𝟙 (X, Y) = (𝟙 X, 𝟙 Y) := rfl</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  @[simp] lemma prod_comp {P Q R : C} {S T U : D} (f : (P, S) ⟶ (Q, T)) (g : (Q, T) ⟶ (R, U)) :</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29    f ≫ g = (f.1 ≫ g.1, f.2 ≫ g.2) := rfl</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  @[simp] lemma prod_id_fst (X : prod C D) : _root_.prod.fst (𝟙 X) = 𝟙 X.fst := rfl</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  @[simp] lemma prod_id_snd (X : prod C D) : _root_.prod.snd (𝟙 X) = 𝟙 X.snd := rfl</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  @[simp] lemma prod_comp_fst {X Y Z : prod C D} (f : X ⟶ Y) (g : Y ⟶ Z) :</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33    (f ≫ g).1 = f.1 ≫ g.1 := rfl</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  @[simp] lemma prod_comp_snd {X Y Z : prod C D} (f : X ⟶ Y) (g : Y ⟶ Z) :</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='simplification lemma'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35    (f ≫ g).2 = f.2 ≫ g.2 := rfl</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  end</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  section</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39  variables (C : Type u₁) [𝒞 : category.{v₁} C] (D : Type u₁) [𝒟 : category.{v₁} D]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  include 𝒞 𝒟</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  /--</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  `prod.category.uniform C D` is an additional instance specialised so both factors have the same universe levels. This helps typeclass resolution.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44  instance uniform_prod : category (C × D) := category_theory.prod C D</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='blue'><a title='category_theory.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='red'><a title='{&#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='green'><a title='Π (C : Type u₁) [𝒞 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [𝒟 : category_theory.category.{v₂ u₂} D], category_theory.category.{(max v₁ v₂) (max u₁ u₂)} (prod.{u₁ u₂} C D)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                       </code><font color='orange'><a title='`prod C D` gives the cartesian product of two categories.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45  end</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47  -- Next we define the natural functors into and out of product categories. For now this doesn&#x27;t address the universal properties.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48  namespace prod</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  variables (C : Type u₁) [𝒞 : category.{v₁} C] (D : Type u₂) [𝒟 : category.{v₂} D]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  include 𝒞 𝒟</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  /-- `inl C Z` is the functor `X ↦ (X, Z)`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54  -- Here and below we specify explicitly the projections to generate `@[simp]` lemmas for, </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55  -- as the default behaviour of `@[simps]` will generate projections all the way down to components of pairs.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56  @[simps obj map] def inl (Z : D) : C ⥤ C × D :=</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57  { obj := λ X, (X, Z),</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58    map := λ X Y f, (f, 𝟙 Z) }</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60  /-- `inr D Z` is the functor `X ↦ (Z, X)`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  @[simps obj map] def inr (Z : C) : D ⥤ C × D :=</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  { obj := λ X, (Z, X),</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63    map := λ X Y f, (𝟙 Z, f) }</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65  /-- `fst` is the functor `(X, Y) ↦ X`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66  @[simps obj map] def fst : C × D ⥤ C :=</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67  { obj := λ X, X.1,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68    map := λ X Y f, f.1 }</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70  /-- `snd` is the functor `(X, Y) ↦ Y`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71  @[simps obj map] def snd : C × D ⥤ D :=</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72  { obj := λ X, X.2,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73    map := λ X Y f, f.2 }</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75  @[simps obj map] def swap : C × D ⥤ D × C :=</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76  { obj := λ X, (X.2, X.1),</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77    map := λ _ _ f, (f.2, f.1) }</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79  @[simps hom_app inv_app] def symmetry : swap C D ⋙ swap D C ≅ 𝟭 (C × D) :=</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80  { hom := { app := λ X, 𝟙 X },</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81    inv := { app := λ X, 𝟙 X } }</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83  def braiding : C × D ≌ D × C :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84  equivalence.mk (swap C D) (swap D C)</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85    (nat_iso.of_components (λ X, eq_to_iso (by simp)) (by tidy))</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/tidy.lean&#x27;, &#x27;line&#x27;: 91, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → opt_param.{1} tactic.tidy.cfg {trace_result := bool.ff, trace_result_prefix := string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))), tactics := tactic.tidy.default_tactics} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title=' Use a variety of conservative tactics to solve goals.
`tidy?` reports back the tactic script it found.
The default list of tactics is stored in `tactic.tidy.default_tidy_tactics`.
This list can be overridden using `tidy { tactics := ... }`.
(The list must be a `list` of `tactic string`, so that `tidy?`
can report a usable tactic script.) 

Tactics can also be added to the list by tagging them (locally) with the
`[tidy]` attribute.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='tidy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;??&#x27;, &#x27;tactic.tidy.cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86    (nat_iso.of_components (λ X, eq_to_iso (by simp)) (by tidy))</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/tidy.lean&#x27;, &#x27;line&#x27;: 91, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → opt_param.{1} tactic.tidy.cfg {trace_result := bool.ff, trace_result_prefix := string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one))))))), tactics := tactic.tidy.default_tactics} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title=' Use a variety of conservative tactics to solve goals.
`tidy?` reports back the tactic script it found.
The default list of tactics is stored in `tactic.tidy.default_tidy_tactics`.
This list can be overridden using `tidy { tactics := ... }`.
(The list must be a `list` of `tactic string`, so that `tidy?`
can report a usable tactic script.) 

Tactics can also be added to the list by tagging them (locally) with the
`[tidy]` attribute.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='tidy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;??&#x27;, &#x27;tactic.tidy.cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88  instance swap_is_equivalence : is_equivalence (swap C D) :=</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89  (by apply_instance : is_equivalence (braiding C D).functor)</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91  end prod</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93  section</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94  variables (C : Type u₁) [𝒞 : category.{v₁} C] (D : Type u₂) [𝒟 : category.{v₂} D]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95  include 𝒞 𝒟</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97  @[simps] def evaluation : C ⥤ (C ⥤ D) ⥤ D :=</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98  { obj := λ X,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99    { obj := λ F, F.obj X,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100      map := λ F G α, α.app X, },</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101    map := λ X Y f,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102    { app := λ F, F.map f,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103      naturality&#x27; := λ F G α, eq.symm (α.naturality f) } }</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105  @[simps obj map] def evaluation_uncurried : C × (C ⥤ D) ⥤ D :=</code>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106  { obj := λ p, p.2.obj p.1,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107    map := λ x y f, (x.2.map f.1) ≫ (f.2.app y.1),</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108    map_comp&#x27; := λ X Y Z f g,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109    begin</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110      cases g, cases f, cases Z, cases Y, cases X,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111      simp only [prod_comp, nat_trans.comp_app, functor.map_comp, category.assoc],</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112      rw [←nat_trans.comp_app, nat_trans.naturality, nat_trans.comp_app,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='blue'><a title='category_theory.nat_trans.comp_app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor_category.lean&#x27;, &#x27;line&#x27;: 40, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G H : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} (α : @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) F G) (β : @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))) G H) (X : C), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 H X)) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F H (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)) F G H α β) X) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 H X) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G α X) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G H β X))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
Z_fst : C,
Z_snd : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
Y_fst : C,
Y_snd : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
g_fst :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) Y_fst
          Y_snd))
    (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) Z_fst
          Z_snd)),
g_snd :
  @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
       (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)))
    (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) Y_fst
          Y_snd))
    (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) Z_fst
          Z_snd)),
X_fst : C,
X_snd : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
f_fst :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) X_fst
          X_snd))
    (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) Y_fst
          Y_snd)),
f_snd :
  @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
       (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)))
    (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) X_fst
          X_snd))
    (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) Y_fst
          Y_snd))
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd)))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Z_fst
                Z_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Z_fst
                Z_snd))))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd)))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Y_fst
                Y_snd)))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Z_fst
                Z_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Z_fst
                Z_snd)))
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Y_fst
                Y_snd))
          f_fst)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   X_fst
                   X_snd))
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd)))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Z_fst
                   Z_snd))
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd)))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Z_fst
                   Z_snd))
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Z_fst
                   Z_snd)))
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   X_fst
                   X_snd))
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Z_fst
                   Z_snd))
             (@category_theory.category_struct.comp.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟))
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      X_fst
                      X_snd))
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd))
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd))
                f_snd
                g_snd)
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd)))
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Z_fst
                   Z_snd))
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd))
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Z_fst
                   Z_snd))
             g_fst)))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd)))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Y_fst
                Y_snd)))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Z_fst
                Z_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Z_fst
                Z_snd)))
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Y_fst
                Y_snd))
          f_fst)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   X_fst
                   X_snd))
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd)))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd))
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd)))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Z_fst
                   Z_snd))
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Z_fst
                   Z_snd)))
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   X_fst
                   X_snd))
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd))
             f_snd
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd)))
          (@category_theory.category_struct.comp.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd))
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd)))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd))
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd)))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd))
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd)))
             (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd))
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd))
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd))
                g_fst)
             (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd))
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd))
                g_snd
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
Z_fst : C,
Z_snd : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
Y_fst : C,
Y_snd : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
g_fst :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) Y_fst
          Y_snd))
    (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) Z_fst
          Z_snd)),
g_snd :
  @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
       (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)))
    (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) Y_fst
          Y_snd))
    (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) Z_fst
          Z_snd)),
X_fst : C,
X_snd : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
f_fst :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) X_fst
          X_snd))
    (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) Y_fst
          Y_snd)),
f_snd :
  @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
       (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)))
    (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) X_fst
          X_snd))
    (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) Y_fst
          Y_snd))
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd)))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Z_fst
                Z_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Z_fst
                Z_snd))))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd)))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Y_fst
                Y_snd)))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Z_fst
                Z_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Z_fst
                Z_snd)))
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Y_fst
                Y_snd))
          f_fst)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   X_fst
                   X_snd))
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd)))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Z_fst
                   Z_snd))
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd)))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Z_fst
                   Z_snd))
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Z_fst
                   Z_snd)))
          (@category_theory.category_struct.comp.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      X_fst
                      X_snd))
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd)))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd))
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd)))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd))
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd)))
             (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      X_fst
                      X_snd))
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd))
                f_snd
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd)))
             (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd))
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd))
                g_snd
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd))))
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Z_fst
                   Z_snd))
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd))
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Z_fst
                   Z_snd))
             g_fst)))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd)))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Y_fst
                Y_snd)))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Z_fst
                Z_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Z_fst
                Z_snd)))
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Y_fst
                Y_snd))
          f_fst)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   X_fst
                   X_snd))
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd)))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd))
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd)))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Z_fst
                   Z_snd))
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Z_fst
                   Z_snd)))
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   X_fst
                   X_snd))
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd))
             f_snd
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd)))
          (@category_theory.category_struct.comp.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd))
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd)))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd))
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd)))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd))
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd)))
             (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd))
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd))
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd))
                g_fst)
             (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd))
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd))
                g_snd
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113          category.assoc, nat_trans.naturality],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='category_theory.category.assoc'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.nat_trans.naturality'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (obj : Type u₂) [c : category_theory.category.{v₂ u₂} obj] {W X Y Z : obj} (f : @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) W X) (g : @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) X Y) (h : @category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) Y Z), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} obj (@category_theory.category_struct.to_has_hom.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c)) W Z) (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) W Y Z (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) W X Y f g) h) (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) W X Z f (@category_theory.category_struct.comp.{v₂ u₂} obj (@category_theory.category.to_category_struct.{v₂ u₂} obj c) X Y Z g h))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} (c : @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G) ⦃X Y : C⦄ (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G c Y)) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G c X) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
Z_fst : C,
Z_snd : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
Y_fst : C,
Y_snd : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
g_fst :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) Y_fst
          Y_snd))
    (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) Z_fst
          Z_snd)),
g_snd :
  @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
       (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)))
    (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) Y_fst
          Y_snd))
    (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) Z_fst
          Z_snd)),
X_fst : C,
X_snd : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
f_fst :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) X_fst
          X_snd))
    (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) Y_fst
          Y_snd)),
f_snd :
  @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
       (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)))
    (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) X_fst
          X_snd))
    (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) Y_fst
          Y_snd))
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd)))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Z_fst
                Z_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Z_fst
                Z_snd))))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd)))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Y_fst
                Y_snd)))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Z_fst
                Z_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Z_fst
                Z_snd)))
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Y_fst
                Y_snd))
          f_fst)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   X_fst
                   X_snd))
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd)))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Z_fst
                   Z_snd))
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd)))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Z_fst
                   Z_snd))
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Z_fst
                   Z_snd)))
          (@category_theory.category_struct.comp.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      X_fst
                      X_snd))
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd)))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd))
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd)))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd))
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd)))
             (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      X_fst
                      X_snd))
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd))
                f_snd
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd)))
             (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd))
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd))
                g_snd
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd))))
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Z_fst
                   Z_snd))
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd))
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Z_fst
                   Z_snd))
             g_fst)))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd)))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Y_fst
                Y_snd)))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Z_fst
                Z_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Z_fst
                Z_snd)))
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Y_fst
                Y_snd))
          f_fst)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   X_fst
                   X_snd))
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd)))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd))
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd)))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Z_fst
                   Z_snd))
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Z_fst
                   Z_snd)))
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   X_fst
                   X_snd))
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd))
             f_snd
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd)))
          (@category_theory.category_struct.comp.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd))
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd)))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd))
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd)))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd))
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd)))
             (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd))
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd))
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd))
                g_fst)
             (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd))
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd))
                g_snd
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='C : Type u₁,
𝒞 : category_theory.category.{v₁ u₁} C,
D : Type u₂,
𝒟 : category_theory.category.{v₂ u₂} D,
Z_fst : C,
Z_snd : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
Y_fst : C,
Y_snd : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
g_fst :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) Y_fst
          Y_snd))
    (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) Z_fst
          Z_snd)),
g_snd :
  @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
       (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)))
    (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) Y_fst
          Y_snd))
    (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) Z_fst
          Z_snd)),
X_fst : C,
X_snd : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟,
f_fst :
  @category_theory.has_hom.hom.{v₁ u₁} C
    (@category_theory.category_struct.to_has_hom.{v₁ u₁} C
       (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞))
    (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) X_fst
          X_snd))
    (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) Y_fst
          Y_snd)),
f_snd :
  @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
       (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
          (@category_theory.functor.category.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)))
    (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) X_fst
          X_snd))
    (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
       (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟) Y_fst
          Y_snd))
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} D
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd)))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Z_fst
                Z_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Z_fst
                Z_snd))))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd)))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Y_fst
                Y_snd)))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Z_fst
                Z_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Z_fst
                Z_snd)))
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Y_fst
                Y_snd))
          f_fst)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   X_fst
                   X_snd))
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd)))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd))
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd)))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Z_fst
                   Z_snd))
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Z_fst
                   Z_snd)))
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   X_fst
                   X_snd))
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd))
             f_snd
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd)))
          (@category_theory.category_struct.comp.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd))
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd)))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd))
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd)))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd))
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd)))
             (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd))
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd))
                g_snd
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd)))
             (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd))
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd))
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd))
                g_fst))))
    (@category_theory.category_struct.comp.{v₂ u₂} D
       (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd)))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Y_fst
                Y_snd)))
       (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Z_fst
                Z_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Z_fst
                Z_snd)))
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
          (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                X_fst
                X_snd))
          (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
             (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                Y_fst
                Y_snd))
          f_fst)
       (@category_theory.category_struct.comp.{v₂ u₂} D
          (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   X_fst
                   X_snd))
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd)))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd))
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd)))
          (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Z_fst
                   Z_snd))
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Z_fst
                   Z_snd)))
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   X_fst
                   X_snd))
             (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd))
             f_snd
             (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   Y_fst
                   Y_snd)))
          (@category_theory.category_struct.comp.{v₂ u₂} D
             (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd))
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd)))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd))
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd)))
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd))
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd)))
             (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd))
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd))
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd))
                g_fst)
             (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Y_fst
                      Y_snd))
                (@prod.snd.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd))
                g_snd
                (@prod.fst.{u₁ (max v₁ v₂ u₁ u₂)} C
                   (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                   (@prod.mk.{u₁ (max v₁ v₂ u₁ u₂)} C
                      (@category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟)
                      Z_fst
                      Z_snd))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114    end }</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116  end</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118  variables {A : Type u₁} [𝒜 : category.{v₁} A]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119            {B : Type u₂} [ℬ : category.{v₂} B]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120            {C : Type u₃} [𝒞 : category.{v₃} C]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121            {D : Type u₄} [𝒟 : category.{v₄} D]</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='category_theory.category'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 61, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u → Type (max u (v+1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='orange'><a title='The typeclass `category C` describes morphisms associated to objects of type `C`.
The universe levels of the objects and morphisms are unconstrained, and will often need to be
specified explicitly, as `category.{v} C`. (See also `large_category` and `small_category`.)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122  include 𝒜 ℬ 𝒞 𝒟</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124  namespace functor</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125  /-- The cartesian product of two functors. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126  @[simps obj map] def prod (F : A ⥤ B) (G : C ⥤ D) : A × C ⥤ B × D :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [_inst_2 : category_theory.category.{v₂ u₂} D], Type (max v₁ v₂ u₁ u₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Type u₃'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₃) [_inst_1 : category_theory.category.{v₃ u₃} C] (D : Type u₄) [_inst_2 : category_theory.category.{v₄ u₄} D], Type (max v₃ v₄ u₃ u₄)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₄'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₁ → Type u₃ → Type (max u₁ u₃)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₃'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type (max u₁ u₃)) [_inst_1 : category_theory.category.{(max v₁ v₃) (max u₁ u₃)} C] (D : Type (max u₂ u₄)) [_inst_2 : category_theory.category.{(max v₂ v₄) (max u₂ u₄)} D], Type (max (max v₁ v₃) (max v₂ v₄) (max u₁ u₃) u₂ u₄)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₂ → Type u₄ → Type (max u₂ u₄)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₄'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127  { obj := λ X, (F.obj X.1, G.obj X.2),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='obviously'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.obj'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='prod.{u₁ u₃} A C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u₂} {β : Type u₄}, α → β → prod.{u₂ u₄} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D], @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u₁ u₃} A C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u₁} {β : Type u₃}, prod.{u₁ u₃} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₃} [_inst_1 : category_theory.category.{v₃ u₃} C] {D : Type u₄} [_inst_2 : category_theory.category.{v₄ u₄} D], @category_theory.functor.{v₃ v₄ u₃ u₄} C _inst_1 D _inst_2 → C → D'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u₁ u₃} A C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u₁} {β : Type u₃}, prod.{u₁ u₃} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `obviously` tactic is a &quot;replaceable&quot; tactic, which means that its meaning is defined by tactics that are defined later with the `@[obviously]` attribute. It is intended for use with `auto_param`s for structure fields.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128    map := λ _ _ f, (F.map f.1, G.map f.2) }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='_x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='prod.{u₁ u₃} A C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u₁ u₃} A C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C) (@category_theory.category_struct.to_has_hom.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C) (@category_theory.category.to_category_struct.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C) (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞))) _x _x_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₂} {β : Type v₄}, α → β → prod.{v₂ v₄} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [_inst_1 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [_inst_2 : category_theory.category.{v₂ u₂} D] (c : @category_theory.functor.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D _inst_2)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C) (@category_theory.category_struct.to_has_hom.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C) (@category_theory.category.to_category_struct.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C) (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞))) _x _x_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v₁} {β : Type v₃}, prod.{v₁ v₃} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₃} [_inst_1 : category_theory.category.{v₃ u₃} C] {D : Type u₄} [_inst_2 : category_theory.category.{v₄ u₄} D] (c : @category_theory.functor.{v₃ v₄ u₃ u₄} C _inst_1 D _inst_2) {X Y : C}, @category_theory.has_hom.hom.{v₃ u₃} C (@category_theory.category_struct.to_has_hom.{v₃ u₃} C (@category_theory.category.to_category_struct.{v₃ u₃} C _inst_1)) X Y → @category_theory.has_hom.hom.{v₄ u₄} D (@category_theory.category_struct.to_has_hom.{v₄ u₄} D (@category_theory.category.to_category_struct.{v₄ u₄} D _inst_2)) (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C _inst_1 D _inst_2 c X) (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C _inst_1 D _inst_2 c Y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C) (@category_theory.category_struct.to_has_hom.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C) (@category_theory.category.to_category_struct.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C) (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞))) _x _x_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type v₁} {β : Type v₃}, prod.{v₁ v₃} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130  /- Because of limitations in Lean 3&#x27;s handling of notations, we do not setup a notation `F × G`.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131     You can use `F.prod G` as a &quot;poor man&#x27;s infix&quot;, or just write `functor.prod F G`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133  end functor</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135  namespace nat_trans</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137  /-- The cartesian product of two natural transformations. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138  @[simps app] def prod {F G : A ⥤ B} {H I : C ⥤ D} (α : F ⟶ G) (β : H ⟶ I) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='B'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.functor'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='D'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/functor.lean&#x27;, &#x27;line&#x27;: 30, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                             </code><font color='green'><a title='Type u₁'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₁) [_inst_1 : category_theory.category.{v₁ u₁} C] (D : Type u₂) [_inst_2 : category_theory.category.{v₂ u₂} D], Type (max v₁ v₂ u₁ u₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='green'><a title='Type u₃'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (C : Type u₃) [_inst_1 : category_theory.category.{v₃ u₃} C] (D : Type u₄) [_inst_2 : category_theory.category.{v₄ u₄} D], Type (max v₃ v₄ u₃ u₄)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u₄'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v₁ v₂ u₁ u₂)} [c : category_theory.has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} obj], obj → obj → Type (max u₁ v₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max v₃ v₄ u₃ u₄)} [c : category_theory.has_hom.{(max u₃ v₄) (max v₃ v₄ u₃ u₄)} obj], obj → obj → Type (max u₃ v₄)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Automatically derive lemmas specifying the projections of this declaration.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='`functor C D` represents a functor between categories `C` and `D`.

To apply a functor `F` to an object use `F.obj X`, and to a morphism use `F.map f`.

The axiom `map_id_lemma` expresses preservation of identities, and
`map_comp_lemma` expresses functoriality.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139    F.prod H ⟶ G.prod I :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='F'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='H'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='category_theory.has_hom.hom'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.functor.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;line&#x27;: 126, &#x27;column&#x27;: 21}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/category/default.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 126, &#x27;column&#x27;: 21}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {A : Type u₁} [𝒜 : category_theory.category.{v₁ u₁} A] {B : Type u₂} [ℬ : category_theory.category.{v₂ u₂} B] {C : Type u₃} [𝒞 : category_theory.category.{v₃ u₃} C] {D : Type u₄} [𝒟 : category_theory.category.{v₄ u₄} D], @category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ → @category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 → @category_theory.functor.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)} (prod.{u₁ u₃} A C) (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞) (prod.{u₂ u₄} B D) (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {obj : Type (max (max v₁ v₃) (max v₂ v₄) (max u₁ u₃) u₂ u₄)} [c : category_theory.has_hom.{(max (max u₁ u₃) v₂ v₄) (max (max v₁ v₃) (max v₂ v₄) (max u₁ u₃) u₂ u₄)} obj], obj → obj → Type (max (max u₁ u₃) v₂ v₄)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {A : Type u₁} [𝒜 : category_theory.category.{v₁ u₁} A] {B : Type u₂} [ℬ : category_theory.category.{v₂ u₂} B] {C : Type u₃} [𝒞 : category_theory.category.{v₃ u₃} C] {D : Type u₄} [𝒟 : category_theory.category.{v₄ u₄} D], @category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ → @category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 → @category_theory.functor.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)} (prod.{u₁ u₃} A C) (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞) (prod.{u₂ u₄} B D) (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The cartesian product of two functors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The cartesian product of two functors.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140  { app         := λ X, (α.app X.1, β.app X.2),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='category_theory.nat_trans.app'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;, &#x27;line&#x27;: 31, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='prod.{u₁ u₃} A C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type v₂} {β : Type v₄}, α → β → prod.{v₂ v₄} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ) (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ) (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)} (@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ) (@category_theory.functor.category.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ))) F G'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u₁ u₃} A C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u₁} {β : Type u₃}, prod.{u₁ u₃} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@category_theory.has_hom.hom.{(max u₃ v₄) (max v₃ v₄ u₃ u₄)} (@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟) (@category_theory.category_struct.to_has_hom.{(max u₃ v₄) (max v₃ v₄ u₃ u₄)} (@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟) (@category_theory.category.to_category_struct.{(max u₃ v₄) (max v₃ v₄ u₃ u₄)} (@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟) (@category_theory.functor.category.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟))) H I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {C : Type u₃} [𝒞 : category_theory.category.{v₃ u₃} C] {D : Type u₄} [𝒟 : category_theory.category.{v₄ u₄} D] {F G : @category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟}, @category_theory.nat_trans.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 F G → Π (X : C), @category_theory.has_hom.hom.{v₄ u₄} D (@category_theory.category_struct.to_has_hom.{v₄ u₄} D (@category_theory.category.to_category_struct.{v₄ u₄} D 𝒟)) (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 G X)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u₁ u₃} A C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u₁} {β : Type u₃}, prod.{u₁ u₃} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141    naturality&#x27; := λ X Y f,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='f'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='green'><a title='prod.{u₁ u₃} A C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u₁ u₃} A C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@category_theory.has_hom.hom.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C) (@category_theory.category_struct.to_has_hom.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C) (@category_theory.category.to_category_struct.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C) (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞))) X Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142    begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='A : Type u₁,
𝒜 : category_theory.category.{v₁ u₁} A,
B : Type u₂,
ℬ : category_theory.category.{v₂ u₂} B,
C : Type u₃,
𝒞 : category_theory.category.{v₃ u₃} C,
D : Type u₄,
𝒟 : category_theory.category.{v₄ u₄} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ,
H I : @category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟,
α :
  @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
       (@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)
       (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)
          (@category_theory.functor.category.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)))
    F
    G,
β :
  @category_theory.has_hom.hom.{(max u₃ v₄) (max v₃ v₄ u₃ u₄)}
    (@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)
    (@category_theory.category_struct.to_has_hom.{(max u₃ v₄) (max v₃ v₄ u₃ u₄)}
       (@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)
       (@category_theory.category.to_category_struct.{(max u₃ v₄) (max v₃ v₄ u₃ u₄)}
          (@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)
          (@category_theory.functor.category.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)))
    H
    I,
X Y : prod.{u₁ u₃} A C,
f :
  @category_theory.has_hom.hom.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C)
    (@category_theory.category_struct.to_has_hom.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C)
       (@category_theory.category.to_category_struct.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)))
    X
    Y
⊢ @eq.{(max v₂ v₄)+1}
    (@category_theory.has_hom.hom.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
       (@category_theory.category_struct.to_has_hom.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
          (@category_theory.category.to_category_struct.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
             (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)))
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          X)
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          Y))
    (@category_theory.category_struct.comp.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
       (@category_theory.category.to_category_struct.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟))
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          X)
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          Y)
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          Y)
       (@category_theory.functor.map.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          X
          Y
          f)
       (@prod.mk.{v₂ v₄}
          (@category_theory.has_hom.hom.{v₂ u₂} B
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} B
                (@category_theory.category.to_category_struct.{v₂ u₂} B ℬ))
             (@prod.fst.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F
                      H)
                   Y))
             (@prod.fst.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G
                      I)
                   Y)))
          (@category_theory.has_hom.hom.{v₄ u₄} D
             (@category_theory.category_struct.to_has_hom.{v₄ u₄} D
                (@category_theory.category.to_category_struct.{v₄ u₄} D 𝒟))
             (@prod.snd.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F
                      H)
                   Y))
             (@prod.snd.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G
                      I)
                   Y)))
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F G α (@prod.fst.{u₁ u₃} A C Y))
          (@category_theory.nat_trans.app.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H I β (@prod.snd.{u₁ u₃} A C Y))))
    (@category_theory.category_struct.comp.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
       (@category_theory.category.to_category_struct.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟))
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          X)
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          X)
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          Y)
       (@prod.mk.{v₂ v₄}
          (@category_theory.has_hom.hom.{v₂ u₂} B
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} B
                (@category_theory.category.to_category_struct.{v₂ u₂} B ℬ))
             (@prod.fst.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F
                      H)
                   X))
             (@prod.fst.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G
                      I)
                   X)))
          (@category_theory.has_hom.hom.{v₄ u₄} D
             (@category_theory.category_struct.to_has_hom.{v₄ u₄} D
                (@category_theory.category.to_category_struct.{v₄ u₄} D 𝒟))
             (@prod.snd.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F
                      H)
                   X))
             (@prod.snd.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G
                      I)
                   X)))
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F G α (@prod.fst.{u₁ u₃} A C X))
          (@category_theory.nat_trans.app.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H I β (@prod.snd.{u₁ u₃} A C X)))
       (@category_theory.functor.map.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          X
          Y
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143      cases X, cases Y,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='X'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='Y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 745, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{u₁ u₃} A C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{u₁ u₃} A C'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='Assuming `x` is a variable in the local context with an inductive type, `cases x` splits the main goal, producing one goal for each constructor of the inductive type, in which the target is replaced by a general instance of that constructor. If the type of an element in the local context depends on `x`, that element is reverted and reintroduced afterward, so that the case split affects that hypothesis as well.

For example, given `n : nat` and a goal with a hypothesis `h : P n` and target `Q n`, `cases n` produces one goal with hypothesis `h : P 0` and target `Q 0`, and one goal with hypothesis `h : P (nat.succ a)` and target `Q (nat.succ a)`. Here the name `a` is chosen automatically.

`cases e`, where `e` is an expression instead of a variable, generalizes `e` in the goal, and then cases on the resulting variable.

`cases e with y₁ ... yₙ`, where `e` is a variable or an expression, specifies that the sequence of names `y₁ ... yₙ` should be used for the arguments to the constructors, including implicit arguments. If the list does not include enough names for all of the arguments, additional names are generated automatically. If too many names are given, the extra ones are ignored. Underscores can be used in the list, in which case the corresponding names are generated automatically.

`cases h : e`, where `e` is a variable or an expression, performs cases on `e` as above, but also adds a hypothesis `h : e = ...` to each hypothesis, where `...` is the constructor instance for that particular case.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;, &#x27;(with id*)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='A : Type u₁,
𝒜 : category_theory.category.{v₁ u₁} A,
B : Type u₂,
ℬ : category_theory.category.{v₂ u₂} B,
C : Type u₃,
𝒞 : category_theory.category.{v₃ u₃} C,
D : Type u₄,
𝒟 : category_theory.category.{v₄ u₄} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ,
H I : @category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟,
α :
  @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
       (@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)
       (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)
          (@category_theory.functor.category.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)))
    F
    G,
β :
  @category_theory.has_hom.hom.{(max u₃ v₄) (max v₃ v₄ u₃ u₄)}
    (@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)
    (@category_theory.category_struct.to_has_hom.{(max u₃ v₄) (max v₃ v₄ u₃ u₄)}
       (@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)
       (@category_theory.category.to_category_struct.{(max u₃ v₄) (max v₃ v₄ u₃ u₄)}
          (@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)
          (@category_theory.functor.category.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)))
    H
    I,
X Y : prod.{u₁ u₃} A C,
f :
  @category_theory.has_hom.hom.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C)
    (@category_theory.category_struct.to_has_hom.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C)
       (@category_theory.category.to_category_struct.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)))
    X
    Y
⊢ @eq.{(max v₂ v₄)+1}
    (@category_theory.has_hom.hom.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
       (@category_theory.category_struct.to_has_hom.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
          (@category_theory.category.to_category_struct.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
             (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)))
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          X)
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          Y))
    (@category_theory.category_struct.comp.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
       (@category_theory.category.to_category_struct.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟))
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          X)
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          Y)
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          Y)
       (@category_theory.functor.map.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          X
          Y
          f)
       (@prod.mk.{v₂ v₄}
          (@category_theory.has_hom.hom.{v₂ u₂} B
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} B
                (@category_theory.category.to_category_struct.{v₂ u₂} B ℬ))
             (@prod.fst.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F
                      H)
                   Y))
             (@prod.fst.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G
                      I)
                   Y)))
          (@category_theory.has_hom.hom.{v₄ u₄} D
             (@category_theory.category_struct.to_has_hom.{v₄ u₄} D
                (@category_theory.category.to_category_struct.{v₄ u₄} D 𝒟))
             (@prod.snd.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F
                      H)
                   Y))
             (@prod.snd.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G
                      I)
                   Y)))
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F G α (@prod.fst.{u₁ u₃} A C Y))
          (@category_theory.nat_trans.app.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H I β (@prod.snd.{u₁ u₃} A C Y))))
    (@category_theory.category_struct.comp.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
       (@category_theory.category.to_category_struct.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟))
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          X)
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          X)
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          Y)
       (@prod.mk.{v₂ v₄}
          (@category_theory.has_hom.hom.{v₂ u₂} B
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} B
                (@category_theory.category.to_category_struct.{v₂ u₂} B ℬ))
             (@prod.fst.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F
                      H)
                   X))
             (@prod.fst.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G
                      I)
                   X)))
          (@category_theory.has_hom.hom.{v₄ u₄} D
             (@category_theory.category_struct.to_has_hom.{v₄ u₄} D
                (@category_theory.category.to_category_struct.{v₄ u₄} D 𝒟))
             (@prod.snd.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F
                      H)
                   X))
             (@prod.snd.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G
                      I)
                   X)))
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F G α (@prod.fst.{u₁ u₃} A C X))
          (@category_theory.nat_trans.app.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H I β (@prod.snd.{u₁ u₃} A C X)))
       (@category_theory.functor.map.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          X
          Y
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='A : Type u₁,
𝒜 : category_theory.category.{v₁ u₁} A,
B : Type u₂,
ℬ : category_theory.category.{v₂ u₂} B,
C : Type u₃,
𝒞 : category_theory.category.{v₃ u₃} C,
D : Type u₄,
𝒟 : category_theory.category.{v₄ u₄} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ,
H I : @category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟,
α :
  @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
       (@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)
       (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)
          (@category_theory.functor.category.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)))
    F
    G,
β :
  @category_theory.has_hom.hom.{(max u₃ v₄) (max v₃ v₄ u₃ u₄)}
    (@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)
    (@category_theory.category_struct.to_has_hom.{(max u₃ v₄) (max v₃ v₄ u₃ u₄)}
       (@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)
       (@category_theory.category.to_category_struct.{(max u₃ v₄) (max v₃ v₄ u₃ u₄)}
          (@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)
          (@category_theory.functor.category.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)))
    H
    I,
Y : prod.{u₁ u₃} A C,
X_fst : A,
X_snd : C,
f :
  @category_theory.has_hom.hom.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C)
    (@category_theory.category_struct.to_has_hom.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C)
       (@category_theory.category.to_category_struct.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)))
    (@prod.mk.{u₁ u₃} A C X_fst X_snd)
    Y
⊢ @eq.{(max v₂ v₄)+1}
    (@category_theory.has_hom.hom.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
       (@category_theory.category_struct.to_has_hom.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
          (@category_theory.category.to_category_struct.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
             (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)))
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@prod.mk.{u₁ u₃} A C X_fst X_snd))
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          Y))
    (@category_theory.category_struct.comp.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
       (@category_theory.category.to_category_struct.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟))
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@prod.mk.{u₁ u₃} A C X_fst X_snd))
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          Y)
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          Y)
       (@category_theory.functor.map.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@prod.mk.{u₁ u₃} A C X_fst X_snd)
          Y
          f)
       (@prod.mk.{v₂ v₄}
          (@category_theory.has_hom.hom.{v₂ u₂} B
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} B
                (@category_theory.category.to_category_struct.{v₂ u₂} B ℬ))
             (@prod.fst.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F
                      H)
                   Y))
             (@prod.fst.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G
                      I)
                   Y)))
          (@category_theory.has_hom.hom.{v₄ u₄} D
             (@category_theory.category_struct.to_has_hom.{v₄ u₄} D
                (@category_theory.category.to_category_struct.{v₄ u₄} D 𝒟))
             (@prod.snd.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F
                      H)
                   Y))
             (@prod.snd.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G
                      I)
                   Y)))
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F G α (@prod.fst.{u₁ u₃} A C Y))
          (@category_theory.nat_trans.app.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H I β (@prod.snd.{u₁ u₃} A C Y))))
    (@category_theory.category_struct.comp.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
       (@category_theory.category.to_category_struct.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟))
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@prod.mk.{u₁ u₃} A C X_fst X_snd))
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@prod.mk.{u₁ u₃} A C X_fst X_snd))
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          Y)
       (@prod.mk.{v₂ v₄}
          (@category_theory.has_hom.hom.{v₂ u₂} B
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} B
                (@category_theory.category.to_category_struct.{v₂ u₂} B ℬ))
             (@prod.fst.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F
                      H)
                   (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
             (@prod.fst.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G
                      I)
                   (@prod.mk.{u₁ u₃} A C X_fst X_snd))))
          (@category_theory.has_hom.hom.{v₄ u₄} D
             (@category_theory.category_struct.to_has_hom.{v₄ u₄} D
                (@category_theory.category.to_category_struct.{v₄ u₄} D 𝒟))
             (@prod.snd.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F
                      H)
                   (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
             (@prod.snd.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G
                      I)
                   (@prod.mk.{u₁ u₃} A C X_fst X_snd))))
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F G α
             (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
          (@category_theory.nat_trans.app.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H I β
             (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))))
       (@category_theory.functor.map.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@prod.mk.{u₁ u₃} A C X_fst X_snd)
          Y
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='A : Type u₁,
𝒜 : category_theory.category.{v₁ u₁} A,
B : Type u₂,
ℬ : category_theory.category.{v₂ u₂} B,
C : Type u₃,
𝒞 : category_theory.category.{v₃ u₃} C,
D : Type u₄,
𝒟 : category_theory.category.{v₄ u₄} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ,
H I : @category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟,
α :
  @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
       (@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)
       (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)
          (@category_theory.functor.category.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)))
    F
    G,
β :
  @category_theory.has_hom.hom.{(max u₃ v₄) (max v₃ v₄ u₃ u₄)}
    (@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)
    (@category_theory.category_struct.to_has_hom.{(max u₃ v₄) (max v₃ v₄ u₃ u₄)}
       (@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)
       (@category_theory.category.to_category_struct.{(max u₃ v₄) (max v₃ v₄ u₃ u₄)}
          (@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)
          (@category_theory.functor.category.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)))
    H
    I,
X_fst : A,
X_snd : C,
Y_fst : A,
Y_snd : C,
f :
  @category_theory.has_hom.hom.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C)
    (@category_theory.category_struct.to_has_hom.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C)
       (@category_theory.category.to_category_struct.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)))
    (@prod.mk.{u₁ u₃} A C X_fst X_snd)
    (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)
⊢ @eq.{(max v₂ v₄)+1}
    (@category_theory.has_hom.hom.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
       (@category_theory.category_struct.to_has_hom.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
          (@category_theory.category.to_category_struct.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
             (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)))
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@prod.mk.{u₁ u₃} A C X_fst X_snd))
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
    (@category_theory.category_struct.comp.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
       (@category_theory.category.to_category_struct.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟))
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@prod.mk.{u₁ u₃} A C X_fst X_snd))
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))
       (@category_theory.functor.map.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@prod.mk.{u₁ u₃} A C X_fst X_snd)
          (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)
          f)
       (@prod.mk.{v₂ v₄}
          (@category_theory.has_hom.hom.{v₂ u₂} B
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} B
                (@category_theory.category.to_category_struct.{v₂ u₂} B ℬ))
             (@prod.fst.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F
                      H)
                   (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
             (@prod.fst.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G
                      I)
                   (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))))
          (@category_theory.has_hom.hom.{v₄ u₄} D
             (@category_theory.category_struct.to_has_hom.{v₄ u₄} D
                (@category_theory.category.to_category_struct.{v₄ u₄} D 𝒟))
             (@prod.snd.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F
                      H)
                   (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
             (@prod.snd.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G
                      I)
                   (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))))
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F G α
             (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
          (@category_theory.nat_trans.app.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H I β
             (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))))
    (@category_theory.category_struct.comp.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
       (@category_theory.category.to_category_struct.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟))
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@prod.mk.{u₁ u₃} A C X_fst X_snd))
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@prod.mk.{u₁ u₃} A C X_fst X_snd))
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))
       (@prod.mk.{v₂ v₄}
          (@category_theory.has_hom.hom.{v₂ u₂} B
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} B
                (@category_theory.category.to_category_struct.{v₂ u₂} B ℬ))
             (@prod.fst.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F
                      H)
                   (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
             (@prod.fst.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G
                      I)
                   (@prod.mk.{u₁ u₃} A C X_fst X_snd))))
          (@category_theory.has_hom.hom.{v₄ u₄} D
             (@category_theory.category_struct.to_has_hom.{v₄ u₄} D
                (@category_theory.category.to_category_struct.{v₄ u₄} D 𝒟))
             (@prod.snd.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F
                      H)
                   (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
             (@prod.snd.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G
                      I)
                   (@prod.mk.{u₁ u₃} A C X_fst X_snd))))
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F G α
             (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
          (@category_theory.nat_trans.app.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H I β
             (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))))
       (@category_theory.functor.map.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@prod.mk.{u₁ u₃} A C X_fst X_snd)
          (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144      simp only [functor.prod_map, prod.mk.inj_iff, prod_comp],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='category_theory.functor.prod_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.mk.inj_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='category_theory.prod_comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 126, &#x27;column&#x27;: 21}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/prod.lean&#x27;, &#x27;line&#x27;: 33, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 28, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {A : Type ?l_1} [𝒜 : category_theory.category.{?l_2 ?l_1} A] {B : Type ?l_3} [ℬ : category_theory.category.{?l_4 ?l_3} B] {C : Type ?l_5} [𝒞 : category_theory.category.{?l_6 ?l_5} C] {D : Type ?l_7} [𝒟 : category_theory.category.{?l_8 ?l_7} D] (F : @category_theory.functor.{?l_2 ?l_4 ?l_1 ?l_3} A 𝒜 B ℬ) (G : @category_theory.functor.{?l_6 ?l_8 ?l_5 ?l_7} C 𝒞 D 𝒟) (_x _x_1 : prod.{?l_1 ?l_5} A C) (f : @category_theory.has_hom.hom.{(max ?l_2 ?l_6) (max ?l_1 ?l_5)} (prod.{?l_1 ?l_5} A C) (@category_theory.category_struct.to_has_hom.{(max ?l_2 ?l_6) (max ?l_1 ?l_5)} (prod.{?l_1 ?l_5} A C) (@category_theory.category.to_category_struct.{(max ?l_2 ?l_6) (max ?l_1 ?l_5)} (prod.{?l_1 ?l_5} A C) (@category_theory.prod.{?l_2 ?l_6 ?l_1 ?l_5} A 𝒜 C 𝒞))) _x _x_1), @eq.{(max (?l_4+1) (?l_8+1))} (prod.{?l_4 ?l_8} (@category_theory.has_hom.hom.{?l_4 ?l_3} B (@category_theory.category_struct.to_has_hom.{?l_4 ?l_3} B (@category_theory.category.to_category_struct.{?l_4 ?l_3} B ℬ)) (@prod.fst.{?l_3 ?l_7} B D (@prod.mk.{?l_3 ?l_7} B D (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} A 𝒜 B ℬ F (@prod.fst.{?l_1 ?l_5} A C _x)) (@category_theory.functor.obj.{?l_6 ?l_8 ?l_5 ?l_7} C 𝒞 D 𝒟 G (@prod.snd.{?l_1 ?l_5} A C _x)))) (@prod.fst.{?l_3 ?l_7} B D (@prod.mk.{?l_3 ?l_7} B D (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} A 𝒜 B ℬ F (@prod.fst.{?l_1 ?l_5} A C _x_1)) (@category_theory.functor.obj.{?l_6 ?l_8 ?l_5 ?l_7} C 𝒞 D 𝒟 G (@prod.snd.{?l_1 ?l_5} A C _x_1))))) (@category_theory.has_hom.hom.{?l_8 ?l_7} D (@category_theory.category_struct.to_has_hom.{?l_8 ?l_7} D (@category_theory.category.to_category_struct.{?l_8 ?l_7} D 𝒟)) (@prod.snd.{?l_3 ?l_7} B D (@prod.mk.{?l_3 ?l_7} B D (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} A 𝒜 B ℬ F (@prod.fst.{?l_1 ?l_5} A C _x)) (@category_theory.functor.obj.{?l_6 ?l_8 ?l_5 ?l_7} C 𝒞 D 𝒟 G (@prod.snd.{?l_1 ?l_5} A C _x)))) (@prod.snd.{?l_3 ?l_7} B D (@prod.mk.{?l_3 ?l_7} B D (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} A 𝒜 B ℬ F (@prod.fst.{?l_1 ?l_5} A C _x_1)) (@category_theory.functor.obj.{?l_6 ?l_8 ?l_5 ?l_7} C 𝒞 D 𝒟 G (@prod.snd.{?l_1 ?l_5} A C _x_1)))))) (@category_theory.functor.map.{(max ?l_2 ?l_6) (max ?l_4 ?l_8) (max ?l_1 ?l_5) (max ?l_3 ?l_7)} (prod.{?l_1 ?l_5} A C) (@category_theory.prod.{?l_2 ?l_6 ?l_1 ?l_5} A 𝒜 C 𝒞) (prod.{?l_3 ?l_7} B D) (@category_theory.prod.{?l_4 ?l_8 ?l_3 ?l_7} B ℬ D 𝒟) (@category_theory.functor.prod.{?l_2 ?l_4 ?l_6 ?l_8 ?l_1 ?l_3 ?l_5 ?l_7} A 𝒜 B ℬ C 𝒞 D 𝒟 F G) _x _x_1 f) (@prod.mk.{?l_4 ?l_8} (@category_theory.has_hom.hom.{?l_4 ?l_3} B (@category_theory.category_struct.to_has_hom.{?l_4 ?l_3} B (@category_theory.category.to_category_struct.{?l_4 ?l_3} B ℬ)) (@prod.fst.{?l_3 ?l_7} B D (@prod.mk.{?l_3 ?l_7} B D (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} A 𝒜 B ℬ F (@prod.fst.{?l_1 ?l_5} A C _x)) (@category_theory.functor.obj.{?l_6 ?l_8 ?l_5 ?l_7} C 𝒞 D 𝒟 G (@prod.snd.{?l_1 ?l_5} A C _x)))) (@prod.fst.{?l_3 ?l_7} B D (@prod.mk.{?l_3 ?l_7} B D (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} A 𝒜 B ℬ F (@prod.fst.{?l_1 ?l_5} A C _x_1)) (@category_theory.functor.obj.{?l_6 ?l_8 ?l_5 ?l_7} C 𝒞 D 𝒟 G (@prod.snd.{?l_1 ?l_5} A C _x_1))))) (@category_theory.has_hom.hom.{?l_8 ?l_7} D (@category_theory.category_struct.to_has_hom.{?l_8 ?l_7} D (@category_theory.category.to_category_struct.{?l_8 ?l_7} D 𝒟)) (@prod.snd.{?l_3 ?l_7} B D (@prod.mk.{?l_3 ?l_7} B D (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} A 𝒜 B ℬ F (@prod.fst.{?l_1 ?l_5} A C _x)) (@category_theory.functor.obj.{?l_6 ?l_8 ?l_5 ?l_7} C 𝒞 D 𝒟 G (@prod.snd.{?l_1 ?l_5} A C _x)))) (@prod.snd.{?l_3 ?l_7} B D (@prod.mk.{?l_3 ?l_7} B D (@category_theory.functor.obj.{?l_2 ?l_4 ?l_1 ?l_3} A 𝒜 B ℬ F (@prod.fst.{?l_1 ?l_5} A C _x_1)) (@category_theory.functor.obj.{?l_6 ?l_8 ?l_5 ?l_7} C 𝒞 D 𝒟 G (@prod.snd.{?l_1 ?l_5} A C _x_1))))) (@category_theory.functor.map.{?l_2 ?l_4 ?l_1 ?l_3} A 𝒜 B ℬ F (@prod.fst.{?l_1 ?l_5} A C _x) (@prod.fst.{?l_1 ?l_5} A C _x_1) (@prod.fst.{?l_2 ?l_6} (@category_theory.has_hom.hom.{?l_2 ?l_1} A (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} A (@category_theory.category.to_category_struct.{?l_2 ?l_1} A 𝒜)) (@prod.fst.{?l_1 ?l_5} A C _x) (@prod.fst.{?l_1 ?l_5} A C _x_1)) (@category_theory.has_hom.hom.{?l_6 ?l_5} C (@category_theory.category_struct.to_has_hom.{?l_6 ?l_5} C (@category_theory.category.to_category_struct.{?l_6 ?l_5} C 𝒞)) (@prod.snd.{?l_1 ?l_5} A C _x) (@prod.snd.{?l_1 ?l_5} A C _x_1)) f)) (@category_theory.functor.map.{?l_6 ?l_8 ?l_5 ?l_7} C 𝒞 D 𝒟 G (@prod.snd.{?l_1 ?l_5} A C _x) (@prod.snd.{?l_1 ?l_5} A C _x_1) (@prod.snd.{?l_2 ?l_6} (@category_theory.has_hom.hom.{?l_2 ?l_1} A (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} A (@category_theory.category.to_category_struct.{?l_2 ?l_1} A 𝒜)) (@prod.fst.{?l_1 ?l_5} A C _x) (@prod.fst.{?l_1 ?l_5} A C _x_1)) (@category_theory.has_hom.hom.{?l_6 ?l_5} C (@category_theory.category_struct.to_has_hom.{?l_6 ?l_5} C (@category_theory.category.to_category_struct.{?l_6 ?l_5} C 𝒞)) (@prod.snd.{?l_1 ?l_5} A C _x) (@prod.snd.{?l_1 ?l_5} A C _x_1)) f)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {a₁ a₂ : α} {b₁ b₂ : β}, iff (@eq.{(max (?l_1+1) (?l_2+1))} (prod.{?l_1 ?l_2} α β) (@prod.mk.{?l_1 ?l_2} α β a₁ b₁) (@prod.mk.{?l_1 ?l_2} α β a₂ b₂)) (and (@eq.{?l_1+1} α a₁ a₂) (@eq.{?l_2+1} β b₁ b₂))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (C : Type ?l_1) [𝒞 : category_theory.category.{?l_2 ?l_1} C] (D : Type ?l_3) [𝒟 : category_theory.category.{?l_4 ?l_3} D] {P Q R : C} {S T U : D} (f : @category_theory.has_hom.hom.{(max ?l_2 ?l_4) (max ?l_1 ?l_3)} (prod.{?l_1 ?l_3} C D) (@category_theory.category_struct.to_has_hom.{(max ?l_2 ?l_4) (max ?l_1 ?l_3)} (prod.{?l_1 ?l_3} C D) (@category_theory.category.to_category_struct.{(max ?l_2 ?l_4) (max ?l_1 ?l_3)} (prod.{?l_1 ?l_3} C D) (@category_theory.prod.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟))) (@prod.mk.{?l_1 ?l_3} C D P S) (@prod.mk.{?l_1 ?l_3} C D Q T)) (g : @category_theory.has_hom.hom.{(max ?l_2 ?l_4) (max ?l_1 ?l_3)} (prod.{?l_1 ?l_3} C D) (@category_theory.category_struct.to_has_hom.{(max ?l_2 ?l_4) (max ?l_1 ?l_3)} (prod.{?l_1 ?l_3} C D) (@category_theory.category.to_category_struct.{(max ?l_2 ?l_4) (max ?l_1 ?l_3)} (prod.{?l_1 ?l_3} C D) (@category_theory.prod.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟))) (@prod.mk.{?l_1 ?l_3} C D Q T) (@prod.mk.{?l_1 ?l_3} C D R U)), @eq.{(max ?l_2 ?l_4)+1} (@category_theory.has_hom.hom.{(max ?l_2 ?l_4) (max ?l_1 ?l_3)} (prod.{?l_1 ?l_3} C D) (@category_theory.category_struct.to_has_hom.{(max ?l_2 ?l_4) (max ?l_1 ?l_3)} (prod.{?l_1 ?l_3} C D) (@category_theory.category.to_category_struct.{(max ?l_2 ?l_4) (max ?l_1 ?l_3)} (prod.{?l_1 ?l_3} C D) (@category_theory.prod.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟))) (@prod.mk.{?l_1 ?l_3} C D P S) (@prod.mk.{?l_1 ?l_3} C D R U)) (@category_theory.category_struct.comp.{(max ?l_2 ?l_4) (max ?l_1 ?l_3)} (prod.{?l_1 ?l_3} C D) (@category_theory.category.to_category_struct.{(max ?l_2 ?l_4) (max ?l_1 ?l_3)} (prod.{?l_1 ?l_3} C D) (@category_theory.prod.{?l_2 ?l_4 ?l_1 ?l_3} C 𝒞 D 𝒟)) (@prod.mk.{?l_1 ?l_3} C D P S) (@prod.mk.{?l_1 ?l_3} C D Q T) (@prod.mk.{?l_1 ?l_3} C D R U) f g) (@prod.mk.{?l_2 ?l_4} (@category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞)) (@prod.fst.{?l_1 ?l_3} C D (@prod.mk.{?l_1 ?l_3} C D P S)) (@prod.fst.{?l_1 ?l_3} C D (@prod.mk.{?l_1 ?l_3} C D R U))) (@category_theory.has_hom.hom.{?l_4 ?l_3} D (@category_theory.category_struct.to_has_hom.{?l_4 ?l_3} D (@category_theory.category.to_category_struct.{?l_4 ?l_3} D 𝒟)) (@prod.snd.{?l_1 ?l_3} C D (@prod.mk.{?l_1 ?l_3} C D P S)) (@prod.snd.{?l_1 ?l_3} C D (@prod.mk.{?l_1 ?l_3} C D R U))) (@category_theory.category_struct.comp.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞) (@prod.fst.{?l_1 ?l_3} C D (@prod.mk.{?l_1 ?l_3} C D P S)) (@prod.fst.{?l_1 ?l_3} C D (@prod.mk.{?l_1 ?l_3} C D Q T)) (@prod.fst.{?l_1 ?l_3} C D (@prod.mk.{?l_1 ?l_3} C D R U)) (@prod.fst.{?l_2 ?l_4} (@category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞)) (@prod.fst.{?l_1 ?l_3} C D (@prod.mk.{?l_1 ?l_3} C D P S)) (@prod.fst.{?l_1 ?l_3} C D (@prod.mk.{?l_1 ?l_3} C D Q T))) (@category_theory.has_hom.hom.{?l_4 ?l_3} D (@category_theory.category_struct.to_has_hom.{?l_4 ?l_3} D (@category_theory.category.to_category_struct.{?l_4 ?l_3} D 𝒟)) (@prod.snd.{?l_1 ?l_3} C D (@prod.mk.{?l_1 ?l_3} C D P S)) (@prod.snd.{?l_1 ?l_3} C D (@prod.mk.{?l_1 ?l_3} C D Q T))) f) (@prod.fst.{?l_2 ?l_4} (@category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞)) (@prod.fst.{?l_1 ?l_3} C D (@prod.mk.{?l_1 ?l_3} C D Q T)) (@prod.fst.{?l_1 ?l_3} C D (@prod.mk.{?l_1 ?l_3} C D R U))) (@category_theory.has_hom.hom.{?l_4 ?l_3} D (@category_theory.category_struct.to_has_hom.{?l_4 ?l_3} D (@category_theory.category.to_category_struct.{?l_4 ?l_3} D 𝒟)) (@prod.snd.{?l_1 ?l_3} C D (@prod.mk.{?l_1 ?l_3} C D Q T)) (@prod.snd.{?l_1 ?l_3} C D (@prod.mk.{?l_1 ?l_3} C D R U))) g)) (@category_theory.category_struct.comp.{?l_4 ?l_3} D (@category_theory.category.to_category_struct.{?l_4 ?l_3} D 𝒟) (@prod.snd.{?l_1 ?l_3} C D (@prod.mk.{?l_1 ?l_3} C D P S)) (@prod.snd.{?l_1 ?l_3} C D (@prod.mk.{?l_1 ?l_3} C D Q T)) (@prod.snd.{?l_1 ?l_3} C D (@prod.mk.{?l_1 ?l_3} C D R U)) (@prod.snd.{?l_2 ?l_4} (@category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞)) (@prod.fst.{?l_1 ?l_3} C D (@prod.mk.{?l_1 ?l_3} C D P S)) (@prod.fst.{?l_1 ?l_3} C D (@prod.mk.{?l_1 ?l_3} C D Q T))) (@category_theory.has_hom.hom.{?l_4 ?l_3} D (@category_theory.category_struct.to_has_hom.{?l_4 ?l_3} D (@category_theory.category.to_category_struct.{?l_4 ?l_3} D 𝒟)) (@prod.snd.{?l_1 ?l_3} C D (@prod.mk.{?l_1 ?l_3} C D P S)) (@prod.snd.{?l_1 ?l_3} C D (@prod.mk.{?l_1 ?l_3} C D Q T))) f) (@prod.snd.{?l_2 ?l_4} (@category_theory.has_hom.hom.{?l_2 ?l_1} C (@category_theory.category_struct.to_has_hom.{?l_2 ?l_1} C (@category_theory.category.to_category_struct.{?l_2 ?l_1} C 𝒞)) (@prod.fst.{?l_1 ?l_3} C D (@prod.mk.{?l_1 ?l_3} C D Q T)) (@prod.fst.{?l_1 ?l_3} C D (@prod.mk.{?l_1 ?l_3} C D R U))) (@category_theory.has_hom.hom.{?l_4 ?l_3} D (@category_theory.category_struct.to_has_hom.{?l_4 ?l_3} D (@category_theory.category.to_category_struct.{?l_4 ?l_3} D 𝒟)) (@prod.snd.{?l_1 ?l_3} C D (@prod.mk.{?l_1 ?l_3} C D Q T)) (@prod.snd.{?l_1 ?l_3} C D (@prod.mk.{?l_1 ?l_3} C D R U))) g)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='A : Type u₁,
𝒜 : category_theory.category.{v₁ u₁} A,
B : Type u₂,
ℬ : category_theory.category.{v₂ u₂} B,
C : Type u₃,
𝒞 : category_theory.category.{v₃ u₃} C,
D : Type u₄,
𝒟 : category_theory.category.{v₄ u₄} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ,
H I : @category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟,
α :
  @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
       (@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)
       (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)
          (@category_theory.functor.category.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)))
    F
    G,
β :
  @category_theory.has_hom.hom.{(max u₃ v₄) (max v₃ v₄ u₃ u₄)}
    (@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)
    (@category_theory.category_struct.to_has_hom.{(max u₃ v₄) (max v₃ v₄ u₃ u₄)}
       (@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)
       (@category_theory.category.to_category_struct.{(max u₃ v₄) (max v₃ v₄ u₃ u₄)}
          (@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)
          (@category_theory.functor.category.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)))
    H
    I,
X_fst : A,
X_snd : C,
Y_fst : A,
Y_snd : C,
f :
  @category_theory.has_hom.hom.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C)
    (@category_theory.category_struct.to_has_hom.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C)
       (@category_theory.category.to_category_struct.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)))
    (@prod.mk.{u₁ u₃} A C X_fst X_snd)
    (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)
⊢ @eq.{(max v₂ v₄)+1}
    (@category_theory.has_hom.hom.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
       (@category_theory.category_struct.to_has_hom.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
          (@category_theory.category.to_category_struct.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
             (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)))
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@prod.mk.{u₁ u₃} A C X_fst X_snd))
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
    (@category_theory.category_struct.comp.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
       (@category_theory.category.to_category_struct.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟))
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@prod.mk.{u₁ u₃} A C X_fst X_snd))
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))
       (@category_theory.functor.map.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@prod.mk.{u₁ u₃} A C X_fst X_snd)
          (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)
          f)
       (@prod.mk.{v₂ v₄}
          (@category_theory.has_hom.hom.{v₂ u₂} B
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} B
                (@category_theory.category.to_category_struct.{v₂ u₂} B ℬ))
             (@prod.fst.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F
                      H)
                   (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
             (@prod.fst.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G
                      I)
                   (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))))
          (@category_theory.has_hom.hom.{v₄ u₄} D
             (@category_theory.category_struct.to_has_hom.{v₄ u₄} D
                (@category_theory.category.to_category_struct.{v₄ u₄} D 𝒟))
             (@prod.snd.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F
                      H)
                   (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
             (@prod.snd.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G
                      I)
                   (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))))
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F G α
             (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
          (@category_theory.nat_trans.app.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H I β
             (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))))
    (@category_theory.category_struct.comp.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
       (@category_theory.category.to_category_struct.{(max v₂ v₄) (max u₂ u₄)} (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟))
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F H)
          (@prod.mk.{u₁ u₃} A C X_fst X_snd))
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@prod.mk.{u₁ u₃} A C X_fst X_snd))
       (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))
       (@prod.mk.{v₂ v₄}
          (@category_theory.has_hom.hom.{v₂ u₂} B
             (@category_theory.category_struct.to_has_hom.{v₂ u₂} B
                (@category_theory.category.to_category_struct.{v₂ u₂} B ℬ))
             (@prod.fst.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F
                      H)
                   (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
             (@prod.fst.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G
                      I)
                   (@prod.mk.{u₁ u₃} A C X_fst X_snd))))
          (@category_theory.has_hom.hom.{v₄ u₄} D
             (@category_theory.category_struct.to_has_hom.{v₄ u₄} D
                (@category_theory.category.to_category_struct.{v₄ u₄} D 𝒟))
             (@prod.snd.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 F
                      H)
                   (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
             (@prod.snd.{u₂ u₄} B D
                (@category_theory.functor.obj.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
                   (prod.{u₁ u₃} A C)
                   (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
                   (prod.{u₂ u₄} B D)
                   (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
                   (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G
                      I)
                   (@prod.mk.{u₁ u₃} A C X_fst X_snd))))
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F G α
             (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
          (@category_theory.nat_trans.app.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H I β
             (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))))
       (@category_theory.functor.map.{(max v₁ v₃) (max v₂ v₄) (max u₁ u₃) (max u₂ u₄)}
          (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)
          (prod.{u₂ u₄} B D)
          (@category_theory.prod.{v₂ v₄ u₂ u₄} B ℬ D 𝒟)
          (@category_theory.functor.prod.{v₁ v₂ v₃ v₄ u₁ u₂ u₃ u₄} A 𝒜 B ℬ C 𝒞 D 𝒟 G I)
          (@prod.mk.{u₁ u₃} A C X_fst X_snd)
          (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)
          f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='A : Type u₁,
𝒜 : category_theory.category.{v₁ u₁} A,
B : Type u₂,
ℬ : category_theory.category.{v₂ u₂} B,
C : Type u₃,
𝒞 : category_theory.category.{v₃ u₃} C,
D : Type u₄,
𝒟 : category_theory.category.{v₄ u₄} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ,
H I : @category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟,
α :
  @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
       (@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)
       (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)
          (@category_theory.functor.category.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)))
    F
    G,
β :
  @category_theory.has_hom.hom.{(max u₃ v₄) (max v₃ v₄ u₃ u₄)}
    (@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)
    (@category_theory.category_struct.to_has_hom.{(max u₃ v₄) (max v₃ v₄ u₃ u₄)}
       (@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)
       (@category_theory.category.to_category_struct.{(max u₃ v₄) (max v₃ v₄ u₃ u₄)}
          (@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)
          (@category_theory.functor.category.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)))
    H
    I,
X_fst : A,
X_snd : C,
Y_fst : A,
Y_snd : C,
f :
  @category_theory.has_hom.hom.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C)
    (@category_theory.category_struct.to_has_hom.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C)
       (@category_theory.category.to_category_struct.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)))
    (@prod.mk.{u₁ u₃} A C X_fst X_snd)
    (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)
⊢ and
    (@eq.{v₂+1}
       (@category_theory.has_hom.hom.{v₂ u₂} B
          (@category_theory.category_struct.to_has_hom.{v₂ u₂} B
             (@category_theory.category.to_category_struct.{v₂ u₂} B ℬ))
          (@prod.fst.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
          (@prod.fst.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))))))
       (@category_theory.category_struct.comp.{v₂ u₂} B
          (@category_theory.category.to_category_struct.{v₂ u₂} B ℬ)
          (@prod.fst.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
          (@prod.fst.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))))
          (@prod.fst.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))))
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
             (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
             (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))
             (@prod.fst.{v₁ v₃}
                (@category_theory.has_hom.hom.{v₁ u₁} A
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} A
                      (@category_theory.category.to_category_struct.{v₁ u₁} A 𝒜))
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.has_hom.hom.{v₃ u₃} C
                   (@category_theory.category_struct.to_has_hom.{v₃ u₃} C
                      (@category_theory.category.to_category_struct.{v₃ u₃} C 𝒞))
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                f))
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F G α
             (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))))
       (@category_theory.category_struct.comp.{v₂ u₂} B
          (@category_theory.category.to_category_struct.{v₂ u₂} B ℬ)
          (@prod.fst.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
          (@prod.fst.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
          (@prod.fst.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))))
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F G α
             (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
             (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
             (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))
             (@prod.fst.{v₁ v₃}
                (@category_theory.has_hom.hom.{v₁ u₁} A
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} A
                      (@category_theory.category.to_category_struct.{v₁ u₁} A 𝒜))
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.has_hom.hom.{v₃ u₃} C
                   (@category_theory.category_struct.to_has_hom.{v₃ u₃} C
                      (@category_theory.category.to_category_struct.{v₃ u₃} C 𝒞))
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                f))))
    (@eq.{v₄+1}
       (@category_theory.has_hom.hom.{v₄ u₄} D
          (@category_theory.category_struct.to_has_hom.{v₄ u₄} D
             (@category_theory.category.to_category_struct.{v₄ u₄} D 𝒟))
          (@prod.snd.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
          (@prod.snd.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))))))
       (@category_theory.category_struct.comp.{v₄ u₄} D
          (@category_theory.category.to_category_struct.{v₄ u₄} D 𝒟)
          (@prod.snd.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
          (@prod.snd.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))))
          (@prod.snd.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))))
          (@category_theory.functor.map.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
             (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
             (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))
             (@prod.snd.{v₁ v₃}
                (@category_theory.has_hom.hom.{v₁ u₁} A
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} A
                      (@category_theory.category.to_category_struct.{v₁ u₁} A 𝒜))
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.has_hom.hom.{v₃ u₃} C
                   (@category_theory.category_struct.to_has_hom.{v₃ u₃} C
                      (@category_theory.category.to_category_struct.{v₃ u₃} C 𝒞))
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                f))
          (@category_theory.nat_trans.app.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H I β
             (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))))
       (@category_theory.category_struct.comp.{v₄ u₄} D
          (@category_theory.category.to_category_struct.{v₄ u₄} D 𝒟)
          (@prod.snd.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
          (@prod.snd.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
          (@prod.snd.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))))
          (@category_theory.nat_trans.app.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H I β
             (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
          (@category_theory.functor.map.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
             (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
             (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))
             (@prod.snd.{v₁ v₃}
                (@category_theory.has_hom.hom.{v₁ u₁} A
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} A
                      (@category_theory.category.to_category_struct.{v₁ u₁} A 𝒜))
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.has_hom.hom.{v₃ u₃} C
                   (@category_theory.category_struct.to_has_hom.{v₃ u₃} C
                      (@category_theory.category.to_category_struct.{v₃ u₃} C 𝒞))
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                f))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145      split; rw naturality</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='category_theory.nat_trans.naturality'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/category_theory/natural_transformation.lean&#x27;}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {C : Type u₁} [𝒞 : category_theory.category.{v₁ u₁} C] {D : Type u₂} [𝒟 : category_theory.category.{v₂ u₂} D] {F G : @category_theory.functor.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟} (c : @category_theory.nat_trans.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G) ⦃X Y : C⦄ (f : @category_theory.has_hom.hom.{v₁ u₁} C (@category_theory.category_struct.to_has_hom.{v₁ u₁} C (@category_theory.category.to_category_struct.{v₁ u₁} C 𝒞)) X Y), @eq.{v₂+1} (@category_theory.has_hom.hom.{v₂ u₂} D (@category_theory.category_struct.to_has_hom.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟)) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y)) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F Y) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X Y f) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G c Y)) (@category_theory.category_struct.comp.{v₂ u₂} D (@category_theory.category.to_category_struct.{v₂ u₂} D 𝒟) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X) (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G Y) (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 F G c X) (@category_theory.functor.map.{v₁ v₂ u₁ u₂} C 𝒞 D 𝒟 G X Y f))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='A : Type u₁,
𝒜 : category_theory.category.{v₁ u₁} A,
B : Type u₂,
ℬ : category_theory.category.{v₂ u₂} B,
C : Type u₃,
𝒞 : category_theory.category.{v₃ u₃} C,
D : Type u₄,
𝒟 : category_theory.category.{v₄ u₄} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ,
H I : @category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟,
α :
  @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
       (@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)
       (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)
          (@category_theory.functor.category.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)))
    F
    G,
β :
  @category_theory.has_hom.hom.{(max u₃ v₄) (max v₃ v₄ u₃ u₄)}
    (@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)
    (@category_theory.category_struct.to_has_hom.{(max u₃ v₄) (max v₃ v₄ u₃ u₄)}
       (@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)
       (@category_theory.category.to_category_struct.{(max u₃ v₄) (max v₃ v₄ u₃ u₄)}
          (@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)
          (@category_theory.functor.category.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)))
    H
    I,
X_fst : A,
X_snd : C,
Y_fst : A,
Y_snd : C,
f :
  @category_theory.has_hom.hom.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C)
    (@category_theory.category_struct.to_has_hom.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C)
       (@category_theory.category.to_category_struct.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)))
    (@prod.mk.{u₁ u₃} A C X_fst X_snd)
    (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)
⊢ and
    (@eq.{v₂+1}
       (@category_theory.has_hom.hom.{v₂ u₂} B
          (@category_theory.category_struct.to_has_hom.{v₂ u₂} B
             (@category_theory.category.to_category_struct.{v₂ u₂} B ℬ))
          (@prod.fst.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
          (@prod.fst.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))))))
       (@category_theory.category_struct.comp.{v₂ u₂} B
          (@category_theory.category.to_category_struct.{v₂ u₂} B ℬ)
          (@prod.fst.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
          (@prod.fst.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))))
          (@prod.fst.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))))
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
             (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
             (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))
             (@prod.fst.{v₁ v₃}
                (@category_theory.has_hom.hom.{v₁ u₁} A
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} A
                      (@category_theory.category.to_category_struct.{v₁ u₁} A 𝒜))
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.has_hom.hom.{v₃ u₃} C
                   (@category_theory.category_struct.to_has_hom.{v₃ u₃} C
                      (@category_theory.category.to_category_struct.{v₃ u₃} C 𝒞))
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                f))
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F G α
             (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))))
       (@category_theory.category_struct.comp.{v₂ u₂} B
          (@category_theory.category.to_category_struct.{v₂ u₂} B ℬ)
          (@prod.fst.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
          (@prod.fst.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
          (@prod.fst.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))))
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F G α
             (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
             (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
             (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))
             (@prod.fst.{v₁ v₃}
                (@category_theory.has_hom.hom.{v₁ u₁} A
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} A
                      (@category_theory.category.to_category_struct.{v₁ u₁} A 𝒜))
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.has_hom.hom.{v₃ u₃} C
                   (@category_theory.category_struct.to_has_hom.{v₃ u₃} C
                      (@category_theory.category.to_category_struct.{v₃ u₃} C 𝒞))
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                f))))
    (@eq.{v₄+1}
       (@category_theory.has_hom.hom.{v₄ u₄} D
          (@category_theory.category_struct.to_has_hom.{v₄ u₄} D
             (@category_theory.category.to_category_struct.{v₄ u₄} D 𝒟))
          (@prod.snd.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
          (@prod.snd.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))))))
       (@category_theory.category_struct.comp.{v₄ u₄} D
          (@category_theory.category.to_category_struct.{v₄ u₄} D 𝒟)
          (@prod.snd.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
          (@prod.snd.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))))
          (@prod.snd.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))))
          (@category_theory.functor.map.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
             (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
             (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))
             (@prod.snd.{v₁ v₃}
                (@category_theory.has_hom.hom.{v₁ u₁} A
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} A
                      (@category_theory.category.to_category_struct.{v₁ u₁} A 𝒜))
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.has_hom.hom.{v₃ u₃} C
                   (@category_theory.category_struct.to_has_hom.{v₃ u₃} C
                      (@category_theory.category.to_category_struct.{v₃ u₃} C 𝒞))
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                f))
          (@category_theory.nat_trans.app.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H I β
             (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))))
       (@category_theory.category_struct.comp.{v₄ u₄} D
          (@category_theory.category.to_category_struct.{v₄ u₄} D 𝒟)
          (@prod.snd.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
          (@prod.snd.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
          (@prod.snd.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))))
          (@category_theory.nat_trans.app.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H I β
             (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
          (@category_theory.functor.map.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
             (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
             (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))
             (@prod.snd.{v₁ v₃}
                (@category_theory.has_hom.hom.{v₁ u₁} A
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} A
                      (@category_theory.category.to_category_struct.{v₁ u₁} A 𝒜))
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.has_hom.hom.{v₃ u₃} C
                   (@category_theory.category_struct.to_has_hom.{v₃ u₃} C
                      (@category_theory.category.to_category_struct.{v₃ u₃} C 𝒞))
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                f))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='A : Type u₁,
𝒜 : category_theory.category.{v₁ u₁} A,
B : Type u₂,
ℬ : category_theory.category.{v₂ u₂} B,
C : Type u₃,
𝒞 : category_theory.category.{v₃ u₃} C,
D : Type u₄,
𝒟 : category_theory.category.{v₄ u₄} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ,
H I : @category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟,
α :
  @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
       (@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)
       (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)
          (@category_theory.functor.category.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)))
    F
    G,
β :
  @category_theory.has_hom.hom.{(max u₃ v₄) (max v₃ v₄ u₃ u₄)}
    (@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)
    (@category_theory.category_struct.to_has_hom.{(max u₃ v₄) (max v₃ v₄ u₃ u₄)}
       (@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)
       (@category_theory.category.to_category_struct.{(max u₃ v₄) (max v₃ v₄ u₃ u₄)}
          (@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)
          (@category_theory.functor.category.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)))
    H
    I,
X_fst : A,
X_snd : C,
Y_fst : A,
Y_snd : C,
f :
  @category_theory.has_hom.hom.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C)
    (@category_theory.category_struct.to_has_hom.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C)
       (@category_theory.category.to_category_struct.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)))
    (@prod.mk.{u₁ u₃} A C X_fst X_snd)
    (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)
⊢ @eq.{v₂+1}
    (@category_theory.has_hom.hom.{v₂ u₂} B
       (@category_theory.category_struct.to_has_hom.{v₂ u₂} B
          (@category_theory.category.to_category_struct.{v₂ u₂} B ℬ))
       (@prod.fst.{u₂ u₄} B D
          (@prod.mk.{u₂ u₄} B D
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
             (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
       (@prod.fst.{u₂ u₄} B D
          (@prod.mk.{u₂ u₄} B D
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
             (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))))))
    (@category_theory.category_struct.comp.{v₂ u₂} B
       (@category_theory.category.to_category_struct.{v₂ u₂} B ℬ)
       (@prod.fst.{u₂ u₄} B D
          (@prod.mk.{u₂ u₄} B D
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
             (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
       (@prod.fst.{u₂ u₄} B D
          (@prod.mk.{u₂ u₄} B D
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
             (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))))
       (@prod.fst.{u₂ u₄} B D
          (@prod.mk.{u₂ u₄} B D
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
             (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))))
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
          (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
          (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))
          (@prod.fst.{v₁ v₃}
             (@category_theory.has_hom.hom.{v₁ u₁} A
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} A
                   (@category_theory.category.to_category_struct.{v₁ u₁} A 𝒜))
                (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
             (@category_theory.has_hom.hom.{v₃ u₃} C
                (@category_theory.category_struct.to_has_hom.{v₃ u₃} C
                   (@category_theory.category.to_category_struct.{v₃ u₃} C 𝒞))
                (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
             f))
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F G α
          (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))))
    (@category_theory.category_struct.comp.{v₂ u₂} B
       (@category_theory.category.to_category_struct.{v₂ u₂} B ℬ)
       (@prod.fst.{u₂ u₄} B D
          (@prod.mk.{u₂ u₄} B D
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
             (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
       (@prod.fst.{u₂ u₄} B D
          (@prod.mk.{u₂ u₄} B D
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
             (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
       (@prod.fst.{u₂ u₄} B D
          (@prod.mk.{u₂ u₄} B D
             (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
             (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))))
       (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F G α
          (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
       (@category_theory.functor.map.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
          (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
          (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))
          (@prod.fst.{v₁ v₃}
             (@category_theory.has_hom.hom.{v₁ u₁} A
                (@category_theory.category_struct.to_has_hom.{v₁ u₁} A
                   (@category_theory.category.to_category_struct.{v₁ u₁} A 𝒜))
                (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
             (@category_theory.has_hom.hom.{v₃ u₃} C
                (@category_theory.category_struct.to_has_hom.{v₃ u₃} C
                   (@category_theory.category.to_category_struct.{v₃ u₃} C 𝒞))
                (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
             f)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='A : Type u₁,
𝒜 : category_theory.category.{v₁ u₁} A,
B : Type u₂,
ℬ : category_theory.category.{v₂ u₂} B,
C : Type u₃,
𝒞 : category_theory.category.{v₃ u₃} C,
D : Type u₄,
𝒟 : category_theory.category.{v₄ u₄} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ,
H I : @category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟,
α :
  @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
       (@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)
       (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)
          (@category_theory.functor.category.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)))
    F
    G,
β :
  @category_theory.has_hom.hom.{(max u₃ v₄) (max v₃ v₄ u₃ u₄)}
    (@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)
    (@category_theory.category_struct.to_has_hom.{(max u₃ v₄) (max v₃ v₄ u₃ u₄)}
       (@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)
       (@category_theory.category.to_category_struct.{(max u₃ v₄) (max v₃ v₄ u₃ u₄)}
          (@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)
          (@category_theory.functor.category.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)))
    H
    I,
X_fst : A,
X_snd : C,
Y_fst : A,
Y_snd : C,
f :
  @category_theory.has_hom.hom.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C)
    (@category_theory.category_struct.to_has_hom.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C)
       (@category_theory.category.to_category_struct.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)))
    (@prod.mk.{u₁ u₃} A C X_fst X_snd)
    (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)
⊢ and
    (@eq.{v₂+1}
       (@category_theory.has_hom.hom.{v₂ u₂} B
          (@category_theory.category_struct.to_has_hom.{v₂ u₂} B
             (@category_theory.category.to_category_struct.{v₂ u₂} B ℬ))
          (@prod.fst.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
          (@prod.fst.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))))))
       (@category_theory.category_struct.comp.{v₂ u₂} B
          (@category_theory.category.to_category_struct.{v₂ u₂} B ℬ)
          (@prod.fst.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
          (@prod.fst.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))))
          (@prod.fst.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))))
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
             (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
             (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))
             (@prod.fst.{v₁ v₃}
                (@category_theory.has_hom.hom.{v₁ u₁} A
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} A
                      (@category_theory.category.to_category_struct.{v₁ u₁} A 𝒜))
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.has_hom.hom.{v₃ u₃} C
                   (@category_theory.category_struct.to_has_hom.{v₃ u₃} C
                      (@category_theory.category.to_category_struct.{v₃ u₃} C 𝒞))
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                f))
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F G α
             (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))))
       (@category_theory.category_struct.comp.{v₂ u₂} B
          (@category_theory.category.to_category_struct.{v₂ u₂} B ℬ)
          (@prod.fst.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
          (@prod.fst.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
          (@prod.fst.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))))
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F G α
             (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
             (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
             (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))
             (@prod.fst.{v₁ v₃}
                (@category_theory.has_hom.hom.{v₁ u₁} A
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} A
                      (@category_theory.category.to_category_struct.{v₁ u₁} A 𝒜))
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.has_hom.hom.{v₃ u₃} C
                   (@category_theory.category_struct.to_has_hom.{v₃ u₃} C
                      (@category_theory.category.to_category_struct.{v₃ u₃} C 𝒞))
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                f))))
    (@eq.{v₄+1}
       (@category_theory.has_hom.hom.{v₄ u₄} D
          (@category_theory.category_struct.to_has_hom.{v₄ u₄} D
             (@category_theory.category.to_category_struct.{v₄ u₄} D 𝒟))
          (@prod.snd.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
          (@prod.snd.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))))))
       (@category_theory.category_struct.comp.{v₄ u₄} D
          (@category_theory.category.to_category_struct.{v₄ u₄} D 𝒟)
          (@prod.snd.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
          (@prod.snd.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))))
          (@prod.snd.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))))
          (@category_theory.functor.map.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
             (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
             (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))
             (@prod.snd.{v₁ v₃}
                (@category_theory.has_hom.hom.{v₁ u₁} A
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} A
                      (@category_theory.category.to_category_struct.{v₁ u₁} A 𝒜))
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.has_hom.hom.{v₃ u₃} C
                   (@category_theory.category_struct.to_has_hom.{v₃ u₃} C
                      (@category_theory.category.to_category_struct.{v₃ u₃} C 𝒞))
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                f))
          (@category_theory.nat_trans.app.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H I β
             (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))))
       (@category_theory.category_struct.comp.{v₄ u₄} D
          (@category_theory.category.to_category_struct.{v₄ u₄} D 𝒟)
          (@prod.snd.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
          (@prod.snd.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
          (@prod.snd.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))))
          (@category_theory.nat_trans.app.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H I β
             (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
          (@category_theory.functor.map.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
             (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
             (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))
             (@prod.snd.{v₁ v₃}
                (@category_theory.has_hom.hom.{v₁ u₁} A
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} A
                      (@category_theory.category.to_category_struct.{v₁ u₁} A 𝒜))
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.has_hom.hom.{v₃ u₃} C
                   (@category_theory.category_struct.to_has_hom.{v₃ u₃} C
                      (@category_theory.category.to_category_struct.{v₃ u₃} C 𝒞))
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                f))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146    end }</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='A : Type u₁,
𝒜 : category_theory.category.{v₁ u₁} A,
B : Type u₂,
ℬ : category_theory.category.{v₂ u₂} B,
C : Type u₃,
𝒞 : category_theory.category.{v₃ u₃} C,
D : Type u₄,
𝒟 : category_theory.category.{v₄ u₄} D,
F G : @category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ,
H I : @category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟,
α :
  @category_theory.has_hom.hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
    (@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)
    (@category_theory.category_struct.to_has_hom.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
       (@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)
       (@category_theory.category.to_category_struct.{(max u₁ v₂) (max v₁ v₂ u₁ u₂)}
          (@category_theory.functor.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)
          (@category_theory.functor.category.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ)))
    F
    G,
β :
  @category_theory.has_hom.hom.{(max u₃ v₄) (max v₃ v₄ u₃ u₄)}
    (@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)
    (@category_theory.category_struct.to_has_hom.{(max u₃ v₄) (max v₃ v₄ u₃ u₄)}
       (@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)
       (@category_theory.category.to_category_struct.{(max u₃ v₄) (max v₃ v₄ u₃ u₄)}
          (@category_theory.functor.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)
          (@category_theory.functor.category.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟)))
    H
    I,
X_fst : A,
X_snd : C,
Y_fst : A,
Y_snd : C,
f :
  @category_theory.has_hom.hom.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C)
    (@category_theory.category_struct.to_has_hom.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C)
       (@category_theory.category.to_category_struct.{(max v₁ v₃) (max u₁ u₃)} (prod.{u₁ u₃} A C)
          (@category_theory.prod.{v₁ v₃ u₁ u₃} A 𝒜 C 𝒞)))
    (@prod.mk.{u₁ u₃} A C X_fst X_snd)
    (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)
⊢ and
    (@eq.{v₂+1}
       (@category_theory.has_hom.hom.{v₂ u₂} B
          (@category_theory.category_struct.to_has_hom.{v₂ u₂} B
             (@category_theory.category.to_category_struct.{v₂ u₂} B ℬ))
          (@prod.fst.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
          (@prod.fst.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))))))
       (@category_theory.category_struct.comp.{v₂ u₂} B
          (@category_theory.category.to_category_struct.{v₂ u₂} B ℬ)
          (@prod.fst.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
          (@prod.fst.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))))
          (@prod.fst.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))))
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
             (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
             (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))
             (@prod.fst.{v₁ v₃}
                (@category_theory.has_hom.hom.{v₁ u₁} A
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} A
                      (@category_theory.category.to_category_struct.{v₁ u₁} A 𝒜))
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.has_hom.hom.{v₃ u₃} C
                   (@category_theory.category_struct.to_has_hom.{v₃ u₃} C
                      (@category_theory.category.to_category_struct.{v₃ u₃} C 𝒞))
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                f))
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F G α
             (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))))
       (@category_theory.category_struct.comp.{v₂ u₂} B
          (@category_theory.category.to_category_struct.{v₂ u₂} B ℬ)
          (@prod.fst.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
          (@prod.fst.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
          (@prod.fst.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))))
          (@category_theory.nat_trans.app.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F G α
             (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
          (@category_theory.functor.map.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
             (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
             (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))
             (@prod.fst.{v₁ v₃}
                (@category_theory.has_hom.hom.{v₁ u₁} A
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} A
                      (@category_theory.category.to_category_struct.{v₁ u₁} A 𝒜))
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.has_hom.hom.{v₃ u₃} C
                   (@category_theory.category_struct.to_has_hom.{v₃ u₃} C
                      (@category_theory.category.to_category_struct.{v₃ u₃} C 𝒞))
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                f))))
    (@eq.{v₄+1}
       (@category_theory.has_hom.hom.{v₄ u₄} D
          (@category_theory.category_struct.to_has_hom.{v₄ u₄} D
             (@category_theory.category.to_category_struct.{v₄ u₄} D 𝒟))
          (@prod.snd.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
          (@prod.snd.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))))))
       (@category_theory.category_struct.comp.{v₄ u₄} D
          (@category_theory.category.to_category_struct.{v₄ u₄} D 𝒟)
          (@prod.snd.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
          (@prod.snd.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))))
          (@prod.snd.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))))
          (@category_theory.functor.map.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
             (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
             (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))
             (@prod.snd.{v₁ v₃}
                (@category_theory.has_hom.hom.{v₁ u₁} A
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} A
                      (@category_theory.category.to_category_struct.{v₁ u₁} A 𝒜))
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.has_hom.hom.{v₃ u₃} C
                   (@category_theory.category_struct.to_has_hom.{v₃ u₃} C
                      (@category_theory.category.to_category_struct.{v₃ u₃} C 𝒞))
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                f))
          (@category_theory.nat_trans.app.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H I β
             (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))))
       (@category_theory.category_struct.comp.{v₄ u₄} D
          (@category_theory.category.to_category_struct.{v₄ u₄} D 𝒟)
          (@prod.snd.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ F
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
          (@prod.snd.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))))
          (@prod.snd.{u₂ u₄} B D
             (@prod.mk.{u₂ u₄} B D
                (@category_theory.functor.obj.{v₁ v₂ u₁ u₂} A 𝒜 B ℬ G
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.functor.obj.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))))
          (@category_theory.nat_trans.app.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 H I β
             (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd)))
          (@category_theory.functor.map.{v₃ v₄ u₃ u₄} C 𝒞 D 𝒟 I
             (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
             (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd))
             (@prod.snd.{v₁ v₃}
                (@category_theory.has_hom.hom.{v₁ u₁} A
                   (@category_theory.category_struct.to_has_hom.{v₁ u₁} A
                      (@category_theory.category.to_category_struct.{v₁ u₁} A 𝒜))
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                   (@prod.fst.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                (@category_theory.has_hom.hom.{v₃ u₃} C
                   (@category_theory.category_struct.to_has_hom.{v₃ u₃} C
                      (@category_theory.category.to_category_struct.{v₃ u₃} C 𝒞))
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C X_fst X_snd))
                   (@prod.snd.{u₁ u₃} A C (@prod.mk.{u₁ u₃} A C Y_fst Y_snd)))
                f))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148  /- Again, it is inadvisable in Lean 3 to setup a notation `α × β`;</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149     use instead `α.prod β` or `nat_trans.prod α β`. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151  end nat_trans</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153  end category_theory</code></pre>
</body>