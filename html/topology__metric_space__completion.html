<head>
<meta charset="UTF-8">
<link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&display=swap" rel="stylesheet">
</head>

<body>
<pre>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  1  /-</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  2  Copyright (c) 2019 Sébastien Gouëzel. All rights reserved.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  3  Released under Apache 2.0 license as described in the file LICENSE.</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  4  Author: Sébastien Gouëzel</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  5  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  6  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  7  import topology.uniform_space.completion topology.metric_space.isometry</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/isometry.lean&#x27;, &#x27;line&#x27;: 1, &#x27;column&#x27;: 0}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  8  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>  9  /-!</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 10  # The completion of a metric space</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 11  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 12  Completion of uniform spaces are already defined in `topology.uniform_space.completion`. We show</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 13  here that the uniform space completion of a metric space inherits a metric space structure,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 14  by extending the distance to the completion and checking that it is indeed a distance, and that</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 15  it defines the same uniformity as the already defined uniform structure on the completion</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 16  -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 17  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 18  open lattice set filter uniform_space uniform_space.completion</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 19  noncomputable theory</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 20  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 21  universes u</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 22  variables {α : Type u} [metric_space α]</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 23  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 24  namespace metric</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 25  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 26  /-- The distance on the completion is obtained by extending the distance on the original space,</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 27  by uniform continuity. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 28  instance : has_dist (completion α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='has_dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_space.completion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 322, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='green'><a title='Type u_1 → Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : uniform_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The distance function (given an ambient metric space on `α`), which returns
 a nonnegative real number `dist x y` given `x y : α`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Hausdorff completion of `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 29  ⟨completion.extension₂ dist⟩</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='uniform_space.completion.extension₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_dist.dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 544, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [_inst_1 : uniform_space.{u_1} α] {β : Type u_2} [_inst_2 : uniform_space.{u_2} β] {γ : Type u_3} [_inst_3 : uniform_space.{u_3} γ], (α → β → γ) → @uniform_space.completion.{u_1} α _inst_1 → @uniform_space.completion.{u_2} β _inst_2 → γ'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_dist.{u_1} α], α → α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 30  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 31  /-- The new distance is uniformly continuous. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 32  protected lemma completion.uniform_continuous_dist :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 33    uniform_continuous (λp:completion α × completion α, dist p.1 p.2) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='uniform_space.completion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='uniform_space.completion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_dist.dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 427, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 322, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 322, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} {β : Type u_2} [_inst_1 : uniform_space.{u_1} α] [_inst_2 : uniform_space.{u_2} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : uniform_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : uniform_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u_1} [c : has_dist.{u_1} α], α → α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                         </code><font color='orange'><a title='Hausdorff completion of `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Hausdorff completion of `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 34  uniform_continuous_extension₂ dist</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_space.completion.uniform_continuous_extension₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_dist.dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 555, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : uniform_space.{u} α] {β : Type u} [_inst_2 : uniform_space.{u} β] {γ : Type} [_inst_3 : uniform_space.{0} γ] (f : α → β → γ) [_inst_4 : @separated.{0} γ _inst_3] [_inst_5 : @complete_space.{0} γ _inst_3], @uniform_continuous₂.{u u 0} (@uniform_space.completion.{u} α _inst_1) (@uniform_space.completion.{u} β _inst_2) γ (@uniform_space.completion.uniform_space.{u} α _inst_1) (@uniform_space.completion.uniform_space.{u} β _inst_2) _inst_3 (@uniform_space.completion.extension₂.{u u 0} α _inst_1 β _inst_2 γ _inst_3 f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u} [c : has_dist.{u} α], α → α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 35  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 36  /-- The new distance is an extension of the original distance. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 37  protected lemma completion.dist_eq (x y : α) : dist (x : completion α) y = dist x y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_dist.dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='uniform_space.completion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_dist.dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                               </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 322, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} [c : has_dist.{u_1} α], α → α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : uniform_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_dist.{u_1} α], α → α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                         </code><font color='orange'><a title='Hausdorff completion of `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 38  completion.extension₂_coe_coe uniform_continuous_dist&#x27; _ _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='uniform_space.completion.extension₂_coe_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='uniform_continuous_dist&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 549, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 885, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : uniform_space.{u} α] {β : Type u} [_inst_2 : uniform_space.{u} β] {γ : Type} [_inst_3 : uniform_space.{0} γ] {f : α → β → γ} [_inst_4 : @separated.{0} γ _inst_3], @uniform_continuous.{u 0} (prod.{u u} α β) γ (@prod.uniform_space.{u u} α β _inst_1 _inst_2) _inst_3 (@function.uncurry&#x27;.{u u 1} α β γ f) → ∀ (a : α) (b : β), @eq.{1} γ (@uniform_space.completion.extension₂.{u u 0} α _inst_1 β _inst_2 γ _inst_3 f (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α _inst_1) (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α _inst_1) (@uniform_space.completion.has_coe_t.{u} α _inst_1)) a) (@coe.{u+1 u+1} β (@uniform_space.completion.{u} β _inst_2) (@coe_to_lift.{u+1 u+1} β (@uniform_space.completion.{u} β _inst_2) (@uniform_space.completion.has_coe_t.{u} β _inst_2)) b)) (f a b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : metric_space.{u} α], @uniform_continuous.{u 0} (prod.{u u} α α) real (@prod.uniform_space.{u u} α α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1) (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space) (λ (p : prod.{u u} α α), @has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) (@prod.fst.{u u} α α p) (@prod.snd.{u u} α α p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 39  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 40  /- Let us check that the new distance satisfies the axioms of a distance, by starting from the</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 41  properties on α and extending them to `completion α` by continuity. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 42  protected lemma completion.dist_self (x : completion α) : dist x x = 0 :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='blue'><a title='uniform_space.completion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_dist.dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 322, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : uniform_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} [c : has_dist.{u_1} α], α → α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                          </code><font color='orange'><a title='Hausdorff completion of `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 43  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @eq.{1} real
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       x)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 44    apply induction_on x,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='uniform_space.completion.induction_on'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 415, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : uniform_space.{u} α] {p : @uniform_space.completion.{u} α _inst_1 → Prop} (a : @uniform_space.completion.{u} α _inst_1), @is_closed.{u} (@uniform_space.completion.{u} α _inst_1) (@uniform_space.to_topological_space.{u} (@uniform_space.completion.{u} α _inst_1) (@uniform_space.completion.uniform_space.{u} α _inst_1)) (@set_of.{u} (@uniform_space.completion.{u} α _inst_1) (λ (a : @uniform_space.completion.{u} α _inst_1), p a)) → (∀ (a : α), p (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α _inst_1) (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α _inst_1) (@uniform_space.completion.has_coe_t.{u} α _inst_1)) a)) → p a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @eq.{1} real
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       x)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : metric_space.{u} α,
x : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @is_closed.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
    (@uniform_space.to_topological_space.{u}
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@set_of.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (λ (a : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
          @eq.{1} real
            (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@metric.has_dist.{u} α _inst_1)
               a
               a)
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))))

α : Type u,
_inst_1 : metric_space.{u} α,
x : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ ∀ (a : α),
    @eq.{1} real
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe_to_lift.{u+1 u+1} α
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            a)
         (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe_to_lift.{u+1 u+1} α
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            a))
      (@has_zero.zero.{0} real
         (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 45    { refine is_closed_eq _ continuous_const,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='is_closed_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='continuous_const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/separation.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 686, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β : Type u} [_inst_1 : topological_space.{0} α] [_inst_2 : topological_space.{u} β] [_inst_3 : @t2_space.{0} α _inst_1] {f g : β → α}, @continuous.{u 0} β α _inst_2 _inst_1 f → @continuous.{u 0} β α _inst_2 _inst_1 g → @is_closed.{u} β _inst_2 (@set_of.{u} β (λ (x : β), @eq.{1} α (f x) (g x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type} [_inst_1 : topological_space.{u} α] [_inst_2 : topological_space.{0} β] {b : β}, @continuous.{u 0} α β _inst_1 _inst_2 (λ (a : α), b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : metric_space.{u} α,
x : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @is_closed.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
    (@uniform_space.to_topological_space.{u}
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@set_of.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (λ (a : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
          @eq.{1} real
            (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@metric.has_dist.{u} α _inst_1)
               a
               a)
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))))

α : Type u,
_inst_1 : metric_space.{u} α,
x : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ ∀ (a : α),
    @eq.{1} real
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe_to_lift.{u+1 u+1} α
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            a)
         (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe_to_lift.{u+1 u+1} α
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            a))
      (@has_zero.zero.{0} real
         (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @is_closed.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
    (@uniform_space.to_topological_space.{u}
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@set_of.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (λ (a : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
          @eq.{1} real
            (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@metric.has_dist.{u} α _inst_1)
               a
               a)
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @continuous.{u 0} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) real
    (@uniform_space.to_topological_space.{u}
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (λ (a : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
       @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 46      exact (completion.uniform_continuous_dist.continuous.comp</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='metric.completion.uniform_continuous_dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : metric_space.{u} α], @uniform_continuous.{u 0} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) real (@prod.uniform_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space) (λ (p : prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))), @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) p) (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The new distance is uniformly continuous.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @continuous.{u 0} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) real
    (@uniform_space.to_topological_space.{u}
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (λ (a : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
       @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 47               (continuous.prod_mk continuous_id continuous_id) : _) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='continuous.prod_mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='continuous_id'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 121, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 654, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β γ : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : topological_space.{u} β] [_inst_3 : topological_space.{u} γ] {f : γ → α} {g : γ → β}, @continuous.{u u} γ α _inst_3 _inst_1 f → @continuous.{u u} γ β _inst_3 _inst_2 g → @continuous.{u u} γ (prod.{u u} α β) _inst_3 (@prod.topological_space.{u u} α β _inst_1 _inst_2) (λ (x : γ), @prod.mk.{u u} α β (f x) (g x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : topological_space.{u} α], @continuous.{u u} α α _inst_1 _inst_1 (@id.{u+1} α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @continuous.{u 0} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) real
    (@uniform_space.to_topological_space.{u}
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (λ (a : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
       @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ ∀ (a : α),
    @eq.{1} real
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe_to_lift.{u+1 u+1} α
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            a)
         (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe_to_lift.{u+1 u+1} α
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            a))
      (@has_zero.zero.{0} real
         (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 48    { assume a,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ ∀ (a : α),
    @eq.{1} real
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe_to_lift.{u+1 u+1} α
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            a)
         (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe_to_lift.{u+1 u+1} α
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            a))
      (@has_zero.zero.{0} real
         (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
a : α
⊢ @eq.{1} real
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          a)
       (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          a))
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 49      rw [completion.dist_eq, dist_self] }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='metric.completion.dist_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='dist_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 37, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 83, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : metric_space.{u} α] (x y : α), @eq.{1} real (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) x) (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) y)) (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : metric_space.{u} α] (x : α), @eq.{1} real (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x x) (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The new distance is an extension of the original distance.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
a : α
⊢ @eq.{1} real
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          a)
       (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          a))
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
a : α
⊢ @eq.{1} real (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a a)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
a : α
⊢ @eq.{1} real
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          a)
       (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          a))
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 50  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 51  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 52  protected lemma completion.dist_comm (x y : completion α) : dist x y = dist y x :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='blue'><a title='uniform_space.completion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_dist.dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_dist.dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 322, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : uniform_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} [c : has_dist.{u_1} α], α → α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_dist.{u_1} α], α → α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                            </code><font color='orange'><a title='Hausdorff completion of `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 53  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @eq.{1} real
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       y
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 54    apply induction_on₂ x y,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='uniform_space.completion.induction_on₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 420, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : uniform_space.{u} α] {β : Type u} [_inst_2 : uniform_space.{u} β] {p : @uniform_space.completion.{u} α _inst_1 → @uniform_space.completion.{u} β _inst_2 → Prop} (a : @uniform_space.completion.{u} α _inst_1) (b : @uniform_space.completion.{u} β _inst_2), @is_closed.{u} (prod.{u u} (@uniform_space.completion.{u} α _inst_1) (@uniform_space.completion.{u} β _inst_2)) (@prod.topological_space.{u u} (@uniform_space.completion.{u} α _inst_1) (@uniform_space.completion.{u} β _inst_2) (@uniform_space.to_topological_space.{u} (@uniform_space.completion.{u} α _inst_1) (@uniform_space.completion.uniform_space.{u} α _inst_1)) (@uniform_space.to_topological_space.{u} (@uniform_space.completion.{u} β _inst_2) (@uniform_space.completion.uniform_space.{u} β _inst_2))) (@set_of.{u} (prod.{u u} (@uniform_space.completion.{u} α _inst_1) (@uniform_space.completion.{u} β _inst_2)) (λ (x : prod.{u u} (@uniform_space.completion.{u} α _inst_1) (@uniform_space.completion.{u} β _inst_2)), p (@prod.fst.{u u} (@uniform_space.completion.{u} α _inst_1) (@uniform_space.completion.{u} β _inst_2) x) (@prod.snd.{u u} (@uniform_space.completion.{u} α _inst_1) (@uniform_space.completion.{u} β _inst_2) x))) → (∀ (a : α) (b : β), p (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α _inst_1) (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α _inst_1) (@uniform_space.completion.has_coe_t.{u} α _inst_1)) a) (@coe.{u+1 u+1} β (@uniform_space.completion.{u} β _inst_2) (@coe_to_lift.{u+1 u+1} β (@uniform_space.completion.{u} β _inst_2) (@uniform_space.completion.has_coe_t.{u} β _inst_2)) b)) → p a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @eq.{1} real
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       y
       x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : metric_space.{u} α,
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set_of.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (λ
        (x :
          prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
          @eq.{1} real
            (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@metric.has_dist.{u} α _inst_1)
               (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  x)
               (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  x))
            (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@metric.has_dist.{u} α _inst_1)
               (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  x)
               (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  x))))

α : Type u,
_inst_1 : metric_space.{u} α,
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ ∀ (a b : α),
    @eq.{1} real
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe_to_lift.{u+1 u+1} α
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            a)
         (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe_to_lift.{u+1 u+1} α
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            b))
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe_to_lift.{u+1 u+1} α
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            b)
         (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe_to_lift.{u+1 u+1} α
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 55    { refine is_closed_eq completion.uniform_continuous_dist.continuous _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='is_closed_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='metric.completion.uniform_continuous_dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/separation.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β : Type u} [_inst_1 : topological_space.{0} α] [_inst_2 : topological_space.{u} β] [_inst_3 : @t2_space.{0} α _inst_1] {f g : β → α}, @continuous.{u 0} β α _inst_2 _inst_1 f → @continuous.{u 0} β α _inst_2 _inst_1 g → @is_closed.{u} β _inst_2 (@set_of.{u} β (λ (x : β), @eq.{1} α (f x) (g x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : metric_space.{u} α], @uniform_continuous.{u 0} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) real (@prod.uniform_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space) (λ (p : prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))), @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) p) (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The new distance is uniformly continuous.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : metric_space.{u} α,
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set_of.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (λ
        (x :
          prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
          @eq.{1} real
            (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@metric.has_dist.{u} α _inst_1)
               (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  x)
               (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  x))
            (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@metric.has_dist.{u} α _inst_1)
               (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  x)
               (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  x))))

α : Type u,
_inst_1 : metric_space.{u} α,
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ ∀ (a b : α),
    @eq.{1} real
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe_to_lift.{u+1 u+1} α
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            a)
         (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe_to_lift.{u+1 u+1} α
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            b))
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe_to_lift.{u+1 u+1} α
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            b)
         (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe_to_lift.{u+1 u+1} α
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set_of.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (λ
        (x :
          prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
          @eq.{1} real
            (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@metric.has_dist.{u} α _inst_1)
               (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  x)
               (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  x))
            (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@metric.has_dist.{u} α _inst_1)
               (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  x)
               (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  x))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @continuous.{u 0}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    real
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (λ
     (x :
       prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
       @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            x)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 56      exact (completion.uniform_continuous_dist.continuous.comp continuous_swap : _) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='metric.completion.uniform_continuous_dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='continuous_swap'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 125, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : metric_space.{u} α], @uniform_continuous.{u 0} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) real (@prod.uniform_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space) (λ (p : prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))), @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) p) (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : topological_space.{u} β], @continuous.{u u} (prod.{u u} α β) (prod.{u u} β α) (@prod.topological_space.{u u} α β _inst_1 _inst_2) (@prod.topological_space.{u u} β α _inst_2 _inst_1) (@prod.swap.{u u} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The new distance is uniformly continuous.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @continuous.{u 0}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    real
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (λ
     (x :
       prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
       @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            x)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ ∀ (a b : α),
    @eq.{1} real
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe_to_lift.{u+1 u+1} α
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            a)
         (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe_to_lift.{u+1 u+1} α
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            b))
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe_to_lift.{u+1 u+1} α
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            b)
         (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe_to_lift.{u+1 u+1} α
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 57    { assume a b,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ ∀ (a b : α),
    @eq.{1} real
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe_to_lift.{u+1 u+1} α
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            a)
         (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe_to_lift.{u+1 u+1} α
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            b))
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe_to_lift.{u+1 u+1} α
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            b)
         (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe_to_lift.{u+1 u+1} α
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
a b : α
⊢ @eq.{1} real
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          a)
       (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          b))
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          b)
       (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 58      rw [completion.dist_eq, completion.dist_eq, dist_comm] }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='metric.completion.dist_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='metric.completion.dist_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='dist_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 37, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 37, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 88, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : metric_space.{u} α] (x y : α), @eq.{1} real (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) x) (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) y)) (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : metric_space.{u} α] (x y : α), @eq.{1} real (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) x) (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) y)) (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : metric_space.{u} α] (x y : α), @eq.{1} real (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y) (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) y x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The new distance is an extension of the original distance.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The new distance is an extension of the original distance.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
a b : α
⊢ @eq.{1} real
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          a)
       (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          b))
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          b)
       (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
a b : α
⊢ @eq.{1} real (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b)
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          b)
       (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
a b : α
⊢ @eq.{1} real (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b)
    (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
a b : α
⊢ @eq.{1} real
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          a)
       (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          b))
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          b)
       (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          a))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 59  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 60  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 61  protected lemma completion.dist_triangle (x y z : completion α) : dist x z ≤ dist x y + dist y z :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='blue'><a title='uniform_space.completion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='has_dist.dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_dist.dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_add.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_dist.dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 322, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 311, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : uniform_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='Π {α : Type u_1} [c : has_dist.{u_1} α], α → α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_dist.{u_1} α], α → α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_add.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u_1} [c : has_dist.{u_1} α], α → α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                  </code><font color='orange'><a title='Hausdorff completion of `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 62  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @has_le.le.{0} real real.has_le
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       z)
    (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
       (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@metric.has_dist.{u} α _inst_1)
          x
          y)
       (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@metric.has_dist.{u} α _inst_1)
          y
          z))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 63    apply induction_on₃ x y z,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='uniform_space.completion.induction_on₃'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 429, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : uniform_space.{u} α] {β : Type u} [_inst_2 : uniform_space.{u} β] {γ : Type u} [_inst_3 : uniform_space.{u} γ] {p : @uniform_space.completion.{u} α _inst_1 → @uniform_space.completion.{u} β _inst_2 → @uniform_space.completion.{u} γ _inst_3 → Prop} (a : @uniform_space.completion.{u} α _inst_1) (b : @uniform_space.completion.{u} β _inst_2) (c : @uniform_space.completion.{u} γ _inst_3), @is_closed.{u} (prod.{u u} (@uniform_space.completion.{u} α _inst_1) (prod.{u u} (@uniform_space.completion.{u} β _inst_2) (@uniform_space.completion.{u} γ _inst_3))) (@prod.topological_space.{u u} (@uniform_space.completion.{u} α _inst_1) (prod.{u u} (@uniform_space.completion.{u} β _inst_2) (@uniform_space.completion.{u} γ _inst_3)) (@uniform_space.to_topological_space.{u} (@uniform_space.completion.{u} α _inst_1) (@uniform_space.completion.uniform_space.{u} α _inst_1)) (@prod.topological_space.{u u} (@uniform_space.completion.{u} β _inst_2) (@uniform_space.completion.{u} γ _inst_3) (@uniform_space.to_topological_space.{u} (@uniform_space.completion.{u} β _inst_2) (@uniform_space.completion.uniform_space.{u} β _inst_2)) (@uniform_space.to_topological_space.{u} (@uniform_space.completion.{u} γ _inst_3) (@uniform_space.completion.uniform_space.{u} γ _inst_3)))) (@set_of.{u} (prod.{u u} (@uniform_space.completion.{u} α _inst_1) (prod.{u u} (@uniform_space.completion.{u} β _inst_2) (@uniform_space.completion.{u} γ _inst_3))) (λ (x : prod.{u u} (@uniform_space.completion.{u} α _inst_1) (prod.{u u} (@uniform_space.completion.{u} β _inst_2) (@uniform_space.completion.{u} γ _inst_3))), p (@prod.fst.{u u} (@uniform_space.completion.{u} α _inst_1) (prod.{u u} (@uniform_space.completion.{u} β _inst_2) (@uniform_space.completion.{u} γ _inst_3)) x) (@prod.fst.{u u} (@uniform_space.completion.{u} β _inst_2) (@uniform_space.completion.{u} γ _inst_3) (@prod.snd.{u u} (@uniform_space.completion.{u} α _inst_1) (prod.{u u} (@uniform_space.completion.{u} β _inst_2) (@uniform_space.completion.{u} γ _inst_3)) x)) (@prod.snd.{u u} (@uniform_space.completion.{u} β _inst_2) (@uniform_space.completion.{u} γ _inst_3) (@prod.snd.{u u} (@uniform_space.completion.{u} α _inst_1) (prod.{u u} (@uniform_space.completion.{u} β _inst_2) (@uniform_space.completion.{u} γ _inst_3)) x)))) → (∀ (a : α) (b : β) (c : γ), p (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α _inst_1) (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α _inst_1) (@uniform_space.completion.has_coe_t.{u} α _inst_1)) a) (@coe.{u+1 u+1} β (@uniform_space.completion.{u} β _inst_2) (@coe_to_lift.{u+1 u+1} β (@uniform_space.completion.{u} β _inst_2) (@uniform_space.completion.has_coe_t.{u} β _inst_2)) b) (@coe.{u+1 u+1} γ (@uniform_space.completion.{u} γ _inst_3) (@coe_to_lift.{u+1 u+1} γ (@uniform_space.completion.{u} γ _inst_3) (@uniform_space.completion.has_coe_t.{u} γ _inst_3)) c)) → p a b c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @has_le.le.{0} real real.has_le
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       z)
    (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
       (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@metric.has_dist.{u} α _inst_1)
          x
          y)
       (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@metric.has_dist.{u} α _inst_1)
          y
          z))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.topological_space.{u u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set_of.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (λ
        (x :
          prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
          @has_le.le.{0} real real.has_le
            (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@metric.has_dist.{u} α _inst_1)
               (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  x)
               (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                     x)))
            (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                     x)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x)))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))))))

α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ ∀ (a b c : α),
    @has_le.le.{0} real real.has_le
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe_to_lift.{u+1 u+1} α
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            a)
         (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe_to_lift.{u+1 u+1} α
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            c))
      (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@metric.has_dist.{u} α _inst_1)
            (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe_to_lift.{u+1 u+1} α
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               a)
            (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe_to_lift.{u+1 u+1} α
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               b))
         (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@metric.has_dist.{u} α _inst_1)
            (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe_to_lift.{u+1 u+1} α
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               b)
            (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe_to_lift.{u+1 u+1} α
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               c)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 64    { refine is_closed_le _ (continuous.add _ _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='is_closed_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='continuous.add'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/ordered.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/monoid.lean&#x27;, &#x27;line&#x27;: 42, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β : Type u} [_inst_1 : topological_space.{0} α] [_inst_2 : preorder.{0} α] [t : @order_closed_topology.{0} α _inst_1 _inst_2] [_inst_3 : topological_space.{u} β] {f g : β → α}, @continuous.{u 0} β α _inst_3 _inst_1 f → @continuous.{u 0} β α _inst_3 _inst_1 g → @is_closed.{u} β _inst_3 (@set_of.{u} β (λ (b : β), @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_2) (f b) (g b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} {β : Type u} [_inst_1 : topological_space.{0} α] [_inst_2 : add_monoid.{0} α] [_inst_3 : @topological_add_monoid.{0} α _inst_1 _inst_2] [_inst_4 : topological_space.{u} β] {f g : β → α}, @continuous.{u 0} β α _inst_4 _inst_1 f → @continuous.{u 0} β α _inst_4 _inst_1 g → @continuous.{u 0} β α _inst_4 _inst_1 (λ (x : β), @has_add.add.{0} α (@add_semigroup.to_has_add.{0} α (@add_monoid.to_add_semigroup.{0} α _inst_2)) (f x) (g x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.topological_space.{u u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set_of.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (λ
        (x :
          prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
          @has_le.le.{0} real real.has_le
            (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@metric.has_dist.{u} α _inst_1)
               (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  x)
               (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                     x)))
            (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                     x)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x)))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))))))

α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ ∀ (a b c : α),
    @has_le.le.{0} real real.has_le
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe_to_lift.{u+1 u+1} α
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            a)
         (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe_to_lift.{u+1 u+1} α
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            c))
      (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@metric.has_dist.{u} α _inst_1)
            (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe_to_lift.{u+1 u+1} α
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               a)
            (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe_to_lift.{u+1 u+1} α
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               b))
         (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@metric.has_dist.{u} α _inst_1)
            (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe_to_lift.{u+1 u+1} α
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               b)
            (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe_to_lift.{u+1 u+1} α
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               c)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.topological_space.{u u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set_of.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (λ
        (x :
          prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
          @has_le.le.{0} real real.has_le
            (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@metric.has_dist.{u} α _inst_1)
               (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  x)
               (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                     x)))
            (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                     x)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x)))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @continuous.{u 0}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    real
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.topological_space.{u u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (λ
     (x :
       prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
       @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            x)
         (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               x)))

α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @continuous.{u 0}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    real
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.topological_space.{u u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (λ
     (x :
       prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
       @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            x)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               x)))

α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @continuous.{u 0}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    real
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.topological_space.{u u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (λ
     (x :
       prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
       @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               x))
         (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 65      { have : continuous (λp : completion α × completion α × completion α, (p.1, p.2.2)) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='uniform_space.completion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 644, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 322, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : topological_space.{u} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u) [_inst_1 : uniform_space.{u} α], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A function between topological spaces is continuous if the preimage
 of every open set is open.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Hausdorff completion of `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @continuous.{u 0}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    real
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.topological_space.{u u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (λ
     (x :
       prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
       @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            x)
         (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               x)))

α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @continuous.{u 0}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    real
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.topological_space.{u u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (λ
     (x :
       prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
       @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            x)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               x)))

α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @continuous.{u 0}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    real
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.topological_space.{u u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (λ
     (x :
       prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
       @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               x))
         (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @continuous.{u 0}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    real
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.topological_space.{u u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (λ
     (x :
       prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
       @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            x)
         (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 66          continuous.prod_mk continuous_fst (continuous.comp continuous_snd continuous_snd),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='continuous.prod_mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='continuous_fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='continuous.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='continuous_snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 121, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 115, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 657, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 118, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β γ : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : topological_space.{u} β] [_inst_3 : topological_space.{u} γ] {f : γ → α} {g : γ → β}, @continuous.{u u} γ α _inst_3 _inst_1 f → @continuous.{u u} γ β _inst_3 _inst_2 g → @continuous.{u u} γ (prod.{u u} α β) _inst_3 (@prod.topological_space.{u u} α β _inst_1 _inst_2) (λ (x : γ), @prod.mk.{u u} α β (f x) (g x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : topological_space.{u} β], @continuous.{u u} (prod.{u u} α β) α (@prod.topological_space.{u u} α β _inst_1 _inst_2) _inst_1 (@prod.fst.{u u} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β γ : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : topological_space.{u} β] [_inst_3 : topological_space.{u} γ] {g : β → γ} {f : α → β}, @continuous.{u u} β γ _inst_2 _inst_3 g → @continuous.{u u} α β _inst_1 _inst_2 f → @continuous.{u u} α γ _inst_1 _inst_3 (@function.comp.{u+1 u+1 u+1} α β γ g f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : topological_space.{u} β], @continuous.{u u} (prod.{u u} α β) β (@prod.topological_space.{u u} α β _inst_1 _inst_2) _inst_2 (@prod.snd.{u u} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @continuous.{u 0}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    real
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.topological_space.{u u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (λ
     (x :
       prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
       @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            x)
         (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
this :
  @continuous.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.topological_space.{u u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (λ
     (p :
       prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
       @prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            p)
         (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               p)))
⊢ @continuous.{u 0}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    real
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.topological_space.{u u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (λ
     (x :
       prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
       @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            x)
         (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 67        exact (completion.uniform_continuous_dist.continuous.comp this : _) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='metric.completion.uniform_continuous_dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : metric_space.{u} α], @uniform_continuous.{u 0} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) real (@prod.uniform_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space) (λ (p : prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))), @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) p) (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@continuous.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@uniform_space.to_topological_space.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.to_topological_space.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@uniform_space.to_topological_space.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))) (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.to_topological_space.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@uniform_space.to_topological_space.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (λ (p : prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))), @prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) p) (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) p)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The new distance is uniformly continuous.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
this :
  @continuous.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.topological_space.{u u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (λ
     (p :
       prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
       @prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            p)
         (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               p)))
⊢ @continuous.{u 0}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    real
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.topological_space.{u u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (λ
     (x :
       prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
       @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            x)
         (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @continuous.{u 0}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    real
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.topological_space.{u u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (λ
     (x :
       prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
       @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            x)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               x)))

α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @continuous.{u 0}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    real
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.topological_space.{u u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (λ
     (x :
       prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
       @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               x))
         (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 68      { have : continuous (λp : completion α × completion α × completion α, (p.1, p.2.1)) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='uniform_space.completion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 644, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 322, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : topological_space.{u} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u) [_inst_1 : uniform_space.{u} α], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A function between topological spaces is continuous if the preimage
 of every open set is open.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Hausdorff completion of `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @continuous.{u 0}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    real
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.topological_space.{u u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (λ
     (x :
       prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
       @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            x)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               x)))

α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @continuous.{u 0}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    real
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.topological_space.{u u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (λ
     (x :
       prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
       @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               x))
         (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @continuous.{u 0}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    real
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.topological_space.{u u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (λ
     (x :
       prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
       @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            x)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 69          continuous.prod_mk continuous_fst (continuous_fst.comp continuous_snd),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='continuous.prod_mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='continuous_fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='continuous_snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 121, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 115, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 118, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β γ : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : topological_space.{u} β] [_inst_3 : topological_space.{u} γ] {f : γ → α} {g : γ → β}, @continuous.{u u} γ α _inst_3 _inst_1 f → @continuous.{u u} γ β _inst_3 _inst_2 g → @continuous.{u u} γ (prod.{u u} α β) _inst_3 (@prod.topological_space.{u u} α β _inst_1 _inst_2) (λ (x : γ), @prod.mk.{u u} α β (f x) (g x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : topological_space.{u} β], @continuous.{u u} (prod.{u u} α β) α (@prod.topological_space.{u u} α β _inst_1 _inst_2) _inst_1 (@prod.fst.{u u} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : topological_space.{u} β], @continuous.{u u} (prod.{u u} α β) β (@prod.topological_space.{u u} α β _inst_1 _inst_2) _inst_2 (@prod.snd.{u u} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @continuous.{u 0}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    real
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.topological_space.{u u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (λ
     (x :
       prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
       @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            x)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
this :
  @continuous.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.topological_space.{u u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (λ
     (p :
       prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
       @prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            p)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               p)))
⊢ @continuous.{u 0}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    real
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.topological_space.{u u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (λ
     (x :
       prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
       @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            x)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 70        exact (completion.uniform_continuous_dist.continuous.comp this : _) },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='metric.completion.uniform_continuous_dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : metric_space.{u} α], @uniform_continuous.{u 0} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) real (@prod.uniform_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space) (λ (p : prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))), @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) p) (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@continuous.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@uniform_space.to_topological_space.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.to_topological_space.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@uniform_space.to_topological_space.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))) (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.to_topological_space.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@uniform_space.to_topological_space.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (λ (p : prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))), @prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) p) (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) p)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The new distance is uniformly continuous.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
this :
  @continuous.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.topological_space.{u u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (λ
     (p :
       prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
       @prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            p)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               p)))
⊢ @continuous.{u 0}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    real
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.topological_space.{u u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (λ
     (x :
       prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
       @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            x)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @continuous.{u 0}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    real
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.topological_space.{u u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (λ
     (x :
       prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
       @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               x))
         (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 71      { have : continuous (λp : completion α × completion α × completion α, (p.2.1, p.2.2)) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='continuous'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                     </code><font color='blue'><a title='uniform_space.completion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 644, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 322, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : topological_space.{u} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u) [_inst_1 : uniform_space.{u} α], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='A function between topological spaces is continuous if the preimage
 of every open set is open.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Hausdorff completion of `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @continuous.{u 0}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    real
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.topological_space.{u u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (λ
     (x :
       prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
       @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               x))
         (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 72          continuous.prod_mk (continuous_fst.comp continuous_snd)</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='continuous.prod_mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='continuous_fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 121, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 115, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β γ : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : topological_space.{u} β] [_inst_3 : topological_space.{u} γ] {f : γ → α} {g : γ → β}, @continuous.{u u} γ α _inst_3 _inst_1 f → @continuous.{u u} γ β _inst_3 _inst_2 g → @continuous.{u u} γ (prod.{u u} α β) _inst_3 (@prod.topological_space.{u u} α β _inst_1 _inst_2) (λ (x : γ), @prod.mk.{u u} α β (f x) (g x))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : topological_space.{u} β], @continuous.{u u} (prod.{u u} α β) α (@prod.topological_space.{u u} α β _inst_1 _inst_2) _inst_1 (@prod.fst.{u u} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @continuous.{u 0}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    real
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.topological_space.{u u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (λ
     (x :
       prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
       @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               x))
         (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 73                             (continuous.comp continuous_snd continuous_snd),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='blue'><a title='continuous.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='continuous_snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 657, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/constructions.lean&#x27;, &#x27;line&#x27;: 118, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β γ : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : topological_space.{u} β] [_inst_3 : topological_space.{u} γ] {g : β → γ} {f : α → β}, @continuous.{u u} β γ _inst_2 _inst_3 g → @continuous.{u u} α β _inst_1 _inst_2 f → @continuous.{u u} α γ _inst_1 _inst_3 (@function.comp.{u+1 u+1 u+1} α β γ g f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : topological_space.{u} α] [_inst_2 : topological_space.{u} β], @continuous.{u u} (prod.{u u} α β) β (@prod.topological_space.{u u} α β _inst_1 _inst_2) _inst_2 (@prod.snd.{u u} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ @continuous.{u 0}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    real
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.topological_space.{u u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (λ
     (x :
       prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
       @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               x))
         (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
this :
  @continuous.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.topological_space.{u u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (λ
     (p :
       prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
       @prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               p))
         (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               p)))
⊢ @continuous.{u 0}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    real
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.topological_space.{u u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (λ
     (x :
       prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
       @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               x))
         (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 74        exact (continuous.comp completion.uniform_continuous_dist.continuous this : _) } },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='continuous.comp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='metric.completion.uniform_continuous_dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 657, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α β : Type u} {γ : Type} [_inst_1 : topological_space.{u} α] [_inst_2 : topological_space.{u} β] [_inst_3 : topological_space.{0} γ] {g : β → γ} {f : α → β}, @continuous.{u 0} β γ _inst_2 _inst_3 g → @continuous.{u u} α β _inst_1 _inst_2 f → @continuous.{u 0} α γ _inst_1 _inst_3 (@function.comp.{u+1 u+1 1} α β γ g f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : metric_space.{u} α], @uniform_continuous.{u 0} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) real (@prod.uniform_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space) (λ (p : prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))), @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) p) (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@continuous.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@uniform_space.to_topological_space.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.to_topological_space.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@uniform_space.to_topological_space.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))) (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.to_topological_space.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@uniform_space.to_topological_space.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (λ (p : prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))), @prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) p)) (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) p)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The new distance is uniformly continuous.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
this :
  @continuous.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.topological_space.{u u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (λ
     (p :
       prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
       @prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               p))
         (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               p)))
⊢ @continuous.{u 0}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    real
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.topological_space.{u u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (@uniform_space.to_topological_space.{u}
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@uniform_space.to_topological_space.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
    (λ
     (x :
       prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
       @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               x))
         (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               x)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ ∀ (a b c : α),
    @has_le.le.{0} real real.has_le
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe_to_lift.{u+1 u+1} α
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            a)
         (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe_to_lift.{u+1 u+1} α
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            c))
      (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@metric.has_dist.{u} α _inst_1)
            (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe_to_lift.{u+1 u+1} α
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               a)
            (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe_to_lift.{u+1 u+1} α
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               b))
         (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@metric.has_dist.{u} α _inst_1)
            (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe_to_lift.{u+1 u+1} α
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               b)
            (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe_to_lift.{u+1 u+1} α
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               c)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 75    { assume a b c,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)
⊢ ∀ (a b c : α),
    @has_le.le.{0} real real.has_le
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe_to_lift.{u+1 u+1} α
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            a)
         (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe_to_lift.{u+1 u+1} α
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            c))
      (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
         (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@metric.has_dist.{u} α _inst_1)
            (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe_to_lift.{u+1 u+1} α
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               a)
            (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe_to_lift.{u+1 u+1} α
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               b))
         (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@metric.has_dist.{u} α _inst_1)
            (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe_to_lift.{u+1 u+1} α
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               b)
            (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe_to_lift.{u+1 u+1} α
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               c)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
a b c : α
⊢ @has_le.le.{0} real real.has_le
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          a)
       (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          c))
    (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
       (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@metric.has_dist.{u} α _inst_1)
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             a)
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             b))
       (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@metric.has_dist.{u} α _inst_1)
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             b)
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             c)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 76      rw [completion.dist_eq, completion.dist_eq, completion.dist_eq],</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='metric.completion.dist_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='metric.completion.dist_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='metric.completion.dist_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 37, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 37, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 37, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : metric_space.{u} α] (x y : α), @eq.{1} real (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) x) (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) y)) (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : metric_space.{u} α] (x y : α), @eq.{1} real (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) x) (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) y)) (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : metric_space.{u} α] (x y : α), @eq.{1} real (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) x) (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) y)) (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The new distance is an extension of the original distance.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The new distance is an extension of the original distance.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The new distance is an extension of the original distance.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
a b c : α
⊢ @has_le.le.{0} real real.has_le
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          a)
       (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          c))
    (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
       (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@metric.has_dist.{u} α _inst_1)
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             a)
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             b))
       (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@metric.has_dist.{u} α _inst_1)
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             b)
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             c)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
a b c : α
⊢ @has_le.le.{0} real real.has_le (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a c)
    (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
       (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@metric.has_dist.{u} α _inst_1)
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             a)
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             b))
       (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@metric.has_dist.{u} α _inst_1)
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             b)
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             c)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
a b c : α
⊢ @has_le.le.{0} real real.has_le (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a c)
    (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
       (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b)
       (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@metric.has_dist.{u} α _inst_1)
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             b)
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             c)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
a b c : α
⊢ @has_le.le.{0} real real.has_le (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a c)
    (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
       (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b)
       (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 77      exact dist_triangle a b c }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='dist_triangle'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='c'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 99, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : metric_space.{u} α] (x y z : α), @has_le.le.{0} real real.has_le (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x z) (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y) (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) y z))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
a b c : α
⊢ @has_le.le.{0} real real.has_le (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a c)
    (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring))
       (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b)
       (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) b c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 78  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 79  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 80  /-- Elements of the uniformity (defined generally for completions) can be characterized in terms</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 81  of the distance. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 82  protected lemma completion.mem_uniformity_dist (s : set (completion α × completion α)) :</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_space.completion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='uniform_space.completion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 322, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 322, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                    </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : uniform_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u → Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : uniform_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                         </code><font color='orange'><a title='Hausdorff completion of `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='Hausdorff completion of `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 83    s ∈ uniformity (completion α) ↔ (∃ε&gt;0, ∀{a b}, dist a b &lt; ε → (a, b) ∈ s) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_space.completion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='Exists'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_dist.dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 322, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 524, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [_inst_2 : uniform_space.{u} α], filter.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : uniform_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, (α → Prop) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_1} [c : has_dist.{u_1} α], α → α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [c : has_lt.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Hausdorff completion of `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 84  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ iff
    (@has_mem.mem.{u u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (filter.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@filter.has_mem.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       s
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@Exists.{1} real
       (λ (ε : real),
          @Exists.{0}
            (@gt.{0} real real.has_lt ε
               (@has_zero.zero.{0} real
                  (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
            (λ
             (H :
               @gt.{0} real real.has_lt ε
                 (@has_zero.zero.{0} real
                    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))),
               ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
                 @has_lt.lt.{0} real real.has_lt
                   (@has_dist.dist.{u}
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@metric.has_dist.{u} α _inst_1)
                      a
                      b)
                   ε →
                 @has_mem.mem.{u u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                   (set.{u}
                      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                   (@set.has_mem.{u}
                      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                   (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      a
                      b)
                   s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 85    split,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1012, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Applies the constructor when the type of the target is an inductive data type with one constructor.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='split'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ iff
    (@has_mem.mem.{u u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (filter.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@filter.has_mem.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       s
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@Exists.{1} real
       (λ (ε : real),
          @Exists.{0}
            (@gt.{0} real real.has_lt ε
               (@has_zero.zero.{0} real
                  (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
            (λ
             (H :
               @gt.{0} real real.has_lt ε
                 (@has_zero.zero.{0} real
                    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))),
               ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
                 @has_lt.lt.{0} real real.has_lt
                   (@has_dist.dist.{u}
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@metric.has_dist.{u} α _inst_1)
                      a
                      b)
                   ε →
                 @has_mem.mem.{u u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                   (set.{u}
                      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                   (@set.has_mem.{u}
                      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                   (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      a
                      b)
                   s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) →
  @Exists.{1} real
    (λ (ε : real),
       @Exists.{0}
         (@gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
         (λ
          (H :
            @gt.{0} real real.has_lt ε
              (@has_zero.zero.{0} real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))),
            ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
              @has_lt.lt.{0} real real.has_lt
                (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@metric.has_dist.{u} α _inst_1)
                   a
                   b)
                ε →
              @has_mem.mem.{u u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (set.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@set.has_mem.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   a
                   b)
                s))

α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ @Exists.{1} real
    (λ (ε : real),
       @Exists.{0}
         (@gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
         (λ
          (H :
            @gt.{0} real real.has_lt ε
              (@has_zero.zero.{0} real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))),
            ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
              @has_lt.lt.{0} real real.has_lt
                (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@metric.has_dist.{u} α _inst_1)
                   a
                   b)
                ε →
              @has_mem.mem.{u u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (set.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@set.has_mem.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   a
                   b)
                s)) →
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 86    { /- Start from an entourage `s`. It contains a closed entourage `t`. Its pullback in α is an</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) →
  @Exists.{1} real
    (λ (ε : real),
       @Exists.{0}
         (@gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
         (λ
          (H :
            @gt.{0} real real.has_lt ε
              (@has_zero.zero.{0} real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))),
            ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
              @has_lt.lt.{0} real real.has_lt
                (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@metric.has_dist.{u} α _inst_1)
                   a
                   b)
                ε →
              @has_mem.mem.{u u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (set.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@set.has_mem.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   a
                   b)
                s))

α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ @Exists.{1} real
    (λ (ε : real),
       @Exists.{0}
         (@gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
         (λ
          (H :
            @gt.{0} real real.has_lt ε
              (@has_zero.zero.{0} real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))),
            ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
              @has_lt.lt.{0} real real.has_lt
                (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@metric.has_dist.{u} α _inst_1)
                   a
                   b)
                ε →
              @has_mem.mem.{u u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (set.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@set.has_mem.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   a
                   b)
                s)) →
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) →
  @Exists.{1} real
    (λ (ε : real),
       @Exists.{0}
         (@gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
         (λ
          (H :
            @gt.{0} real real.has_lt ε
              (@has_zero.zero.{0} real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))),
            ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
              @has_lt.lt.{0} real real.has_lt
                (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@metric.has_dist.{u} α _inst_1)
                   a
                   b)
                ε →
              @has_mem.mem.{u u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (set.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@set.has_mem.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   a
                   b)
                s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 87      entourage, so it contains an ε-neighborhood of the diagonal by definition of the entourages</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) →
  @Exists.{1} real
    (λ (ε : real),
       @Exists.{0}
         (@gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
         (λ
          (H :
            @gt.{0} real real.has_lt ε
              (@has_zero.zero.{0} real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))),
            ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
              @has_lt.lt.{0} real real.has_lt
                (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@metric.has_dist.{u} α _inst_1)
                   a
                   b)
                ε →
              @has_mem.mem.{u u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (set.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@set.has_mem.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   a
                   b)
                s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 88      in metric spaces. Then `t` contains an ε-neighborhood of the diagonal in `completion α`, as</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) →
  @Exists.{1} real
    (λ (ε : real),
       @Exists.{0}
         (@gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
         (λ
          (H :
            @gt.{0} real real.has_lt ε
              (@has_zero.zero.{0} real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))),
            ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
              @has_lt.lt.{0} real real.has_lt
                (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@metric.has_dist.{u} α _inst_1)
                   a
                   b)
                ε →
              @has_mem.mem.{u u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (set.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@set.has_mem.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   a
                   b)
                s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 89      closed properties pass to the completion. -/</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) →
  @Exists.{1} real
    (λ (ε : real),
       @Exists.{0}
         (@gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
         (λ
          (H :
            @gt.{0} real real.has_lt ε
              (@has_zero.zero.{0} real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))),
            ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
              @has_lt.lt.{0} real real.has_lt
                (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@metric.has_dist.{u} α _inst_1)
                   a
                   b)
                ε →
              @has_mem.mem.{u u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (set.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@set.has_mem.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   a
                   b)
                s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 90      assume hs,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) →
  @Exists.{1} real
    (λ (ε : real),
       @Exists.{0}
         (@gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
         (λ
          (H :
            @gt.{0} real real.has_lt ε
              (@has_zero.zero.{0} real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))),
            ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
              @has_lt.lt.{0} real real.has_lt
                (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@metric.has_dist.{u} α _inst_1)
                   a
                   b)
                ε →
              @has_mem.mem.{u u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (set.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@set.has_mem.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   a
                   b)
                s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ @Exists.{1} real
    (λ (ε : real),
       @Exists.{0}
         (@gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
         (λ
          (H :
            @gt.{0} real real.has_lt ε
              (@has_zero.zero.{0} real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))),
            ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
              @has_lt.lt.{0} real real.has_lt
                (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@metric.has_dist.{u} α _inst_1)
                   a
                   b)
                ε →
              @has_mem.mem.{u u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (set.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@set.has_mem.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   a
                   b)
                s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 91      rcases mem_uniformity_is_closed hs with ⟨t, ht, ⟨tclosed, ts⟩⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='mem_uniformity_is_closed'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 417, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : uniform_space.{u} α] {s : set.{u} (prod.{u u} α α)}, @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) s (@uniformity.{u} α _inst_1) → @Exists.{u+1} (set.{u} (prod.{u u} α α)) (λ (t : set.{u} (prod.{u u} α α)), @Exists.{0} (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) t (@uniformity.{u} α _inst_1)) (λ (H : @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) t (@uniformity.{u} α _inst_1)), and (@is_closed.{u} (prod.{u u} α α) (@prod.topological_space.{u u} α α (@uniform_space.to_topological_space.{u} α _inst_1) (@uniform_space.to_topological_space.{u} α _inst_1)) t) (@has_subset.subset.{u} (set.{u} (prod.{u u} α α)) (@set.has_subset.{u} (prod.{u u} α α)) t s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (filter.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@filter.has_mem.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) s (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ @Exists.{1} real
    (λ (ε : real),
       @Exists.{0}
         (@gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
         (λ
          (H :
            @gt.{0} real real.has_lt ε
              (@has_zero.zero.{0} real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))),
            ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
              @has_lt.lt.{0} real real.has_lt
                (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@metric.has_dist.{u} α _inst_1)
                   a
                   b)
                ε →
              @has_mem.mem.{u u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (set.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@set.has_mem.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   a
                   b)
                s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s
⊢ @Exists.{1} real
    (λ (ε : real),
       @Exists.{0}
         (@gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
         (λ
          (H :
            @gt.{0} real real.has_lt ε
              (@has_zero.zero.{0} real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))),
            ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
              @has_lt.lt.{0} real real.has_lt
                (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@metric.has_dist.{u} α _inst_1)
                   a
                   b)
                ε →
              @has_mem.mem.{u u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (set.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@set.has_mem.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   a
                   b)
                s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 92      have A : {x : α × α | (coe (x.1), coe (x.2)) ∈ t} ∈ uniformity α :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='has_mem.mem'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 338, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u → Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {a b : Type u} [_inst_1 : has_lift_t.{u+1 u+1} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α γ : Type u} [c : has_mem.{u u} α γ], α → γ → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u) [_inst_2 : uniform_space.{u} α], filter.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s
⊢ @Exists.{1} real
    (λ (ε : real),
       @Exists.{0}
         (@gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
         (λ
          (H :
            @gt.{0} real real.has_lt ε
              (@has_zero.zero.{0} real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))),
            ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
              @has_lt.lt.{0} real real.has_lt
                (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@metric.has_dist.{u} α _inst_1)
                   a
                   b)
                ε →
              @has_mem.mem.{u u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (set.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@set.has_mem.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   a
                   b)
                s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 93        uniform_continuous_def.1 (uniform_continuous_coe α) t ht,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='uniform_continuous_def'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='uniform_space.completion.uniform_continuous_coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ht'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 430, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 387, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : uniform_space.{u} α] [_inst_2 : uniform_space.{u} β] {f : α → β}, iff (@uniform_continuous.{u u} α β _inst_1 _inst_2 f) (∀ (r : set.{u} (prod.{u u} β β)), @has_mem.mem.{u u} (set.{u} (prod.{u u} β β)) (filter.{u} (prod.{u u} β β)) (@filter.has_mem.{u} (prod.{u u} β β)) r (@uniformity.{u} β _inst_2) → @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) (@set_of.{u} (prod.{u u} α α) (λ (x : prod.{u u} α α), @has_mem.mem.{u u} (prod.{u u} β β) (set.{u} (prod.{u u} β β)) (@set.has_mem.{u} (prod.{u u} β β)) (@prod.mk.{u u} β β (f (@prod.fst.{u u} α α x)) (f (@prod.snd.{u u} α α x))) r)) (@uniformity.{u} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ (α : Type u) [_inst_1 : uniform_space.{u} α], @uniform_continuous.{u u} α (@uniform_space.completion.{u} α _inst_1) _inst_1 (@uniform_space.completion.uniform_space.{u} α _inst_1) (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α _inst_1) (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α _inst_1) (@uniform_space.completion.has_coe_t.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (filter.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@filter.has_mem.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) t (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s
⊢ @Exists.{1} real
    (λ (ε : real),
       @Exists.{0}
         (@gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
         (λ
          (H :
            @gt.{0} real real.has_lt ε
              (@has_zero.zero.{0} real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))),
            ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
              @has_lt.lt.{0} real real.has_lt
                (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@metric.has_dist.{u} α _inst_1)
                   a
                   b)
                ε →
              @has_mem.mem.{u u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (set.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@set.has_mem.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   a
                   b)
                s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
⊢ @Exists.{1} real
    (λ (ε : real),
       @Exists.{0}
         (@gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
         (λ
          (H :
            @gt.{0} real real.has_lt ε
              (@has_zero.zero.{0} real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))),
            ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
              @has_lt.lt.{0} real real.has_lt
                (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@metric.has_dist.{u} α _inst_1)
                   a
                   b)
                ε →
              @has_mem.mem.{u u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (set.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@set.has_mem.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   a
                   b)
                s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 94      rcases mem_uniformity_dist.1 A with ⟨ε, εpos, hε⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='metric.mem_uniformity_dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 307, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : metric_space.{u} α] {s : set.{u} (prod.{u u} α α)}, iff (@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) s (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@Exists.{1} real (λ (ε : real), @Exists.{0} (@gt.{0} real real.has_lt ε (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))) (λ (H : @gt.{0} real real.has_lt ε (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))), ∀ {a b : α}, @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε → @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α a b) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) (@set_of.{u} (prod.{u u} α α) (λ (x : prod.{u u} α α), @has_mem.mem.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@set.has_mem.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@prod.fst.{u u} α α x)) (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@prod.snd.{u u} α α x))) t)) (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
⊢ @Exists.{1} real
    (λ (ε : real),
       @Exists.{0}
         (@gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
         (λ
          (H :
            @gt.{0} real real.has_lt ε
              (@has_zero.zero.{0} real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))),
            ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
              @has_lt.lt.{0} real real.has_lt
                (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@metric.has_dist.{u} α _inst_1)
                   a
                   b)
                ε →
              @has_mem.mem.{u u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (set.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@set.has_mem.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   a
                   b)
                s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t))
⊢ @Exists.{1} real
    (λ (ε : real),
       @Exists.{0}
         (@gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
         (λ
          (H :
            @gt.{0} real real.has_lt ε
              (@has_zero.zero.{0} real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))),
            ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
              @has_lt.lt.{0} real real.has_lt
                (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@metric.has_dist.{u} α _inst_1)
                   a
                   b)
                ε →
              @has_mem.mem.{u u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (set.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@set.has_mem.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   a
                   b)
                s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 95      refine ⟨ε, εpos, λx y hxy, _⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='εpos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@gt.{0} real real.has_lt ε (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t))
⊢ @Exists.{1} real
    (λ (ε : real),
       @Exists.{0}
         (@gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
         (λ
          (H :
            @gt.{0} real real.has_lt ε
              (@has_zero.zero.{0} real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))),
            ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
              @has_lt.lt.{0} real real.has_lt
                (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@metric.has_dist.{u} α _inst_1)
                   a
                   b)
                ε →
              @has_mem.mem.{u u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (set.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@set.has_mem.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   a
                   b)
                s))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε
⊢ @has_mem.mem.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       x
       y)
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 96      have : ε ≤ dist x y ∨ (x, y) ∈ t,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_le.le'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_dist.dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='or'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 319, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_le.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [c : has_dist.{u} α], α → α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Prop → Prop → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε
⊢ @has_mem.mem.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       x
       y)
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε
⊢ or
    (@has_le.le.{0} real real.has_le ε
       (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@metric.has_dist.{u} α _inst_1)
          x
          y))
    (@has_mem.mem.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set.has_mem.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          x
          y)
       t)

α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε,
this :
  or
    (@has_le.le.{0} real real.has_le ε
       (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@metric.has_dist.{u} α _inst_1)
          x
          y))
    (@has_mem.mem.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set.has_mem.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          x
          y)
       t)
⊢ @has_mem.mem.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       x
       y)
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 97      { apply induction_on₂ x y,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='uniform_space.completion.induction_on₂'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 420, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : uniform_space.{u} α] {β : Type u} [_inst_2 : uniform_space.{u} β] {p : @uniform_space.completion.{u} α _inst_1 → @uniform_space.completion.{u} β _inst_2 → Prop} (a : @uniform_space.completion.{u} α _inst_1) (b : @uniform_space.completion.{u} β _inst_2), @is_closed.{u} (prod.{u u} (@uniform_space.completion.{u} α _inst_1) (@uniform_space.completion.{u} β _inst_2)) (@prod.topological_space.{u u} (@uniform_space.completion.{u} α _inst_1) (@uniform_space.completion.{u} β _inst_2) (@uniform_space.to_topological_space.{u} (@uniform_space.completion.{u} α _inst_1) (@uniform_space.completion.uniform_space.{u} α _inst_1)) (@uniform_space.to_topological_space.{u} (@uniform_space.completion.{u} β _inst_2) (@uniform_space.completion.uniform_space.{u} β _inst_2))) (@set_of.{u} (prod.{u u} (@uniform_space.completion.{u} α _inst_1) (@uniform_space.completion.{u} β _inst_2)) (λ (x : prod.{u u} (@uniform_space.completion.{u} α _inst_1) (@uniform_space.completion.{u} β _inst_2)), p (@prod.fst.{u u} (@uniform_space.completion.{u} α _inst_1) (@uniform_space.completion.{u} β _inst_2) x) (@prod.snd.{u u} (@uniform_space.completion.{u} α _inst_1) (@uniform_space.completion.{u} β _inst_2) x))) → (∀ (a : α) (b : β), p (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α _inst_1) (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α _inst_1) (@uniform_space.completion.has_coe_t.{u} α _inst_1)) a) (@coe.{u+1 u+1} β (@uniform_space.completion.{u} β _inst_2) (@coe_to_lift.{u+1 u+1} β (@uniform_space.completion.{u} β _inst_2) (@uniform_space.completion.has_coe_t.{u} β _inst_2)) b)) → p a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε
⊢ or
    (@has_le.le.{0} real real.has_le ε
       (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@metric.has_dist.{u} α _inst_1)
          x
          y))
    (@has_mem.mem.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set.has_mem.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          x
          y)
       t)

α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε,
this :
  or
    (@has_le.le.{0} real real.has_le ε
       (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@metric.has_dist.{u} α _inst_1)
          x
          y))
    (@has_mem.mem.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set.has_mem.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          x
          y)
       t)
⊢ @has_mem.mem.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       x
       y)
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε
⊢ or
    (@has_le.le.{0} real real.has_le ε
       (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@metric.has_dist.{u} α _inst_1)
          x
          y))
    (@has_mem.mem.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set.has_mem.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          x
          y)
       t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε
⊢ @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set_of.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (λ
        (x :
          prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
          or
            (@has_le.le.{0} real real.has_le ε
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)))
            (@has_mem.mem.{u u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               (set.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
               (@set.has_mem.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
               (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x))
               t)))

α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε
⊢ ∀ (a b : α),
    or
      (@has_le.le.{0} real real.has_le ε
         (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@metric.has_dist.{u} α _inst_1)
            (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe_to_lift.{u+1 u+1} α
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               a)
            (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe_to_lift.{u+1 u+1} α
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               b)))
      (@has_mem.mem.{u u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
         (set.{u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
         (@set.has_mem.{u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
         (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe_to_lift.{u+1 u+1} α
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               a)
            (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe_to_lift.{u+1 u+1} α
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               b))
         t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 98        { have : {x : completion α × completion α | ε ≤ dist (x.fst) (x.snd) ∨ (x.fst, x.snd) ∈ t}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε
⊢ @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set_of.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (λ
        (x :
          prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
          or
            (@has_le.le.{0} real real.has_le ε
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)))
            (@has_mem.mem.{u u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               (set.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
               (@set.has_mem.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
               (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x))
               t)))

α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε
⊢ ∀ (a b : α),
    or
      (@has_le.le.{0} real real.has_le ε
         (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@metric.has_dist.{u} α _inst_1)
            (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe_to_lift.{u+1 u+1} α
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               a)
            (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe_to_lift.{u+1 u+1} α
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               b)))
      (@has_mem.mem.{u u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
         (set.{u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
         (@set.has_mem.{u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
         (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe_to_lift.{u+1 u+1} α
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               a)
            (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe_to_lift.{u+1 u+1} α
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               b))
         t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε
⊢ @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set_of.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (λ
        (x :
          prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
          or
            (@has_le.le.{0} real real.has_le ε
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)))
            (@has_mem.mem.{u u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               (set.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
               (@set.has_mem.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
               (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x))
               t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'> 99                 = {p : completion α × completion α | ε ≤ dist p.1 p.2} ∪ t, by ext; simp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='uniform_space.completion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_dist.dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='has_union.union'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 322, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 323, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u}, (α → Prop) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u) [_inst_1 : uniform_space.{u} α], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [c : has_dist.{u} α], α → α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [c : has_union.{u} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Hausdorff completion of `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε
⊢ @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set_of.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (λ
        (x :
          prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
          or
            (@has_le.le.{0} real real.has_le ε
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)))
            (@has_mem.mem.{u u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               (set.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
               (@set.has_mem.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
               (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x))
               t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε,
this :
  @eq.{(max (u+1) 1)}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set_of.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (λ
        (x :
          prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
          or
            (@has_le.le.{0} real real.has_le ε
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)))
            (@has_mem.mem.{u u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               (set.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
               (@set.has_mem.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
               (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x))
               t)))
    (@has_union.union.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set.has_union.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set_of.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (λ
           (p :
             prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
             @has_le.le.{0} real real.has_le ε
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     p)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     p))))
       t)
⊢ @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set_of.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (λ
        (x :
          prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
          or
            (@has_le.le.{0} real real.has_le ε
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)))
            (@has_mem.mem.{u u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               (set.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
               (@set.has_mem.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
               (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x))
               t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>100          rw this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{(max (u+1) 1)} (set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@set_of.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (λ (x : prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))), or (@has_le.le.{0} real real.has_le ε (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) x) (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) x))) (@has_mem.mem.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@set.has_mem.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) x) (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) x)) t))) (@has_union.union.{u} (set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@set.has_union.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@set_of.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (λ (p : prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))), @has_le.le.{0} real real.has_le ε (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) p) (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) p)))) t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε,
this :
  @eq.{(max (u+1) 1)}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set_of.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (λ
        (x :
          prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
          or
            (@has_le.le.{0} real real.has_le ε
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)))
            (@has_mem.mem.{u u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               (set.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
               (@set.has_mem.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
               (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x))
               t)))
    (@has_union.union.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set.has_union.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set_of.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (λ
           (p :
             prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
             @has_le.le.{0} real real.has_le ε
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     p)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     p))))
       t)
⊢ @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set_of.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (λ
        (x :
          prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
          or
            (@has_le.le.{0} real real.has_le ε
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)))
            (@has_mem.mem.{u u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               (set.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
               (@set.has_mem.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
               (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x))
               t)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε,
this :
  @eq.{(max (u+1) 1)}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set_of.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (λ
        (x :
          prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
          or
            (@has_le.le.{0} real real.has_le ε
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)))
            (@has_mem.mem.{u u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               (set.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
               (@set.has_mem.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
               (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x))
               t)))
    (@has_union.union.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set.has_union.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set_of.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (λ
           (p :
             prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
             @has_le.le.{0} real real.has_le ε
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     p)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     p))))
       t)
⊢ @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@has_union.union.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set.has_union.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set_of.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (λ
           (p :
             prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
             @has_le.le.{0} real real.has_le ε
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     p)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     p))))
       t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>101          apply is_closed_union _ tclosed,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='is_closed_union'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='tclosed'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 134, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 182, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {s₁ s₂ : set.{u} α} [_inst_1 : topological_space.{u} α], @is_closed.{u} α _inst_1 s₁ → @is_closed.{u} α _inst_1 s₂ → @is_closed.{u} α _inst_1 (@has_union.union.{u} (set.{u} α) (@set.has_union.{u} α) s₁ s₂)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@is_closed.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.to_topological_space.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@uniform_space.to_topological_space.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='orange'><a title='The `apply` tactic tries to match the current goal against the conclusion of the type of term. The argument term should be a term well-formed in the local context of the main goal. If it succeeds, then the tactic returns as many subgoals as the number of premises that have not been fixed by type inference or type class resolution. Non-dependent premises are added before dependent ones.

The `apply` tactic uses higher-order pattern matching, type class resolution, and first-order unification with dependent types.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='teal'><a title='apply'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε,
this :
  @eq.{(max (u+1) 1)}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set_of.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (λ
        (x :
          prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
          or
            (@has_le.le.{0} real real.has_le ε
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)))
            (@has_mem.mem.{u u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               (set.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
               (@set.has_mem.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
               (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x))
               t)))
    (@has_union.union.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set.has_union.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set_of.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (λ
           (p :
             prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
             @has_le.le.{0} real real.has_le ε
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     p)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     p))))
       t)
⊢ @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@has_union.union.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set.has_union.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set_of.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (λ
           (p :
             prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
             @has_le.le.{0} real real.has_le ε
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     p)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     p))))
       t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε,
this :
  @eq.{(max (u+1) 1)}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set_of.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (λ
        (x :
          prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
          or
            (@has_le.le.{0} real real.has_le ε
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)))
            (@has_mem.mem.{u u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               (set.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
               (@set.has_mem.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
               (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x))
               t)))
    (@has_union.union.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set.has_union.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set_of.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (λ
           (p :
             prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
             @has_le.le.{0} real real.has_le ε
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     p)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     p))))
       t)
⊢ @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set_of.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (λ
        (p :
          prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
          @has_le.le.{0} real real.has_le ε
            (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@metric.has_dist.{u} α _inst_1)
               (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  p)
               (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  p))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>102          exact is_closed_le continuous_const completion.uniform_continuous_dist.continuous },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='is_closed_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='continuous_const'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='metric.completion.uniform_continuous_dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/algebra/ordered.lean&#x27;, &#x27;line&#x27;: 112, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/basic.lean&#x27;, &#x27;line&#x27;: 686, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} {β : Type u} [_inst_1 : topological_space.{0} α] [_inst_2 : preorder.{0} α] [t : @order_closed_topology.{0} α _inst_1 _inst_2] [_inst_3 : topological_space.{u} β] {f g : β → α}, @continuous.{u 0} β α _inst_3 _inst_1 f → @continuous.{u 0} β α _inst_3 _inst_1 g → @is_closed.{u} β _inst_3 (@set_of.{u} β (λ (b : β), @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_2) (f b) (g b)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type} [_inst_1 : topological_space.{u} α] [_inst_2 : topological_space.{0} β] {b : β}, @continuous.{u 0} α β _inst_1 _inst_2 (λ (a : α), b)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : metric_space.{u} α], @uniform_continuous.{u 0} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) real (@prod.uniform_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space) (λ (p : prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))), @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) p) (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The new distance is uniformly continuous.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                             </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε,
this :
  @eq.{(max (u+1) 1)}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set_of.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (λ
        (x :
          prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
          or
            (@has_le.le.{0} real real.has_le ε
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)))
            (@has_mem.mem.{u u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               (set.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
               (@set.has_mem.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
               (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     x))
               t)))
    (@has_union.union.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set.has_union.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set_of.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (λ
           (p :
             prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
             @has_le.le.{0} real real.has_le ε
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     p)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     p))))
       t)
⊢ @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set_of.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (λ
        (p :
          prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
          @has_le.le.{0} real real.has_le ε
            (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@metric.has_dist.{u} α _inst_1)
               (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  p)
               (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  p))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε
⊢ ∀ (a b : α),
    or
      (@has_le.le.{0} real real.has_le ε
         (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@metric.has_dist.{u} α _inst_1)
            (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe_to_lift.{u+1 u+1} α
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               a)
            (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe_to_lift.{u+1 u+1} α
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               b)))
      (@has_mem.mem.{u u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
         (set.{u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
         (@set.has_mem.{u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
         (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe_to_lift.{u+1 u+1} α
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               a)
            (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe_to_lift.{u+1 u+1} α
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               b))
         t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>103        { assume x y,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε
⊢ ∀ (a b : α),
    or
      (@has_le.le.{0} real real.has_le ε
         (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@metric.has_dist.{u} α _inst_1)
            (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe_to_lift.{u+1 u+1} α
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               a)
            (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe_to_lift.{u+1 u+1} α
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               b)))
      (@has_mem.mem.{u u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
         (set.{u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
         (@set.has_mem.{u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
         (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe_to_lift.{u+1 u+1} α
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               a)
            (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe_to_lift.{u+1 u+1} α
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               b))
         t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε,
x y : α
⊢ or
    (@has_le.le.{0} real real.has_le ε
       (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@metric.has_dist.{u} α _inst_1)
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             x)
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             y)))
    (@has_mem.mem.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set.has_mem.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             x)
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             y))
       t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>104          rw completion.dist_eq,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='metric.completion.dist_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 37, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : metric_space.{u} α] (x y : α), @eq.{1} real (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) x) (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) y)) (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The new distance is an extension of the original distance.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε,
x y : α
⊢ or
    (@has_le.le.{0} real real.has_le ε
       (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@metric.has_dist.{u} α _inst_1)
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             x)
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             y)))
    (@has_mem.mem.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set.has_mem.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             x)
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             y))
       t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε,
x y : α
⊢ or (@has_le.le.{0} real real.has_le ε (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y))
    (@has_mem.mem.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set.has_mem.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             x)
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             y))
       t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>105          by_cases h : ε ≤ dist x y,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_dist.dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1474, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [c : has_dist.{u} α], α → α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} (option.{0} name) pexpr) (λ (a : prod.{0 0} (option.{0} name) pexpr), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(option.{0} name) `(pexpr) a) tactic.interactive.cases_arg_p → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`by_cases (h :)? p` splits the main goal into two cases, assuming `h : p` in the first branch, and `h : ¬ p` in the second branch.

This tactic requires that `p` is decidable. To ensure that all propositions are decidable via classical reasoning, use  `local attribute classical.prop_decidable [instance]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='by_cases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;(id :)? expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε,
x y : α
⊢ or (@has_le.le.{0} real real.has_le ε (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y))
    (@has_mem.mem.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set.has_mem.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             x)
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             y))
       t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε,
x y : α,
h :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real
          (@linear_order.to_partial_order.{0} real
             (@linear_order.mk.{0} real (@decidable_linear_order.le.{0} real real.decidable_linear_order)
                (@decidable_linear_order.lt.{0} real real.decidable_linear_order)
                (@decidable_linear_order.le_refl.{0} real real.decidable_linear_order)
                (@decidable_linear_order.le_trans.{0} real real.decidable_linear_order)
                (@decidable_linear_order.lt_iff_le_not_le.{0} real real.decidable_linear_order)
                (@decidable_linear_order.le_antisymm.{0} real real.decidable_linear_order)
                (@decidable_linear_order.le_total.{0} real real.decidable_linear_order)))))
    ε
    (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y)
⊢ or (@has_le.le.{0} real real.has_le ε (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y))
    (@has_mem.mem.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set.has_mem.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             x)
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             y))
       t)

α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε,
x y : α,
h :
  not
    (@has_le.le.{0} real
       (@preorder.to_has_le.{0} real
          (@partial_order.to_preorder.{0} real
             (@linear_order.to_partial_order.{0} real
                (@linear_order.mk.{0} real (@decidable_linear_order.le.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.lt.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.le_refl.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.le_trans.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.lt_iff_le_not_le.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.le_antisymm.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.le_total.{0} real real.decidable_linear_order)))))
       ε
       (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y))
⊢ or (@has_le.le.{0} real real.has_le ε (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y))
    (@has_mem.mem.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set.has_mem.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             x)
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             y))
       t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>106          { exact or.inl h },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='or.inl'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, a → or a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_le.le.{0} real (@preorder.to_has_le.{0} real (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real (@linear_order.mk.{0} real (@decidable_linear_order.le.{0} real real.decidable_linear_order) (@decidable_linear_order.lt.{0} real real.decidable_linear_order) (@decidable_linear_order.le_refl.{0} real real.decidable_linear_order) (@decidable_linear_order.le_trans.{0} real real.decidable_linear_order) (@decidable_linear_order.lt_iff_le_not_le.{0} real real.decidable_linear_order) (@decidable_linear_order.le_antisymm.{0} real real.decidable_linear_order) (@decidable_linear_order.le_total.{0} real real.decidable_linear_order))))) ε (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε,
x y : α,
h :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real
          (@linear_order.to_partial_order.{0} real
             (@linear_order.mk.{0} real (@decidable_linear_order.le.{0} real real.decidable_linear_order)
                (@decidable_linear_order.lt.{0} real real.decidable_linear_order)
                (@decidable_linear_order.le_refl.{0} real real.decidable_linear_order)
                (@decidable_linear_order.le_trans.{0} real real.decidable_linear_order)
                (@decidable_linear_order.lt_iff_le_not_le.{0} real real.decidable_linear_order)
                (@decidable_linear_order.le_antisymm.{0} real real.decidable_linear_order)
                (@decidable_linear_order.le_total.{0} real real.decidable_linear_order)))))
    ε
    (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y)
⊢ or (@has_le.le.{0} real real.has_le ε (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y))
    (@has_mem.mem.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set.has_mem.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             x)
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             y))
       t)

α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε,
x y : α,
h :
  not
    (@has_le.le.{0} real
       (@preorder.to_has_le.{0} real
          (@partial_order.to_preorder.{0} real
             (@linear_order.to_partial_order.{0} real
                (@linear_order.mk.{0} real (@decidable_linear_order.le.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.lt.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.le_refl.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.le_trans.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.lt_iff_le_not_le.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.le_antisymm.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.le_total.{0} real real.decidable_linear_order)))))
       ε
       (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y))
⊢ or (@has_le.le.{0} real real.has_le ε (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y))
    (@has_mem.mem.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set.has_mem.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             x)
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             y))
       t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε,
x y : α,
h :
  @has_le.le.{0} real
    (@preorder.to_has_le.{0} real
       (@partial_order.to_preorder.{0} real
          (@linear_order.to_partial_order.{0} real
             (@linear_order.mk.{0} real (@decidable_linear_order.le.{0} real real.decidable_linear_order)
                (@decidable_linear_order.lt.{0} real real.decidable_linear_order)
                (@decidable_linear_order.le_refl.{0} real real.decidable_linear_order)
                (@decidable_linear_order.le_trans.{0} real real.decidable_linear_order)
                (@decidable_linear_order.lt_iff_le_not_le.{0} real real.decidable_linear_order)
                (@decidable_linear_order.le_antisymm.{0} real real.decidable_linear_order)
                (@decidable_linear_order.le_total.{0} real real.decidable_linear_order)))))
    ε
    (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y)
⊢ or (@has_le.le.{0} real real.has_le ε (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y))
    (@has_mem.mem.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set.has_mem.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             x)
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             y))
       t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε,
x y : α,
h :
  not
    (@has_le.le.{0} real
       (@preorder.to_has_le.{0} real
          (@partial_order.to_preorder.{0} real
             (@linear_order.to_partial_order.{0} real
                (@linear_order.mk.{0} real (@decidable_linear_order.le.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.lt.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.le_refl.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.le_trans.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.lt_iff_le_not_le.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.le_antisymm.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.le_total.{0} real real.decidable_linear_order)))))
       ε
       (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y))
⊢ or (@has_le.le.{0} real real.has_le ε (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y))
    (@has_mem.mem.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set.has_mem.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             x)
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             y))
       t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>107          { have Z := hε (not_le.1 h),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='hε'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='not_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : α}, @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε → @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α a b) (@set_of.{u} (prod.{u u} α α) (λ (x : prod.{u u} α α), @has_mem.mem.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@set.has_mem.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@prod.fst.{u u} α α x)) (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@prod.snd.{u u} α α x))) t))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : linear_order.{0} α] {a b : α}, iff (not (@has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α _inst_1))) a b)) (@has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α _inst_1))) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='not (@has_le.le.{0} real (@preorder.to_has_le.{0} real (@partial_order.to_preorder.{0} real (@linear_order.to_partial_order.{0} real (@linear_order.mk.{0} real (@decidable_linear_order.le.{0} real real.decidable_linear_order) (@decidable_linear_order.lt.{0} real real.decidable_linear_order) (@decidable_linear_order.le_refl.{0} real real.decidable_linear_order) (@decidable_linear_order.le_trans.{0} real real.decidable_linear_order) (@decidable_linear_order.lt_iff_le_not_le.{0} real real.decidable_linear_order) (@decidable_linear_order.le_antisymm.{0} real real.decidable_linear_order) (@decidable_linear_order.le_total.{0} real real.decidable_linear_order))))) ε (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε,
x y : α,
h :
  not
    (@has_le.le.{0} real
       (@preorder.to_has_le.{0} real
          (@partial_order.to_preorder.{0} real
             (@linear_order.to_partial_order.{0} real
                (@linear_order.mk.{0} real (@decidable_linear_order.le.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.lt.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.le_refl.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.le_trans.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.lt_iff_le_not_le.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.le_antisymm.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.le_total.{0} real real.decidable_linear_order)))))
       ε
       (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y))
⊢ or (@has_le.le.{0} real real.has_le ε (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y))
    (@has_mem.mem.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set.has_mem.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             x)
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             y))
       t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε,
x y : α,
h :
  not
    (@has_le.le.{0} real
       (@preorder.to_has_le.{0} real
          (@partial_order.to_preorder.{0} real
             (@linear_order.to_partial_order.{0} real
                (@linear_order.mk.{0} real (@decidable_linear_order.le.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.lt.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.le_refl.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.le_trans.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.lt_iff_le_not_le.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.le_antisymm.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.le_total.{0} real real.decidable_linear_order)))))
       ε
       (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y)),
Z :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α x y)
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
⊢ or (@has_le.le.{0} real real.has_le ε (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y))
    (@has_mem.mem.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set.has_mem.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             x)
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             y))
       t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>108            simp only [set.mem_set_of_eq] at Z,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                     </code><font color='blue'><a title='set.mem_set_of_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {a : α} {p : α → Prop}, @eq.{1} Prop (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) a (@set_of.{?l_1} α (λ (a : α), p a))) (p a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε,
x y : α,
h :
  not
    (@has_le.le.{0} real
       (@preorder.to_has_le.{0} real
          (@partial_order.to_preorder.{0} real
             (@linear_order.to_partial_order.{0} real
                (@linear_order.mk.{0} real (@decidable_linear_order.le.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.lt.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.le_refl.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.le_trans.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.lt_iff_le_not_le.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.le_antisymm.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.le_total.{0} real real.decidable_linear_order)))))
       ε
       (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y)),
Z :
  @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
    (@prod.mk.{u u} α α x y)
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
⊢ or (@has_le.le.{0} real real.has_le ε (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y))
    (@has_mem.mem.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set.has_mem.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             x)
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             y))
       t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε,
x y : α,
h :
  not
    (@has_le.le.{0} real
       (@preorder.to_has_le.{0} real
          (@partial_order.to_preorder.{0} real
             (@linear_order.to_partial_order.{0} real
                (@linear_order.mk.{0} real (@decidable_linear_order.le.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.lt.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.le_refl.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.le_trans.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.lt_iff_le_not_le.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.le_antisymm.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.le_total.{0} real real.decidable_linear_order)))))
       ε
       (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y)),
Z :
  @has_mem.mem.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          x)
       (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          y))
    t
⊢ or (@has_le.le.{0} real real.has_le ε (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y))
    (@has_mem.mem.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set.has_mem.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             x)
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             y))
       t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>109            exact or.inr Z }}},</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='or.inr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='Z'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 237, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, b → or a b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@set.has_mem.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) x) (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) y)) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε,
x y : α,
h :
  not
    (@has_le.le.{0} real
       (@preorder.to_has_le.{0} real
          (@partial_order.to_preorder.{0} real
             (@linear_order.to_partial_order.{0} real
                (@linear_order.mk.{0} real (@decidable_linear_order.le.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.lt.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.le_refl.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.le_trans.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.lt_iff_le_not_le.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.le_antisymm.{0} real real.decidable_linear_order)
                   (@decidable_linear_order.le_total.{0} real real.decidable_linear_order)))))
       ε
       (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y)),
Z :
  @has_mem.mem.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          x)
       (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          y))
    t
⊢ or (@has_le.le.{0} real real.has_le ε (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y))
    (@has_mem.mem.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set.has_mem.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             x)
          (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@coe_to_lift.{u+1 u+1} α
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             y))
       t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε,
this :
  or
    (@has_le.le.{0} real real.has_le ε
       (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@metric.has_dist.{u} α _inst_1)
          x
          y))
    (@has_mem.mem.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set.has_mem.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          x
          y)
       t)
⊢ @has_mem.mem.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       x
       y)
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>110      simp only [not_le.mpr hxy, false_or, not_le] at this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='not_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hxy'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='false_or'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='not_le'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 466, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/order.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : linear_order.{0} α] {a b : α}, iff (not (@has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α _inst_1))) a b)) (@has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α _inst_1))) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) x y) ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a : Prop), iff (or false a) a'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : linear_order.{?l_1} α] {a b : α}, iff (not (@has_le.le.{?l_1} α (@preorder.to_has_le.{?l_1} α (@partial_order.to_preorder.{?l_1} α (@linear_order.to_partial_order.{?l_1} α _inst_1))) a b)) (@has_lt.lt.{?l_1} α (@preorder.to_has_lt.{?l_1} α (@partial_order.to_preorder.{?l_1} α (@linear_order.to_partial_order.{?l_1} α _inst_1))) b a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε,
this :
  or
    (@has_le.le.{0} real real.has_le ε
       (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@metric.has_dist.{u} α _inst_1)
          x
          y))
    (@has_mem.mem.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@set.has_mem.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          x
          y)
       t)
⊢ @has_mem.mem.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       x
       y)
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε,
this :
  @has_mem.mem.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       x
       y)
    t
⊢ @has_mem.mem.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       x
       y)
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>111      exact ts this },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='ts'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_subset.subset.{u} (set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@set.has_subset.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) t s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@set.has_mem.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) x y) t'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
t :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
tclosed :
  @is_closed.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@prod.topological_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniform_space.to_topological_space.{u}
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t,
ts :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t
    s,
A :
  @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α))
    (@filter.has_mem.{u} (prod.{u u} α α))
    (@set_of.{u} (prod.{u u} α α)
       (λ (x : prod.{u u} α α),
          @has_mem.mem.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@set.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.fst.{u u} α α x))
               (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@coe_to_lift.{u+1 u+1} α
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@prod.snd.{u u} α α x)))
            t))
    (@uniformity.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : α},
    @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) a b) ε →
    @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α))
      (@prod.mk.{u u} α α a b)
      (@set_of.{u} (prod.{u u} α α)
         (λ (x : prod.{u u} α α),
            @has_mem.mem.{u u}
              (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
              (set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@set.has_mem.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
              (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.fst.{u u} α α x))
                 (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@coe_to_lift.{u+1 u+1} α
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (@prod.snd.{u u} α α x)))
              t)),
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hxy :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    ε,
this :
  @has_mem.mem.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       x
       y)
    t
⊢ @has_mem.mem.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       x
       y)
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ @Exists.{1} real
    (λ (ε : real),
       @Exists.{0}
         (@gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
         (λ
          (H :
            @gt.{0} real real.has_lt ε
              (@has_zero.zero.{0} real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))),
            ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
              @has_lt.lt.{0} real real.has_lt
                (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@metric.has_dist.{u} α _inst_1)
                   a
                   b)
                ε →
              @has_mem.mem.{u u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (set.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@set.has_mem.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   a
                   b)
                s)) →
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>112    { /- Start from a set `s` containing an ε-neighborhood of the diagonal in `completion α`. To show</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ @Exists.{1} real
    (λ (ε : real),
       @Exists.{0}
         (@gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
         (λ
          (H :
            @gt.{0} real real.has_lt ε
              (@has_zero.zero.{0} real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))),
            ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
              @has_lt.lt.{0} real real.has_lt
                (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@metric.has_dist.{u} α _inst_1)
                   a
                   b)
                ε →
              @has_mem.mem.{u u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (set.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@set.has_mem.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   a
                   b)
                s)) →
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>113      that it is an entourage, we use the fact that `dist` is uniformly continuous on</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ @Exists.{1} real
    (λ (ε : real),
       @Exists.{0}
         (@gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
         (λ
          (H :
            @gt.{0} real real.has_lt ε
              (@has_zero.zero.{0} real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))),
            ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
              @has_lt.lt.{0} real real.has_lt
                (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@metric.has_dist.{u} α _inst_1)
                   a
                   b)
                ε →
              @has_mem.mem.{u u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (set.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@set.has_mem.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   a
                   b)
                s)) →
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>114      `completion α × completion α` (this is a general property of the extension of uniformly</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ @Exists.{1} real
    (λ (ε : real),
       @Exists.{0}
         (@gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
         (λ
          (H :
            @gt.{0} real real.has_lt ε
              (@has_zero.zero.{0} real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))),
            ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
              @has_lt.lt.{0} real real.has_lt
                (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@metric.has_dist.{u} α _inst_1)
                   a
                   b)
                ε →
              @has_mem.mem.{u u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (set.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@set.has_mem.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   a
                   b)
                s)) →
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>115      continuous functions). Therefore, the preimage of the ε-neighborhood of the diagonal in ℝ</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ @Exists.{1} real
    (λ (ε : real),
       @Exists.{0}
         (@gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
         (λ
          (H :
            @gt.{0} real real.has_lt ε
              (@has_zero.zero.{0} real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))),
            ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
              @has_lt.lt.{0} real real.has_lt
                (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@metric.has_dist.{u} α _inst_1)
                   a
                   b)
                ε →
              @has_mem.mem.{u u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (set.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@set.has_mem.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   a
                   b)
                s)) →
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>116      is an entourage in `completion α × completion α`. Massaging this property, it follows that</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ @Exists.{1} real
    (λ (ε : real),
       @Exists.{0}
         (@gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
         (λ
          (H :
            @gt.{0} real real.has_lt ε
              (@has_zero.zero.{0} real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))),
            ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
              @has_lt.lt.{0} real real.has_lt
                (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@metric.has_dist.{u} α _inst_1)
                   a
                   b)
                ε →
              @has_mem.mem.{u u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (set.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@set.has_mem.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   a
                   b)
                s)) →
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>117      the ε-neighborhood of the diagonal is an entourage in `completion α`, and therefore this is</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ @Exists.{1} real
    (λ (ε : real),
       @Exists.{0}
         (@gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
         (λ
          (H :
            @gt.{0} real real.has_lt ε
              (@has_zero.zero.{0} real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))),
            ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
              @has_lt.lt.{0} real real.has_lt
                (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@metric.has_dist.{u} α _inst_1)
                   a
                   b)
                ε →
              @has_mem.mem.{u u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (set.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@set.has_mem.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   a
                   b)
                s)) →
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>118      also the case of `s`. -/</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ @Exists.{1} real
    (λ (ε : real),
       @Exists.{0}
         (@gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
         (λ
          (H :
            @gt.{0} real real.has_lt ε
              (@has_zero.zero.{0} real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))),
            ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
              @has_lt.lt.{0} real real.has_lt
                (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@metric.has_dist.{u} α _inst_1)
                   a
                   b)
                ε →
              @has_mem.mem.{u u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (set.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@set.has_mem.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   a
                   b)
                s)) →
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>119      rintros ⟨ε, εpos, hε⟩,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ @Exists.{1} real
    (λ (ε : real),
       @Exists.{0}
         (@gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
         (λ
          (H :
            @gt.{0} real real.has_lt ε
              (@has_zero.zero.{0} real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))),
            ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
              @has_lt.lt.{0} real real.has_lt
                (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@metric.has_dist.{u} α _inst_1)
                   a
                   b)
                ε →
              @has_mem.mem.{u u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (set.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@set.has_mem.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   a
                   b)
                s)) →
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s
⊢ @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>120      let r : set (ℝ × ℝ) := {p | dist p.1 p.2 &lt; ε},</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='set'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='blue'><a title='has_dist.dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 941, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_dist.{0} α], α → α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [c : has_lt.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`let h : t := p` adds the hypothesis `h : t := p` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`let h : t` adds the hypothesis `h : t := ?M` to the current goal and opens a new subgoal `?M : t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='let'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s
⊢ @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
r : set.{0} (prod.{0 0} real real) :=
  @set_of.{0} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       @has_lt.lt.{0} real real.has_lt
         (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@prod.fst.{0 0} real real p)
            (@prod.snd.{0 0} real real p))
         ε)
⊢ @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>121      have : r ∈ uniformity ℝ := metric.dist_mem_uniformity εpos,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='metric.dist_mem_uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='εpos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 316, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{0} (prod.{0 0} real real)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type) [_inst_2 : uniform_space.{0} α], filter.{0} (prod.{0 0} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : metric_space.{0} α] {ε : real}, @has_lt.lt.{0} real real.has_lt (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) ε → @has_mem.mem.{0 0} (set.{0} (prod.{0 0} α α)) (filter.{0} (prod.{0 0} α α)) (@filter.has_mem.{0} (prod.{0 0} α α)) (@set_of.{0} (prod.{0 0} α α) (λ (p : prod.{0 0} α α), @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{0} α (@metric_space.to_has_dist.{0} α _inst_1) (@prod.fst.{0 0} α α p) (@prod.snd.{0 0} α α p)) ε)) (@uniformity.{0} α (@metric_space.to_uniform_space&#x27;.{0} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@gt.{0} real real.has_lt ε (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
r : set.{0} (prod.{0 0} real real) :=
  @set_of.{0} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       @has_lt.lt.{0} real real.has_lt
         (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@prod.fst.{0 0} real real p)
            (@prod.snd.{0 0} real real p))
         ε)
⊢ @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
r : set.{0} (prod.{0 0} real real) :=
  @set_of.{0} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       @has_lt.lt.{0} real real.has_lt
         (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@prod.fst.{0 0} real real p)
            (@prod.snd.{0 0} real real p))
         ε),
this :
  @has_mem.mem.{0 0} (set.{0} (prod.{0 0} real real)) (filter.{0} (prod.{0 0} real real))
    (@filter.has_mem.{0} (prod.{0 0} real real))
    r
    (@uniformity.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
⊢ @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>122      have T := uniform_continuous_def.1 (@completion.uniform_continuous_dist α _) r this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='blue'><a title='uniform_continuous_def'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='metric.completion.uniform_continuous_dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 430, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 32, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {β : Type} [_inst_1 : uniform_space.{u} α] [_inst_2 : uniform_space.{0} β] {f : α → β}, iff (@uniform_continuous.{u 0} α β _inst_1 _inst_2 f) (∀ (r : set.{0} (prod.{0 0} β β)), @has_mem.mem.{0 0} (set.{0} (prod.{0 0} β β)) (filter.{0} (prod.{0 0} β β)) (@filter.has_mem.{0} (prod.{0 0} β β)) r (@uniformity.{0} β _inst_2) → @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) (@set_of.{u} (prod.{u u} α α) (λ (x : prod.{u u} α α), @has_mem.mem.{0 0} (prod.{0 0} β β) (set.{0} (prod.{0 0} β β)) (@set.has_mem.{0} (prod.{0 0} β β)) (@prod.mk.{0 0} β β (f (@prod.fst.{u u} α α x)) (f (@prod.snd.{u u} α α x))) r)) (@uniformity.{u} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : metric_space.{u} α], @uniform_continuous.{u 0} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) real (@prod.uniform_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space) (λ (p : prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))), @has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) p) (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) p))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{0} (prod.{0 0} real real)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{0 0} (set.{0} (prod.{0 0} real real)) (filter.{0} (prod.{0 0} real real)) (@filter.has_mem.{0} (prod.{0 0} real real)) r (@uniformity.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The new distance is uniformly continuous.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                      </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
r : set.{0} (prod.{0 0} real real) :=
  @set_of.{0} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       @has_lt.lt.{0} real real.has_lt
         (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@prod.fst.{0 0} real real p)
            (@prod.snd.{0 0} real real p))
         ε),
this :
  @has_mem.mem.{0 0} (set.{0} (prod.{0 0} real real)) (filter.{0} (prod.{0 0} real real))
    (@filter.has_mem.{0} (prod.{0 0} real real))
    r
    (@uniformity.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space))
⊢ @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
r : set.{0} (prod.{0 0} real real) :=
  @set_of.{0} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       @has_lt.lt.{0} real real.has_lt
         (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@prod.fst.{0 0} real real p)
            (@prod.snd.{0 0} real real p))
         ε),
this :
  @has_mem.mem.{0 0} (set.{0} (prod.{0 0} real real)) (filter.{0} (prod.{0 0} real real))
    (@filter.has_mem.{0} (prod.{0 0} real real))
    r
    (@uniformity.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)),
T :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (filter.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@filter.has_mem.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set_of.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (λ
        (x :
          prod.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
          @has_mem.mem.{0 0} (prod.{0 0} real real) (set.{0} (prod.{0 0} real real))
            (@set.has_mem.{0} (prod.{0 0} real real))
            (@prod.mk.{0 0} real real
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x)))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))))
            r))
    (@uniformity.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.uniform_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
⊢ @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>123      simp only [uniformity_prod_eq_prod, mem_prod_iff, exists_prop,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='uniformity_prod_eq_prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='filter.mem_prod_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='exists_prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 687, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 1531, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/logic/basic.lean&#x27;, &#x27;line&#x27;: 544, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} [_inst_1 : uniform_space.{?l_1} α] [_inst_2 : uniform_space.{?l_2} β], @eq.{(max ?l_1 ?l_2)+1} (filter.{(max ?l_1 ?l_2)} (prod.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β) (prod.{?l_1 ?l_2} α β))) (@uniformity.{(max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β) (@prod.uniform_space.{?l_1 ?l_2} α β _inst_1 _inst_2)) (@filter.map.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} (prod.{?l_1 ?l_1} α α) (prod.{?l_2 ?l_2} β β)) (prod.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β) (prod.{?l_1 ?l_2} α β)) (λ (p : prod.{?l_1 ?l_2} (prod.{?l_1 ?l_1} α α) (prod.{?l_2 ?l_2} β β)), @prod.mk.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β) (prod.{?l_1 ?l_2} α β) (@prod.mk.{?l_1 ?l_2} α β (@prod.fst.{?l_1 ?l_1} α α (@prod.fst.{?l_1 ?l_2} (prod.{?l_1 ?l_1} α α) (prod.{?l_2 ?l_2} β β) p)) (@prod.fst.{?l_2 ?l_2} β β (@prod.snd.{?l_1 ?l_2} (prod.{?l_1 ?l_1} α α) (prod.{?l_2 ?l_2} β β) p))) (@prod.mk.{?l_1 ?l_2} α β (@prod.snd.{?l_1 ?l_1} α α (@prod.fst.{?l_1 ?l_2} (prod.{?l_1 ?l_1} α α) (prod.{?l_2 ?l_2} β β) p)) (@prod.snd.{?l_2 ?l_2} β β (@prod.snd.{?l_1 ?l_2} (prod.{?l_1 ?l_1} α α) (prod.{?l_2 ?l_2} β β) p)))) (@filter.prod.{?l_1 ?l_2} (prod.{?l_1 ?l_1} α α) (prod.{?l_2 ?l_2} β β) (@uniformity.{?l_1} α _inst_1) (@uniformity.{?l_2} β _inst_2)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {s : set.{(max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β)} {f : filter.{?l_1} α} {g : filter.{?l_2} β}, iff (@has_mem.mem.{(max ?l_1 ?l_2) (max ?l_1 ?l_2)} (set.{(max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β)) (filter.{(max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β)) (@filter.has_mem.{(max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β)) s (@filter.prod.{?l_1 ?l_2} α β f g)) (@Exists.{?l_1+1} (set.{?l_1} α) (λ (t₁ : set.{?l_1} α), @Exists.{0} (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} α) (filter.{?l_1} α) (@filter.has_mem.{?l_1} α) t₁ f) (λ (H : @has_mem.mem.{?l_1 ?l_1} (set.{?l_1} α) (filter.{?l_1} α) (@filter.has_mem.{?l_1} α) t₁ f), @Exists.{?l_2+1} (set.{?l_2} β) (λ (t₂ : set.{?l_2} β), @Exists.{0} (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} β) (filter.{?l_2} β) (@filter.has_mem.{?l_2} β) t₂ g) (λ (H : @has_mem.mem.{?l_2 ?l_2} (set.{?l_2} β) (filter.{?l_2} β) (@filter.has_mem.{?l_2} β) t₂ g), @has_subset.subset.{(max ?l_1 ?l_2)} (set.{(max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β)) (@set.has_subset.{(max ?l_1 ?l_2)} (prod.{?l_1 ?l_2} α β)) (@set.prod.{?l_1 ?l_2} α β t₁ t₂) s)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {p q : Prop}, iff (@Exists.{0} p (λ (h : p), q)) (and p q)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
r : set.{0} (prod.{0 0} real real) :=
  @set_of.{0} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       @has_lt.lt.{0} real real.has_lt
         (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@prod.fst.{0 0} real real p)
            (@prod.snd.{0 0} real real p))
         ε),
this :
  @has_mem.mem.{0 0} (set.{0} (prod.{0 0} real real)) (filter.{0} (prod.{0 0} real real))
    (@filter.has_mem.{0} (prod.{0 0} real real))
    r
    (@uniformity.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)),
T :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (filter.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@filter.has_mem.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set_of.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (λ
        (x :
          prod.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
          @has_mem.mem.{0 0} (prod.{0 0} real real) (set.{0} (prod.{0 0} real real))
            (@set.has_mem.{0} (prod.{0 0} real real))
            (@prod.mk.{0 0} real real
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x)))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))))
            r))
    (@uniformity.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.uniform_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
⊢ @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>124                 filter.mem_map, set.mem_set_of_eq] at T,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='filter.mem_map'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.mem_set_of_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 776, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 66, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {β : Type ?l_2} {f : filter.{?l_1} α} {m : α → β} {t : set.{?l_2} β}, iff (@has_mem.mem.{?l_2 ?l_2} (set.{?l_2} β) (filter.{?l_2} β) (@filter.has_mem.{?l_2} β) t (@filter.map.{?l_1 ?l_2} α β m f)) (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} α) (filter.{?l_1} α) (@filter.has_mem.{?l_1} α) (@set_of.{?l_1} α (λ (x : α), @has_mem.mem.{?l_2 ?l_2} β (set.{?l_2} β) (@set.has_mem.{?l_2} β) (m x) t)) f)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {a : α} {p : α → Prop}, @eq.{1} Prop (@has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) a (@set_of.{?l_1} α (λ (a : α), p a))) (p a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                 </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
r : set.{0} (prod.{0 0} real real) :=
  @set_of.{0} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       @has_lt.lt.{0} real real.has_lt
         (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@prod.fst.{0 0} real real p)
            (@prod.snd.{0 0} real real p))
         ε),
this :
  @has_mem.mem.{0 0} (set.{0} (prod.{0 0} real real)) (filter.{0} (prod.{0 0} real real))
    (@filter.has_mem.{0} (prod.{0 0} real real))
    r
    (@uniformity.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)),
T :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (filter.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@filter.has_mem.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set_of.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (λ
        (x :
          prod.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
          @has_mem.mem.{0 0} (prod.{0 0} real real) (set.{0} (prod.{0 0} real real))
            (@set.has_mem.{0} (prod.{0 0} real real))
            (@prod.mk.{0 0} real real
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x)))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))))
            r))
    (@uniformity.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.uniform_space.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
⊢ @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
r : set.{0} (prod.{0 0} real real) :=
  @set_of.{0} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       @has_lt.lt.{0} real real.has_lt
         (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@prod.fst.{0 0} real real p)
            (@prod.snd.{0 0} real real p))
         ε),
this :
  @has_mem.mem.{0 0} (set.{0} (prod.{0 0} real real)) (filter.{0} (prod.{0 0} real real))
    (@filter.has_mem.{0} (prod.{0 0} real real))
    r
    (@uniformity.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)),
T :
  @Exists.{u+1}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (λ
     (t₁ :
       set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
       and
         (@has_mem.mem.{u u}
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (set.{u}
               (set.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
            (@set.has_mem.{u}
               (set.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
            t₁
            (@filter.sets.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
         (@Exists.{u+1}
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (λ
             (t₂ :
               set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
               and
                 (@has_mem.mem.{u u}
                    (set.{u}
                       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                    (set.{u}
                       (set.{u}
                          (prod.{u u}
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
                    (@set.has_mem.{u}
                       (set.{u}
                          (prod.{u u}
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
                    t₂
                    (@filter.sets.{u}
                       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                       (@uniformity.{u}
                          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                          (@uniform_space.completion.uniform_space.{u} α
                             (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
                 (@has_subset.subset.{u}
                    (set.{u}
                       (prod.{u u}
                          (prod.{u u}
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                          (prod.{u u}
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
                    (@set.has_subset.{u}
                       (prod.{u u}
                          (prod.{u u}
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                          (prod.{u u}
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
                    (@set.prod.{u u}
                       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                       t₁
                       t₂)
                    (@set_of.{u}
                       (prod.{u u}
                          (prod.{u u}
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                          (prod.{u u}
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                       (λ
                        (x :
                          prod.{u u}
                            (prod.{u u}
                               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                            (prod.{u u}
                               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
                          @has_lt.lt.{0} real real.has_lt
                            (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space)
                               (@has_dist.dist.{u}
                                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                  (@metric.has_dist.{u} α _inst_1)
                                  (@prod.fst.{u u}
                                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                     (@prod.fst.{u u}
                                        (prod.{u u}
                                           (@uniform_space.completion.{u} α
                                              (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                           (@uniform_space.completion.{u} α
                                              (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                                        (prod.{u u}
                                           (@uniform_space.completion.{u} α
                                              (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                           (@uniform_space.completion.{u} α
                                              (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                                        x))
                                  (@prod.fst.{u u}
                                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                     (@prod.snd.{u u}
                                        (prod.{u u}
                                           (@uniform_space.completion.{u} α
                                              (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                           (@uniform_space.completion.{u} α
                                              (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                                        (prod.{u u}
                                           (@uniform_space.completion.{u} α
                                              (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                           (@uniform_space.completion.{u} α
                                              (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                                        x)))
                               (@has_dist.dist.{u}
                                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                  (@metric.has_dist.{u} α _inst_1)
                                  (@prod.snd.{u u}
                                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                     (@prod.fst.{u u}
                                        (prod.{u u}
                                           (@uniform_space.completion.{u} α
                                              (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                           (@uniform_space.completion.{u} α
                                              (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                                        (prod.{u u}
                                           (@uniform_space.completion.{u} α
                                              (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                           (@uniform_space.completion.{u} α
                                              (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                                        x))
                                  (@prod.snd.{u u}
                                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                     (@prod.snd.{u u}
                                        (prod.{u u}
                                           (@uniform_space.completion.{u} α
                                              (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                           (@uniform_space.completion.{u} α
                                              (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                                        (prod.{u u}
                                           (@uniform_space.completion.{u} α
                                              (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                           (@uniform_space.completion.{u} α
                                              (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                                        x))))
                            ε))))))
⊢ @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>125      rcases T with ⟨t1, ht1, t2, ht2, ht⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='T'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@Exists.{u+1} (set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (λ (t₁ : set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))), and (@has_mem.mem.{u u} (set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (set.{u} (set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))) (@set.has_mem.{u} (set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))) t₁ (@filter.sets.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))) (@Exists.{u+1} (set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (λ (t₂ : set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))), and (@has_mem.mem.{u u} (set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (set.{u} (set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))) (@set.has_mem.{u} (set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))) t₂ (@filter.sets.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))) (@has_subset.subset.{u} (set.{u} (prod.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))) (@set.has_subset.{u} (prod.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))) (@set.prod.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) t₁ t₂) (@set_of.{u} (prod.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (λ (x : prod.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))), @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@prod.fst.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) x)) (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@prod.snd.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) x))) (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@prod.fst.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) x)) (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@prod.snd.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) x)))) ε))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
r : set.{0} (prod.{0 0} real real) :=
  @set_of.{0} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       @has_lt.lt.{0} real real.has_lt
         (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@prod.fst.{0 0} real real p)
            (@prod.snd.{0 0} real real p))
         ε),
this :
  @has_mem.mem.{0 0} (set.{0} (prod.{0 0} real real)) (filter.{0} (prod.{0 0} real real))
    (@filter.has_mem.{0} (prod.{0 0} real real))
    r
    (@uniformity.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)),
T :
  @Exists.{u+1}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (λ
     (t₁ :
       set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
       and
         (@has_mem.mem.{u u}
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (set.{u}
               (set.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
            (@set.has_mem.{u}
               (set.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
            t₁
            (@filter.sets.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
         (@Exists.{u+1}
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (λ
             (t₂ :
               set.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
               and
                 (@has_mem.mem.{u u}
                    (set.{u}
                       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                    (set.{u}
                       (set.{u}
                          (prod.{u u}
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
                    (@set.has_mem.{u}
                       (set.{u}
                          (prod.{u u}
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
                    t₂
                    (@filter.sets.{u}
                       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                       (@uniformity.{u}
                          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                          (@uniform_space.completion.uniform_space.{u} α
                             (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
                 (@has_subset.subset.{u}
                    (set.{u}
                       (prod.{u u}
                          (prod.{u u}
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                          (prod.{u u}
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
                    (@set.has_subset.{u}
                       (prod.{u u}
                          (prod.{u u}
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                          (prod.{u u}
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
                    (@set.prod.{u u}
                       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                       t₁
                       t₂)
                    (@set_of.{u}
                       (prod.{u u}
                          (prod.{u u}
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                          (prod.{u u}
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                       (λ
                        (x :
                          prod.{u u}
                            (prod.{u u}
                               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                            (prod.{u u}
                               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
                          @has_lt.lt.{0} real real.has_lt
                            (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space)
                               (@has_dist.dist.{u}
                                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                  (@metric.has_dist.{u} α _inst_1)
                                  (@prod.fst.{u u}
                                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                     (@prod.fst.{u u}
                                        (prod.{u u}
                                           (@uniform_space.completion.{u} α
                                              (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                           (@uniform_space.completion.{u} α
                                              (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                                        (prod.{u u}
                                           (@uniform_space.completion.{u} α
                                              (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                           (@uniform_space.completion.{u} α
                                              (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                                        x))
                                  (@prod.fst.{u u}
                                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                     (@prod.snd.{u u}
                                        (prod.{u u}
                                           (@uniform_space.completion.{u} α
                                              (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                           (@uniform_space.completion.{u} α
                                              (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                                        (prod.{u u}
                                           (@uniform_space.completion.{u} α
                                              (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                           (@uniform_space.completion.{u} α
                                              (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                                        x)))
                               (@has_dist.dist.{u}
                                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                  (@metric.has_dist.{u} α _inst_1)
                                  (@prod.snd.{u u}
                                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                     (@prod.fst.{u u}
                                        (prod.{u u}
                                           (@uniform_space.completion.{u} α
                                              (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                           (@uniform_space.completion.{u} α
                                              (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                                        (prod.{u u}
                                           (@uniform_space.completion.{u} α
                                              (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                           (@uniform_space.completion.{u} α
                                              (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                                        x))
                                  (@prod.snd.{u u}
                                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                     (@prod.snd.{u u}
                                        (prod.{u u}
                                           (@uniform_space.completion.{u} α
                                              (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                           (@uniform_space.completion.{u} α
                                              (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                                        (prod.{u u}
                                           (@uniform_space.completion.{u} α
                                              (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                           (@uniform_space.completion.{u} α
                                              (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                                        x))))
                            ε))))))
⊢ @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
r : set.{0} (prod.{0 0} real real) :=
  @set_of.{0} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       @has_lt.lt.{0} real real.has_lt
         (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@prod.fst.{0 0} real real p)
            (@prod.snd.{0 0} real real p))
         ε),
this :
  @has_mem.mem.{0 0} (set.{0} (prod.{0 0} real real)) (filter.{0} (prod.{0 0} real real))
    (@filter.has_mem.{0} (prod.{0 0} real real))
    r
    (@uniformity.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)),
t1 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht1 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t1
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
t2 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht2 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t2
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
ht :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_subset.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       t1
       t2)
    (@set_of.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (λ
        (x :
          prod.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space)
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x)))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))))
            ε))
⊢ @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>126      refine mem_sets_of_superset ht1 _,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='blue'><a title='filter.mem_sets_of_superset'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ht1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 121, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {f : filter.{u} α} {x y : set.{u} α}, @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) x f → @has_subset.subset.{u} (set.{u} α) (@set.has_subset.{u} α) x y → @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) y f'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (set.{u} (set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))) (@set.has_mem.{u} (set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))) t1 (@filter.sets.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
r : set.{0} (prod.{0 0} real real) :=
  @set_of.{0} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       @has_lt.lt.{0} real real.has_lt
         (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@prod.fst.{0 0} real real p)
            (@prod.snd.{0 0} real real p))
         ε),
this :
  @has_mem.mem.{0 0} (set.{0} (prod.{0 0} real real)) (filter.{0} (prod.{0 0} real real))
    (@filter.has_mem.{0} (prod.{0 0} real real))
    r
    (@uniformity.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)),
t1 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht1 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t1
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
t2 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht2 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t2
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
ht :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_subset.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       t1
       t2)
    (@set_of.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (λ
        (x :
          prod.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space)
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x)))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))))
            ε))
⊢ @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
r : set.{0} (prod.{0 0} real real) :=
  @set_of.{0} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       @has_lt.lt.{0} real real.has_lt
         (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@prod.fst.{0 0} real real p)
            (@prod.snd.{0 0} real real p))
         ε),
this :
  @has_mem.mem.{0 0} (set.{0} (prod.{0 0} real real)) (filter.{0} (prod.{0 0} real real))
    (@filter.has_mem.{0} (prod.{0 0} real real))
    r
    (@uniformity.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)),
t1 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht1 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t1
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
t2 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht2 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t2
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
ht :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_subset.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       t1
       t2)
    (@set_of.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (λ
        (x :
          prod.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space)
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x)))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))))
            ε))
⊢ @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t1
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>127      have A : ∀a b : completion α, (a, b) ∈ t1 → dist a b &lt; ε,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='blue'><a title='uniform_space.completion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_dist.dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 322, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u) [_inst_1 : uniform_space.{u} α], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@set.has_mem.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) a b) t1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [c : has_dist.{u} α], α → α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='Hausdorff completion of `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
r : set.{0} (prod.{0 0} real real) :=
  @set_of.{0} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       @has_lt.lt.{0} real real.has_lt
         (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@prod.fst.{0 0} real real p)
            (@prod.snd.{0 0} real real p))
         ε),
this :
  @has_mem.mem.{0 0} (set.{0} (prod.{0 0} real real)) (filter.{0} (prod.{0 0} real real))
    (@filter.has_mem.{0} (prod.{0 0} real real))
    r
    (@uniformity.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)),
t1 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht1 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t1
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
t2 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht2 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t2
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
ht :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_subset.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       t1
       t2)
    (@set_of.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (λ
        (x :
          prod.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space)
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x)))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))))
            ε))
⊢ @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t1
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
r : set.{0} (prod.{0 0} real real) :=
  @set_of.{0} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       @has_lt.lt.{0} real real.has_lt
         (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@prod.fst.{0 0} real real p)
            (@prod.snd.{0 0} real real p))
         ε),
this :
  @has_mem.mem.{0 0} (set.{0} (prod.{0 0} real real)) (filter.{0} (prod.{0 0} real real))
    (@filter.has_mem.{0} (prod.{0 0} real real))
    r
    (@uniformity.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)),
t1 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht1 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t1
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
t2 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht2 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t2
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
ht :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_subset.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       t1
       t2)
    (@set_of.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (λ
        (x :
          prod.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space)
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x)))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))))
            ε))
⊢ ∀ (a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      t1 →
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε

α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
r : set.{0} (prod.{0 0} real real) :=
  @set_of.{0} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       @has_lt.lt.{0} real real.has_lt
         (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@prod.fst.{0 0} real real p)
            (@prod.snd.{0 0} real real p))
         ε),
this :
  @has_mem.mem.{0 0} (set.{0} (prod.{0 0} real real)) (filter.{0} (prod.{0 0} real real))
    (@filter.has_mem.{0} (prod.{0 0} real real))
    r
    (@uniformity.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)),
t1 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht1 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t1
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
t2 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht2 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t2
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
ht :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_subset.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       t1
       t2)
    (@set_of.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (λ
        (x :
          prod.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space)
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x)))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))))
            ε)),
A :
  ∀ (a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      t1 →
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε
⊢ @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t1
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>128      { assume a b hab,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 905, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (sum.{0 0} pexpr (list.{0} pexpr)) (λ (a : sum.{0 0} pexpr (list.{0} pexpr)), @sum.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) `(pexpr) `(list.{0} pexpr) a) (@has_orelse.orelse.{0 0} lean.parser.{0} (@alternative.to_has_orelse.{0 0} lean.parser.{0} lean.parser.alternative) (sum.{0 0} pexpr (list.{0} pexpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) pexpr (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inl.{0 0} pexpr (list.{0} pexpr)) (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) (@functor.map.{0 0} lean.parser.{0} (@applicative.to_functor.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) (list.{0} pexpr) (sum.{0 0} pexpr (list.{0} pexpr)) (@sum.inr.{0 0} pexpr (list.{0} pexpr)) (interactive.parse_binders interactive.types.tac_rbp))) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Assuming the target of the goal is a Pi or a let, `assume h : t` unifies the type of the binder with `t` and introduces it with name `h`, just like `intro h`. If `h` is absent, the tactic uses the name `this`. If `t` is omitted, it will be inferred.

`assume (h₁ : t₁) ... (hₙ : tₙ)` introduces multiple hypotheses. Any of the types may be omitted, but the names must be present.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='assume'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;(: expr | &lt;binders&gt;)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
r : set.{0} (prod.{0 0} real real) :=
  @set_of.{0} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       @has_lt.lt.{0} real real.has_lt
         (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@prod.fst.{0 0} real real p)
            (@prod.snd.{0 0} real real p))
         ε),
this :
  @has_mem.mem.{0 0} (set.{0} (prod.{0 0} real real)) (filter.{0} (prod.{0 0} real real))
    (@filter.has_mem.{0} (prod.{0 0} real real))
    r
    (@uniformity.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)),
t1 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht1 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t1
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
t2 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht2 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t2
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
ht :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_subset.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       t1
       t2)
    (@set_of.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (λ
        (x :
          prod.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space)
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x)))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))))
            ε))
⊢ ∀ (a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      t1 →
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε

α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
r : set.{0} (prod.{0 0} real real) :=
  @set_of.{0} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       @has_lt.lt.{0} real real.has_lt
         (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@prod.fst.{0 0} real real p)
            (@prod.snd.{0 0} real real p))
         ε),
this :
  @has_mem.mem.{0 0} (set.{0} (prod.{0 0} real real)) (filter.{0} (prod.{0 0} real real))
    (@filter.has_mem.{0} (prod.{0 0} real real))
    r
    (@uniformity.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)),
t1 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht1 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t1
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
t2 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht2 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t2
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
ht :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_subset.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       t1
       t2)
    (@set_of.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (λ
        (x :
          prod.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space)
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x)))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))))
            ε)),
A :
  ∀ (a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      t1 →
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε
⊢ @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t1
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
r : set.{0} (prod.{0 0} real real) :=
  @set_of.{0} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       @has_lt.lt.{0} real real.has_lt
         (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@prod.fst.{0 0} real real p)
            (@prod.snd.{0 0} real real p))
         ε),
this :
  @has_mem.mem.{0 0} (set.{0} (prod.{0 0} real real)) (filter.{0} (prod.{0 0} real real))
    (@filter.has_mem.{0} (prod.{0 0} real real))
    r
    (@uniformity.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)),
t1 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht1 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t1
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
t2 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht2 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t2
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
ht :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_subset.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       t1
       t2)
    (@set_of.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (λ
        (x :
          prod.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space)
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x)))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))))
            ε))
⊢ ∀ (a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      t1 →
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
r : set.{0} (prod.{0 0} real real) :=
  @set_of.{0} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       @has_lt.lt.{0} real real.has_lt
         (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@prod.fst.{0 0} real real p)
            (@prod.snd.{0 0} real real p))
         ε),
this :
  @has_mem.mem.{0 0} (set.{0} (prod.{0 0} real real)) (filter.{0} (prod.{0 0} real real))
    (@filter.has_mem.{0} (prod.{0 0} real real))
    r
    (@uniformity.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)),
t1 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht1 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t1
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
t2 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht2 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t2
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
ht :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_subset.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       t1
       t2)
    (@set_of.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (λ
        (x :
          prod.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space)
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x)))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))))
            ε)),
a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hab :
  @has_mem.mem.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       a
       b)
    t1
⊢ @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       a
       b)
    ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>129        have : ((a, b), (a, a)) ∈ set.prod t1 t2 := ⟨hab, refl_mem_uniformity ht2⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                  </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='prod.mk'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='set.prod'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='t2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='blue'><a title='hab'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='refl_mem_uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ht2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 1408, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 167, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, α → β → prod.{u u} α β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, set.{u} α → set.{u} β → set.{u} (prod.{u u} α β)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@has_mem.mem.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@set.has_mem.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) a b) t1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_1 : uniform_space.{u} α] {x : α} {s : set.{u} (prod.{u u} α α)}, @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) s (@uniformity.{u} α _inst_1) → @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α x x) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (set.{u} (set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))) (@set.has_mem.{u} (set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))) t2 (@filter.sets.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The cartesian product `prod s t` is the set of `(a, b)`
 such that `a ∈ s` and `b ∈ t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
r : set.{0} (prod.{0 0} real real) :=
  @set_of.{0} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       @has_lt.lt.{0} real real.has_lt
         (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@prod.fst.{0 0} real real p)
            (@prod.snd.{0 0} real real p))
         ε),
this :
  @has_mem.mem.{0 0} (set.{0} (prod.{0 0} real real)) (filter.{0} (prod.{0 0} real real))
    (@filter.has_mem.{0} (prod.{0 0} real real))
    r
    (@uniformity.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)),
t1 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht1 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t1
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
t2 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht2 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t2
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
ht :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_subset.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       t1
       t2)
    (@set_of.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (λ
        (x :
          prod.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space)
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x)))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))))
            ε)),
a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hab :
  @has_mem.mem.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       a
       b)
    t1
⊢ @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       a
       b)
    ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
r : set.{0} (prod.{0 0} real real) :=
  @set_of.{0} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       @has_lt.lt.{0} real real.has_lt
         (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@prod.fst.{0 0} real real p)
            (@prod.snd.{0 0} real real p))
         ε),
this :
  @has_mem.mem.{0 0} (set.{0} (prod.{0 0} real real)) (filter.{0} (prod.{0 0} real real))
    (@filter.has_mem.{0} (prod.{0 0} real real))
    r
    (@uniformity.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)),
t1 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht1 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t1
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
t2 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht2 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t2
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
ht :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_subset.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       t1
       t2)
    (@set_of.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (λ
        (x :
          prod.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space)
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x)))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))))
            ε)),
a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hab :
  @has_mem.mem.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       a
       b)
    t1,
this :
  @has_mem.mem.{u u}
    (prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@prod.mk.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          a
          b)
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          a
          a))
    (@set.prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       t1
       t2)
⊢ @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       a
       b)
    ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>130        have I := ht this,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                </code><font color='blue'><a title='ht'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_subset.subset.{u} (set.{u} (prod.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))) (@set.has_subset.{u} (prod.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))) (@set.prod.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) t1 t2) (@set_of.{u} (prod.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (λ (x : prod.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))), @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@prod.fst.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) x)) (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@prod.snd.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) x))) (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@prod.fst.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) x)) (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@prod.snd.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) x)))) ε))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} (prod.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (set.{u} (prod.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))) (@set.has_mem.{u} (prod.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))) (@prod.mk.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) a b) (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) a a)) (@set.prod.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) t1 t2)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
r : set.{0} (prod.{0 0} real real) :=
  @set_of.{0} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       @has_lt.lt.{0} real real.has_lt
         (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@prod.fst.{0 0} real real p)
            (@prod.snd.{0 0} real real p))
         ε),
this :
  @has_mem.mem.{0 0} (set.{0} (prod.{0 0} real real)) (filter.{0} (prod.{0 0} real real))
    (@filter.has_mem.{0} (prod.{0 0} real real))
    r
    (@uniformity.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)),
t1 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht1 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t1
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
t2 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht2 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t2
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
ht :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_subset.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       t1
       t2)
    (@set_of.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (λ
        (x :
          prod.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space)
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x)))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))))
            ε)),
a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hab :
  @has_mem.mem.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       a
       b)
    t1,
this :
  @has_mem.mem.{u u}
    (prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@prod.mk.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          a
          b)
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          a
          a))
    (@set.prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       t1
       t2)
⊢ @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       a
       b)
    ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
r : set.{0} (prod.{0 0} real real) :=
  @set_of.{0} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       @has_lt.lt.{0} real real.has_lt
         (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@prod.fst.{0 0} real real p)
            (@prod.snd.{0 0} real real p))
         ε),
this :
  @has_mem.mem.{0 0} (set.{0} (prod.{0 0} real real)) (filter.{0} (prod.{0 0} real real))
    (@filter.has_mem.{0} (prod.{0 0} real real))
    r
    (@uniformity.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)),
t1 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht1 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t1
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
t2 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht2 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t2
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
ht :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_subset.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       t1
       t2)
    (@set_of.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (λ
        (x :
          prod.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space)
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x)))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))))
            ε)),
a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hab :
  @has_mem.mem.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       a
       b)
    t1,
this :
  @has_mem.mem.{u u}
    (prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@prod.mk.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          a
          b)
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          a
          a))
    (@set.prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       t1
       t2),
I :
  @has_mem.mem.{u u}
    (prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@prod.mk.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          a
          b)
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          a
          a))
    (@set_of.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (λ
        (x :
          prod.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space)
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x)))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))))
            ε))
⊢ @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       a
       b)
    ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>131        simp [completion.dist_self, real.dist_eq, completion.dist_comm] at I,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='metric.completion.dist_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='real.dist_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='metric.completion.dist_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 42, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 653, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 52, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : metric_space.{?l_1} α] (x : @uniform_space.completion.{?l_1} α (@metric_space.to_uniform_space&#x27;.{?l_1} α _inst_1)), @eq.{1} real (@has_dist.dist.{?l_1} (@uniform_space.completion.{?l_1} α (@metric_space.to_uniform_space&#x27;.{?l_1} α _inst_1)) (@metric.has_dist.{?l_1} α _inst_1) x x) (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (x y : real), @eq.{1} real (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) x y) (@abs.{0} real real.decidable_linear_ordered_comm_group (@has_sub.sub.{0} real (@add_group_has_sub.{0} real real.add_group) x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : metric_space.{?l_1} α] (x y : @uniform_space.completion.{?l_1} α (@metric_space.to_uniform_space&#x27;.{?l_1} α _inst_1)), @eq.{1} real (@has_dist.dist.{?l_1} (@uniform_space.completion.{?l_1} α (@metric_space.to_uniform_space&#x27;.{?l_1} α _inst_1)) (@metric.has_dist.{?l_1} α _inst_1) x y) (@has_dist.dist.{?l_1} (@uniform_space.completion.{?l_1} α (@metric_space.to_uniform_space&#x27;.{?l_1} α _inst_1)) (@metric.has_dist.{?l_1} α _inst_1) y x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                    </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
r : set.{0} (prod.{0 0} real real) :=
  @set_of.{0} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       @has_lt.lt.{0} real real.has_lt
         (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@prod.fst.{0 0} real real p)
            (@prod.snd.{0 0} real real p))
         ε),
this :
  @has_mem.mem.{0 0} (set.{0} (prod.{0 0} real real)) (filter.{0} (prod.{0 0} real real))
    (@filter.has_mem.{0} (prod.{0 0} real real))
    r
    (@uniformity.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)),
t1 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht1 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t1
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
t2 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht2 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t2
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
ht :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_subset.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       t1
       t2)
    (@set_of.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (λ
        (x :
          prod.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space)
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x)))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))))
            ε)),
a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hab :
  @has_mem.mem.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       a
       b)
    t1,
this :
  @has_mem.mem.{u u}
    (prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@prod.mk.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          a
          b)
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          a
          a))
    (@set.prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       t1
       t2),
I :
  @has_mem.mem.{u u}
    (prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@prod.mk.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          a
          b)
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          a
          a))
    (@set_of.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (λ
        (x :
          prod.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space)
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x)))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))))
            ε))
⊢ @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       a
       b)
    ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
r : set.{0} (prod.{0 0} real real) :=
  @set_of.{0} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       @has_lt.lt.{0} real real.has_lt
         (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@prod.fst.{0 0} real real p)
            (@prod.snd.{0 0} real real p))
         ε),
this :
  @has_mem.mem.{0 0} (set.{0} (prod.{0 0} real real)) (filter.{0} (prod.{0 0} real real))
    (@filter.has_mem.{0} (prod.{0 0} real real))
    r
    (@uniformity.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)),
t1 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht1 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t1
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
t2 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht2 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t2
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
ht :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_subset.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       t1
       t2)
    (@set_of.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (λ
        (x :
          prod.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space)
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x)))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))))
            ε)),
a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hab :
  @has_mem.mem.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       a
       b)
    t1,
this :
  @has_mem.mem.{u u}
    (prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@prod.mk.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          a
          b)
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          a
          a))
    (@set.prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       t1
       t2),
I :
  @has_lt.lt.{0} real real.has_lt
    (@abs.{0} real real.decidable_linear_ordered_comm_group
       (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@metric.has_dist.{u} α _inst_1)
          a
          b))
    ε
⊢ @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       a
       b)
    ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>132        exact lt_of_le_of_lt (le_abs_self _) I },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='lt_of_le_of_lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='le_abs_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='I'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/order.lean&#x27;, &#x27;line&#x27;: 107, &#x27;column&#x27;: 15}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 247, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : preorder.{0} α] {a b c : α}, @has_le.le.{0} α (@preorder.to_has_le.{0} α _inst_1) a b → @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) b c → @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α _inst_1) a c'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type} [_inst_1 : decidable_linear_ordered_comm_group.{0} α] (a : α), @has_le.le.{0} α (@preorder.to_has_le.{0} α (@partial_order.to_preorder.{0} α (@ordered_comm_group.to_partial_order.{0} α (@decidable_linear_ordered_comm_group.to_ordered_comm_group.{0} α _inst_1)))) a (@abs.{0} α _inst_1 a)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} real real.has_lt (@abs.{0} real real.decidable_linear_ordered_comm_group (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) a b)) ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
r : set.{0} (prod.{0 0} real real) :=
  @set_of.{0} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       @has_lt.lt.{0} real real.has_lt
         (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@prod.fst.{0 0} real real p)
            (@prod.snd.{0 0} real real p))
         ε),
this :
  @has_mem.mem.{0 0} (set.{0} (prod.{0 0} real real)) (filter.{0} (prod.{0 0} real real))
    (@filter.has_mem.{0} (prod.{0 0} real real))
    r
    (@uniformity.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)),
t1 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht1 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t1
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
t2 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht2 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t2
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
ht :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_subset.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       t1
       t2)
    (@set_of.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (λ
        (x :
          prod.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space)
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x)))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))))
            ε)),
a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hab :
  @has_mem.mem.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       a
       b)
    t1,
this :
  @has_mem.mem.{u u}
    (prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@prod.mk.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          a
          b)
       (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          a
          a))
    (@set.prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       t1
       t2),
I :
  @has_lt.lt.{0} real real.has_lt
    (@abs.{0} real real.decidable_linear_ordered_comm_group
       (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@metric.has_dist.{u} α _inst_1)
          a
          b))
    ε
⊢ @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       a
       b)
    ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
r : set.{0} (prod.{0 0} real real) :=
  @set_of.{0} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       @has_lt.lt.{0} real real.has_lt
         (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@prod.fst.{0 0} real real p)
            (@prod.snd.{0 0} real real p))
         ε),
this :
  @has_mem.mem.{0 0} (set.{0} (prod.{0 0} real real)) (filter.{0} (prod.{0 0} real real))
    (@filter.has_mem.{0} (prod.{0 0} real real))
    r
    (@uniformity.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)),
t1 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht1 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t1
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
t2 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht2 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t2
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
ht :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_subset.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       t1
       t2)
    (@set_of.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (λ
        (x :
          prod.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space)
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x)))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))))
            ε)),
A :
  ∀ (a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      t1 →
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε
⊢ @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t1
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>133      show t1 ⊆ s,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='t1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='has_subset.subset'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 327, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1529, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [c : has_subset.{u} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`show t` finds the first goal whose target unifies with `t`. It makes that the main goal, performs the unification, and replaces the target with the unified version of `t`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='show'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
r : set.{0} (prod.{0 0} real real) :=
  @set_of.{0} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       @has_lt.lt.{0} real real.has_lt
         (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@prod.fst.{0 0} real real p)
            (@prod.snd.{0 0} real real p))
         ε),
this :
  @has_mem.mem.{0 0} (set.{0} (prod.{0 0} real real)) (filter.{0} (prod.{0 0} real real))
    (@filter.has_mem.{0} (prod.{0 0} real real))
    r
    (@uniformity.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)),
t1 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht1 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t1
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
t2 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht2 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t2
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
ht :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_subset.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       t1
       t2)
    (@set_of.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (λ
        (x :
          prod.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space)
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x)))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))))
            ε)),
A :
  ∀ (a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      t1 →
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε
⊢ @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t1
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>134      { rintros ⟨a, b⟩ hp,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 450, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Alias for `rintro`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='rintros'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
r : set.{0} (prod.{0 0} real real) :=
  @set_of.{0} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       @has_lt.lt.{0} real real.has_lt
         (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@prod.fst.{0 0} real real p)
            (@prod.snd.{0 0} real real p))
         ε),
this :
  @has_mem.mem.{0 0} (set.{0} (prod.{0 0} real real)) (filter.{0} (prod.{0 0} real real))
    (@filter.has_mem.{0} (prod.{0 0} real real))
    r
    (@uniformity.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)),
t1 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht1 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t1
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
t2 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht2 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t2
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
ht :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_subset.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       t1
       t2)
    (@set_of.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (λ
        (x :
          prod.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space)
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x)))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))))
            ε)),
A :
  ∀ (a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      t1 →
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε
⊢ @has_subset.subset.{u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_subset.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    t1
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
r : set.{0} (prod.{0 0} real real) :=
  @set_of.{0} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       @has_lt.lt.{0} real real.has_lt
         (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@prod.fst.{0 0} real real p)
            (@prod.snd.{0 0} real real p))
         ε),
this :
  @has_mem.mem.{0 0} (set.{0} (prod.{0 0} real real)) (filter.{0} (prod.{0 0} real real))
    (@filter.has_mem.{0} (prod.{0 0} real real))
    r
    (@uniformity.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)),
t1 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht1 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t1
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
t2 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht2 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t2
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
ht :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_subset.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       t1
       t2)
    (@set_of.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (λ
        (x :
          prod.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space)
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x)))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))))
            ε)),
A :
  ∀ (a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      t1 →
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε,
a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hp :
  @has_mem.mem.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       a
       b)
    t1
⊢ @has_mem.mem.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       a
       b)
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>135        have : dist a b &lt; ε := A a b hp,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='blue'><a title='has_dist.dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='A'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='b'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type u} [c : has_dist.{u} α], α → α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ (a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)), @has_mem.mem.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@set.has_mem.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) a b) t1 → @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) a b) ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@set.has_mem.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) a b) t1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
r : set.{0} (prod.{0 0} real real) :=
  @set_of.{0} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       @has_lt.lt.{0} real real.has_lt
         (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@prod.fst.{0 0} real real p)
            (@prod.snd.{0 0} real real p))
         ε),
this :
  @has_mem.mem.{0 0} (set.{0} (prod.{0 0} real real)) (filter.{0} (prod.{0 0} real real))
    (@filter.has_mem.{0} (prod.{0 0} real real))
    r
    (@uniformity.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)),
t1 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht1 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t1
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
t2 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht2 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t2
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
ht :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_subset.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       t1
       t2)
    (@set_of.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (λ
        (x :
          prod.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space)
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x)))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))))
            ε)),
A :
  ∀ (a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      t1 →
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε,
a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hp :
  @has_mem.mem.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       a
       b)
    t1
⊢ @has_mem.mem.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       a
       b)
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
r : set.{0} (prod.{0 0} real real) :=
  @set_of.{0} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       @has_lt.lt.{0} real real.has_lt
         (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@prod.fst.{0 0} real real p)
            (@prod.snd.{0 0} real real p))
         ε),
this :
  @has_mem.mem.{0 0} (set.{0} (prod.{0 0} real real)) (filter.{0} (prod.{0 0} real real))
    (@filter.has_mem.{0} (prod.{0 0} real real))
    r
    (@uniformity.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)),
t1 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht1 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t1
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
t2 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht2 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t2
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
ht :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_subset.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       t1
       t2)
    (@set_of.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (λ
        (x :
          prod.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space)
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x)))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))))
            ε)),
A :
  ∀ (a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      t1 →
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε,
a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hp :
  @has_mem.mem.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       a
       b)
    t1,
this :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       a
       b)
    ε
⊢ @has_mem.mem.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       a
       b)
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>136        exact hε this }}</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='hε'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)}, @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) a b) ε → @has_mem.mem.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@set.has_mem.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) a b) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) a b) ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
r : set.{0} (prod.{0 0} real real) :=
  @set_of.{0} (prod.{0 0} real real)
    (λ (p : prod.{0 0} real real),
       @has_lt.lt.{0} real real.has_lt
         (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space) (@prod.fst.{0 0} real real p)
            (@prod.snd.{0 0} real real p))
         ε),
this :
  @has_mem.mem.{0 0} (set.{0} (prod.{0 0} real real)) (filter.{0} (prod.{0 0} real real))
    (@filter.has_mem.{0} (prod.{0 0} real real))
    r
    (@uniformity.{0} real (@metric_space.to_uniform_space&#x27;.{0} real real.metric_space)),
t1 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht1 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t1
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
t2 :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ht2 :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (set.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_mem.{u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    t2
    (@filter.sets.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
ht :
  @has_subset.subset.{u}
    (set.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.has_subset.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))
    (@set.prod.{u u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
       t1
       t2)
    (@set_of.{u}
       (prod.{u u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (λ
        (x :
          prod.{u u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))),
          @has_lt.lt.{0} real real.has_lt
            (@has_dist.dist.{0} real (@metric_space.to_has_dist.{0} real real.metric_space)
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x)))
               (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@metric.has_dist.{u} α _inst_1)
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.fst.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))
                  (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@prod.snd.{u u}
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                        x))))
            ε)),
A :
  ∀ (a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      t1 →
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε,
a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
hp :
  @has_mem.mem.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       a
       b)
    t1,
this :
  @has_lt.lt.{0} real real.has_lt
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       a
       b)
    ε
⊢ @has_mem.mem.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       a
       b)
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>137  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>138  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>139  /-- If two points are at distance 0, then they coincide. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>140  protected lemma completion.eq_of_dist_eq_zero (x y : completion α) (h : dist x y = 0) : x = y :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='blue'><a title='uniform_space.completion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='has_dist.dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 322, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : uniform_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='green'><a title='Π {α : Type u_1} [c : has_dist.{u_1} α], α → α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                                     </code><font color='orange'><a title='Hausdorff completion of `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>141  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
h :
  @eq.{1} real
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
⊢ @eq.{u+1} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>142    /- This follows from the separation of `completion α` and from the description of</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
h :
  @eq.{1} real
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
⊢ @eq.{u+1} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>143    entourages in terms of the distance. -/</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
h :
  @eq.{1} real
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
⊢ @eq.{u+1} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>144    have : separated (completion α) := by apply_instance,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='separated'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_space.completion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/separation.lean&#x27;, &#x27;line&#x27;: 41, &#x27;column&#x27;: 13}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 322, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 917, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π (α : Type u) [_inst_4 : uniform_space.{u} α], Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π (α : Type u) [_inst_1 : uniform_space.{u} α], Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative name lean.parser.ident) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@alternative.to_applicative.{0 0} lean.parser.{0} lean.parser.alternative)) unit pexpr (lean.parser.tk (string.str (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) interactive.types.texpr)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Hausdorff completion of `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='`have h : t := p` adds the hypothesis `h : t` to the current goal if `p` a term of type `t`. If `t` is omitted, it will be inferred.

`have h : t` adds the hypothesis `h : t` to the current goal and opens a new subgoal with target `t`. The new subgoal becomes the main goal. If `t` is omitted, it will be replaced by a fresh metavariable.

If `h` is omitted, the name `this` is used.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='have'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;id?&#x27;, &#x27;(: expr)?&#x27;, &#x27;(:= expr)?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
h :
  @eq.{1} real
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
⊢ @eq.{u+1} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
h :
  @eq.{1} real
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
⊢ @separated.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
    (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
h :
  @eq.{1} real
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
this :
  @separated.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
    (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
⊢ @eq.{u+1} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>145    refine separated_def.1 this x y (λs hs, _),</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='separated_def'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='this'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='x'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='y'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/separation.lean&#x27;, &#x27;line&#x27;: 44, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 221, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} [_inst_4 : uniform_space.{u} α], iff (@separated.{u} α _inst_4) (∀ (x y : α), (∀ (r : set.{u} (prod.{u u} α α)), @has_mem.mem.{u u} (set.{u} (prod.{u u} α α)) (filter.{u} (prod.{u u} α α)) (@filter.has_mem.{u} (prod.{u u} α α)) r (@uniformity.{u} α _inst_4) → @has_mem.mem.{u u} (prod.{u u} α α) (set.{u} (prod.{u u} α α)) (@set.has_mem.{u} (prod.{u u} α α)) (@prod.mk.{u u} α α x y) r) → @eq.{u+1} α x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@separated.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic behaves like `exact`, but with a big difference: the user can put underscores `_` in the expression as placeholders for holes that need to be filled, and `refine` will generate as many subgoals as there are holes.

Note that some holes may be implicit. The type of each hole must either be synthesized by the system or declared by an explicit type ascription like `(_ : nat → Prop)`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='refine'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>             </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
h :
  @eq.{1} real
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
this :
  @separated.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
    (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
⊢ @eq.{u+1} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
h :
  @eq.{1} real
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
this :
  @separated.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
    (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ @has_mem.mem.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       x
       y)
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>146    rcases (completion.mem_uniformity_dist s).1 hs with ⟨ε, εpos, hε⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='metric.completion.mem_uniformity_dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='s'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='hs'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 82, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 422, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : metric_space.{u} α] (s : set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))), iff (@has_mem.mem.{u u} (set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (filter.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@filter.has_mem.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) s (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@Exists.{1} real (λ (ε : real), @Exists.{0} (@gt.{0} real real.has_lt ε (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))) (λ (H : @gt.{0} real real.has_lt ε (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))), ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)}, @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) a b) ε → @has_mem.mem.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@set.has_mem.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) a b) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@has_mem.mem.{u u} (set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (filter.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@filter.has_mem.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) s (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)) (λ (a : prod.{0 0} pexpr (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat)), @prod.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) (sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) (λ (a : sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat), @sum.has_reflect (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) (λ (a : prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))), @prod.has_reflect (option.{0} name) (λ (a : option.{0} name), @option.has_reflect name (λ (a : name), name.reflect a) `(name) a) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) (λ (a : tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)), @list.reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) `(tactic.list_Pi.{0} tactic.rcases_patt) a) `(option.{0} name) `(tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt)) a) nat (λ (a : nat), nat.reflect a) `(prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) `(nat) a) `(pexpr) `(sum.{0 0} (prod.{0 0} (option.{0} name) (tactic.list_Sigma.{0} (tactic.list_Pi.{0} tactic.rcases_patt))) nat) a) tactic.rcases_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title=' Elements of the uniformity (defined generally for completions) can be characterized in terms
of the distance.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `rcases` tactic is the same as `cases`, but with more flexibility in the
`with` pattern syntax to allow for recursive case splitting. The pattern syntax
uses the following recursive grammar:

```lean
patt ::= (patt_list &quot;|&quot;)* patt_list
patt_list ::= id | &quot;_&quot; | &quot;⟨&quot; (patt &quot;,&quot;)* patt &quot;⟩&quot;
```

A pattern like `⟨a, b, c⟩ | ⟨d, e⟩` will do a split over the inductive datatype,
naming the first three parameters of the first constructor as `a,b,c` and the
first two of the second constructor `d,e`. If the list is not as long as the
number of arguments to the constructor or the number of constructors, the
remaining variables will be automatically named. If there are nested brackets
such as `⟨⟨a⟩, b | c⟩ | d` then these will cause more case splits as necessary.
If there are too many arguments, such as `⟨a, b, c⟩` for splitting on
`∃ x, ∃ y, p x`, then it will be treated as `⟨a, ⟨b, c⟩⟩`, splitting the last
parameter as necessary.

`rcases` also has special support for quotient types: quotient induction into Prop works like
matching on the constructor `quot.mk`.

`rcases h : e with PAT` will do the same as `rcases e with PAT` with the exception that an assumption
`h : e = PAT` will be added to the context.

`rcases? e` will perform case splits on `e` in the same way as `rcases e`,
but rather than accepting a pattern, it does a maximal cases and prints the
pattern that would produce this case splitting. The default maximum depth is 5,
but this can be modified with `rcases? e : n`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rcases'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; expr (: n)?) | ((h :)? expr (with patt_list)?)&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                               </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
h :
  @eq.{1} real
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
this :
  @separated.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
    (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ @has_mem.mem.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       x
       y)
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────────────────────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
h :
  @eq.{1} real
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
this :
  @separated.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
    (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s
⊢ @has_mem.mem.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       x
       y)
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>147    rw ← h at εpos,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='blue'><a title='h'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@eq.{1} real (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) x y) (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
h :
  @eq.{1} real
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
this :
  @separated.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
    (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s
⊢ @has_mem.mem.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       x
       y)
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
h :
  @eq.{1} real
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
this :
  @separated.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
    (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
⊢ @has_mem.mem.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       x
       y)
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>148    exact hε εpos</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='blue'><a title='hε'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='εpos'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)}, @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) a b) ε → @has_mem.mem.{u u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (set.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@set.has_mem.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) a b) s'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@gt.{0} real real.has_lt ε (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1),
h :
  @eq.{1} real
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
this :
  @separated.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
    (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)),
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
hs :
  @has_mem.mem.{u u}
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@filter.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    s
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
ε : real,
hε :
  ∀ {a b : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)},
    @has_lt.lt.{0} real real.has_lt
      (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@metric.has_dist.{u} α _inst_1)
         a
         b)
      ε →
    @has_mem.mem.{u u}
      (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
      (set.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@set.has_mem.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
      (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
         a
         b)
      s,
εpos :
  @gt.{0} real real.has_lt ε
    (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@metric.has_dist.{u} α _inst_1)
       x
       y)
⊢ @has_mem.mem.{u u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (set.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@set.has_mem.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@prod.mk.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       x
       y)
    s'><code style='font-family: menlo, "Source Code Pro", monospace;'>───────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>149  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>150  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>151  /- Reformulate `completion.mem_uniformity_dist` in terms that are suitable for the definition</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>152  of the metric space structure. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>153  protected lemma completion.uniformity_dist&#x27; :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>154    uniformity (completion α) = (⨅ε:{ε:ℝ // ε&gt;0}, principal {p | dist p.1 p.2 &lt; ε.val}) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_space.completion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lattice.infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='subtype'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='blue'><a title='ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='gt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lattice.infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.principal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_dist.dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='subtype.val'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 322, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/real/basic.lean&#x27;, &#x27;line&#x27;: 12, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 372, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 258, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u) [_inst_2 : uniform_space.{u} α], filter.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : uniform_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {ι : Type} [_inst_1 : lattice.has_Inf.{u} α], (ι → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type}, (α → Prop) → Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Type'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} [_inst_1 : has_lt.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {ι : Type} [_inst_1 : lattice.has_Inf.{u} α], (ι → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_1} [c : has_dist.{u_1} α], α → α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_lt.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@subtype.{1} real (λ (ε : real), @gt.{0} real real.has_lt ε (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type} {p : α → Prop}, @subtype.{1} α p → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Hausdorff completion of `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='Indexed infimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>              </code><font color='orange'><a title='Indexed infimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The principal filter of `s` is the collection of all supersets of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>155  begin</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α
⊢ @eq.{u+1}
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@lattice.infi.{u 1}
       (filter.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@subtype.{1} real
          (λ (ε : real),
             @gt.{0} real real.has_lt ε
               (@has_zero.zero.{0} real
                  (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))))
       (@lattice.conditionally_complete_lattice.to_has_Inf.{u}
          (filter.{u}
             (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{u}
             (filter.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
             (@filter.lattice.complete_lattice.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))))
       (λ
        (ε :
          @subtype.{1} real
            (λ (ε : real),
               @gt.{0} real real.has_lt ε
                 (@has_zero.zero.{0} real
                    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))),
          @filter.principal.{u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (@set_of.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               (λ
                (p :
                  prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
                  @has_lt.lt.{0} real real.has_lt
                    (@has_dist.dist.{u}
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@metric.has_dist.{u} α _inst_1)
                       (@prod.fst.{u u}
                          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                          p)
                       (@prod.snd.{u u}
                          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                          p))
                    (@subtype.val.{1} real
                       (λ (ε : real),
                          @gt.{0} real real.has_lt ε
                            (@has_zero.zero.{0} real
                               (@no_zero_divisors.to_has_zero.{0} real
                                  (@domain.to_no_zero_divisors.{0} real real.domain))))
                       ε)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>156    ext s, rw mem_infi,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='blue'><a title='filter.mem_infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/ext.lean&#x27;, &#x27;line&#x27;: 342, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 385, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 448, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.ext_patt (λ (a : tactic.ext_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) tactic.ext_parse → @interactive.parse (option.{0} nat) (λ (a : option.{0} nat), @option.has_reflect nat (λ (a : nat), nat.reflect a) `(nat) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative nat (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit nat (lean.parser.tk (string.str string.empty (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) lean.parser.small_nat)) → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse tactic.interactive.rw_rules_t (λ (a : tactic.interactive.rw_rules_t), tactic.interactive.rw_rules_t.has_reflect a) tactic.interactive.rw_rules → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.rewrite_cfg {to_apply_cfg := {md := tactic.transparency.reducible, approx := bool.tt, new_goals := tactic.new_goals.non_dep_first, instances := bool.tt, auto_param := bool.tt, opt_param := bool.tt, unify := bool.tt}, symm := bool.ff, occs := occurrences.all} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type u} {ι : Type} {f : ι → filter.{u} α}, @directed.{u 1} (filter.{u} α) (@ge.{u} (filter.{u} α) (@preorder.to_has_le.{u} (filter.{u} α) (@partial_order.to_preorder.{u} (filter.{u} α) (@filter.partial_order.{u} α)))) ι f → nonempty.{1} ι → ∀ (s : set.{u} α), iff (@has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (@lattice.infi.{u 1} (filter.{u} α) ι (@lattice.complete_lattice.to_has_Inf.{u} (filter.{u} α) (@filter.lattice.complete_lattice.{u} α)) f)) (@Exists.{1} ι (λ (i : ι), @has_mem.mem.{u u} (set.{u} α) (filter.{u} α) (@filter.has_mem.{u} α) s (f i)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='- `ext` applies as many extensionality lemmas as possible;
- `ext ids`, with `ids` a list of identifiers, finds extentionality and applies them
  until it runs out of identifiers in `ids` to name the local constants.

When trying to prove:

```lean
α β : Type,
f g : α → set β
⊢ f = g
```

applying `ext x y` yields:

```lean
α β : Type,
f g : α → set β,
x : α,
y : β
⊢ y ∈ f x ↔ y ∈ f x
```

by applying functional extensionality and set extensionality.

A maximum depth can be provided with `ext x y z : 3`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='An abbreviation for `rewrite`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='ext'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='rw'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;((patt) | patt_list)*&#x27;, &quot;&lt;error while executing interactive.param_desc: don&#x27;t know how to pretty print lean.parser.small_nat&gt;&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([ (←? expr), ... ] | ←? expr)&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.rewrite_cfg?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α
⊢ @eq.{u+1}
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@lattice.infi.{u 1}
       (filter.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@subtype.{1} real
          (λ (ε : real),
             @gt.{0} real real.has_lt ε
               (@has_zero.zero.{0} real
                  (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))))
       (@lattice.conditionally_complete_lattice.to_has_Inf.{u}
          (filter.{u}
             (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{u}
             (filter.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
             (@filter.lattice.complete_lattice.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))))
       (λ
        (ε :
          @subtype.{1} real
            (λ (ε : real),
               @gt.{0} real real.has_lt ε
                 (@has_zero.zero.{0} real
                    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))),
          @filter.principal.{u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (@set_of.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               (λ
                (p :
                  prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
                  @has_lt.lt.{0} real real.has_lt
                    (@has_dist.dist.{u}
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@metric.has_dist.{u} α _inst_1)
                       (@prod.fst.{u u}
                          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                          p)
                       (@prod.snd.{u u}
                          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                          p))
                    (@subtype.val.{1} real
                       (λ (ε : real),
                          @gt.{0} real real.has_lt ε
                            (@has_zero.zero.{0} real
                               (@no_zero_divisors.to_has_zero.{0} real
                                  (@domain.to_no_zero_divisors.{0} real real.domain))))
                       ε)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ iff
    (@has_mem.mem.{u u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (filter.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@filter.has_mem.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       s
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@has_mem.mem.{u u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (filter.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@filter.has_mem.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       s
       (@lattice.infi.{u 1}
          (filter.{u}
             (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
          (@subtype.{1} real
             (λ (ε : real),
                @gt.{0} real real.has_lt ε
                  (@has_zero.zero.{0} real
                     (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))))
          (@lattice.conditionally_complete_lattice.to_has_Inf.{u}
             (filter.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
             (@lattice.conditionally_complete_lattice_of_complete_lattice.{u}
                (filter.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                (@filter.lattice.complete_lattice.{u}
                   (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                      (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))))
          (λ
           (ε :
             @subtype.{1} real
               (λ (ε : real),
                  @gt.{0} real real.has_lt ε
                    (@has_zero.zero.{0} real
                       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))),
             @filter.principal.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               (@set_of.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (λ
                   (p :
                     prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
                     @has_lt.lt.{0} real real.has_lt
                       (@has_dist.dist.{u}
                          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                          (@metric.has_dist.{u} α _inst_1)
                          (@prod.fst.{u u}
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             p)
                          (@prod.snd.{u u}
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             p))
                       (@subtype.val.{1} real
                          (λ (ε : real),
                             @gt.{0} real real.has_lt ε
                               (@has_zero.zero.{0} real
                                  (@no_zero_divisors.to_has_zero.{0} real
                                     (@domain.to_no_zero_divisors.{0} real real.domain))))
                          ε))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ iff
    (@has_mem.mem.{u u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (filter.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@filter.has_mem.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       s
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@Exists.{1}
       (@subtype.{1} real
          (λ (ε : real),
             @gt.{0} real real.has_lt ε
               (@has_zero.zero.{0} real
                  (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))))
       (λ
        (i :
          @subtype.{1} real
            (λ (ε : real),
               @gt.{0} real real.has_lt ε
                 (@has_zero.zero.{0} real
                    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))),
          @has_mem.mem.{u u}
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (filter.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@filter.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            s
            (@filter.principal.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               (@set_of.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (λ
                   (p :
                     prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
                     @has_lt.lt.{0} real real.has_lt
                       (@has_dist.dist.{u}
                          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                          (@metric.has_dist.{u} α _inst_1)
                          (@prod.fst.{u u}
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             p)
                          (@prod.snd.{u u}
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             p))
                       (@subtype.val.{1} real
                          (λ (ε : real),
                             @gt.{0} real real.has_lt ε
                               (@has_zero.zero.{0} real
                                  (@no_zero_divisors.to_has_zero.{0} real
                                     (@domain.to_no_zero_divisors.{0} real real.domain))))
                          i))))))

α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ @directed.{u 1}
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@ge.{u}
       (filter.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@preorder.to_has_le.{u}
          (filter.{u}
             (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
          (@partial_order.to_preorder.{u}
             (filter.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
             (@filter.partial_order.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))))
    (@subtype.{1} real
       (λ (ε : real),
          @gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))))
    (λ
     (ε :
       @subtype.{1} real
         (λ (ε : real),
            @gt.{0} real real.has_lt ε
              (@has_zero.zero.{0} real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))),
       @filter.principal.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
         (@set_of.{u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (λ
             (p :
               prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
               @has_lt.lt.{0} real real.has_lt
                 (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@metric.has_dist.{u} α _inst_1)
                    (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       p)
                    (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       p))
                 (@subtype.val.{1} real
                    (λ (ε : real),
                       @gt.{0} real real.has_lt ε
                         (@has_zero.zero.{0} real
                            (@no_zero_divisors.to_has_zero.{0} real
                               (@domain.to_no_zero_divisors.{0} real real.domain))))
                    ε))))

α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ nonempty.{1}
    (@subtype.{1} real
       (λ (ε : real),
          @gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>157    { simp [completion.mem_uniformity_dist, subset_def] },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='metric.completion.mem_uniformity_dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='set.subset_def'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;line&#x27;: 82, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/data/set/basic.lean&#x27;, &#x27;line&#x27;: 90, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : metric_space.{?l_1} α] (s : set.{?l_1} (prod.{?l_1 ?l_1} (@uniform_space.completion.{?l_1} α (@metric_space.to_uniform_space&#x27;.{?l_1} α _inst_1)) (@uniform_space.completion.{?l_1} α (@metric_space.to_uniform_space&#x27;.{?l_1} α _inst_1)))), iff (@has_mem.mem.{?l_1 ?l_1} (set.{?l_1} (prod.{?l_1 ?l_1} (@uniform_space.completion.{?l_1} α (@metric_space.to_uniform_space&#x27;.{?l_1} α _inst_1)) (@uniform_space.completion.{?l_1} α (@metric_space.to_uniform_space&#x27;.{?l_1} α _inst_1)))) (filter.{?l_1} (prod.{?l_1 ?l_1} (@uniform_space.completion.{?l_1} α (@metric_space.to_uniform_space&#x27;.{?l_1} α _inst_1)) (@uniform_space.completion.{?l_1} α (@metric_space.to_uniform_space&#x27;.{?l_1} α _inst_1)))) (@filter.has_mem.{?l_1} (prod.{?l_1 ?l_1} (@uniform_space.completion.{?l_1} α (@metric_space.to_uniform_space&#x27;.{?l_1} α _inst_1)) (@uniform_space.completion.{?l_1} α (@metric_space.to_uniform_space&#x27;.{?l_1} α _inst_1)))) s (@uniformity.{?l_1} (@uniform_space.completion.{?l_1} α (@metric_space.to_uniform_space&#x27;.{?l_1} α _inst_1)) (@uniform_space.completion.uniform_space.{?l_1} α (@metric_space.to_uniform_space&#x27;.{?l_1} α _inst_1)))) (@Exists.{1} real (λ (ε : real), @Exists.{0} (@gt.{0} real real.has_lt ε (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))) (λ (H : @gt.{0} real real.has_lt ε (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))), ∀ {a b : @uniform_space.completion.{?l_1} α (@metric_space.to_uniform_space&#x27;.{?l_1} α _inst_1)}, @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{?l_1} (@uniform_space.completion.{?l_1} α (@metric_space.to_uniform_space&#x27;.{?l_1} α _inst_1)) (@metric.has_dist.{?l_1} α _inst_1) a b) ε → @has_mem.mem.{?l_1 ?l_1} (prod.{?l_1 ?l_1} (@uniform_space.completion.{?l_1} α (@metric_space.to_uniform_space&#x27;.{?l_1} α _inst_1)) (@uniform_space.completion.{?l_1} α (@metric_space.to_uniform_space&#x27;.{?l_1} α _inst_1))) (set.{?l_1} (prod.{?l_1 ?l_1} (@uniform_space.completion.{?l_1} α (@metric_space.to_uniform_space&#x27;.{?l_1} α _inst_1)) (@uniform_space.completion.{?l_1} α (@metric_space.to_uniform_space&#x27;.{?l_1} α _inst_1)))) (@set.has_mem.{?l_1} (prod.{?l_1 ?l_1} (@uniform_space.completion.{?l_1} α (@metric_space.to_uniform_space&#x27;.{?l_1} α _inst_1)) (@uniform_space.completion.{?l_1} α (@metric_space.to_uniform_space&#x27;.{?l_1} α _inst_1)))) (@prod.mk.{?l_1 ?l_1} (@uniform_space.completion.{?l_1} α (@metric_space.to_uniform_space&#x27;.{?l_1} α _inst_1)) (@uniform_space.completion.{?l_1} α (@metric_space.to_uniform_space&#x27;.{?l_1} α _inst_1)) a b) s)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {s t : set.{?l_1} α}, @eq.{1} Prop (@has_subset.subset.{?l_1} (set.{?l_1} α) (@set.has_subset.{?l_1} α) s t) (∀ (x : α), @has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x s → @has_mem.mem.{?l_1 ?l_1} α (set.{?l_1} α) (@set.has_mem.{?l_1} α) x t)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title=' Elements of the uniformity (defined generally for completions) can be characterized in terms
of the distance.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                              </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='3 goals
α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ iff
    (@has_mem.mem.{u u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (filter.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@filter.has_mem.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       s
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@Exists.{1}
       (@subtype.{1} real
          (λ (ε : real),
             @gt.{0} real real.has_lt ε
               (@has_zero.zero.{0} real
                  (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))))
       (λ
        (i :
          @subtype.{1} real
            (λ (ε : real),
               @gt.{0} real real.has_lt ε
                 (@has_zero.zero.{0} real
                    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))),
          @has_mem.mem.{u u}
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (filter.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@filter.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            s
            (@filter.principal.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               (@set_of.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (λ
                   (p :
                     prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
                     @has_lt.lt.{0} real real.has_lt
                       (@has_dist.dist.{u}
                          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                          (@metric.has_dist.{u} α _inst_1)
                          (@prod.fst.{u u}
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             p)
                          (@prod.snd.{u u}
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             p))
                       (@subtype.val.{1} real
                          (λ (ε : real),
                             @gt.{0} real real.has_lt ε
                               (@has_zero.zero.{0} real
                                  (@no_zero_divisors.to_has_zero.{0} real
                                     (@domain.to_no_zero_divisors.{0} real real.domain))))
                          i))))))

α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ @directed.{u 1}
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@ge.{u}
       (filter.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@preorder.to_has_le.{u}
          (filter.{u}
             (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
          (@partial_order.to_preorder.{u}
             (filter.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
             (@filter.partial_order.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))))
    (@subtype.{1} real
       (λ (ε : real),
          @gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))))
    (λ
     (ε :
       @subtype.{1} real
         (λ (ε : real),
            @gt.{0} real real.has_lt ε
              (@has_zero.zero.{0} real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))),
       @filter.principal.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
         (@set_of.{u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (λ
             (p :
               prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
               @has_lt.lt.{0} real real.has_lt
                 (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@metric.has_dist.{u} α _inst_1)
                    (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       p)
                    (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       p))
                 (@subtype.val.{1} real
                    (λ (ε : real),
                       @gt.{0} real real.has_lt ε
                         (@has_zero.zero.{0} real
                            (@no_zero_divisors.to_has_zero.{0} real
                               (@domain.to_no_zero_divisors.{0} real real.domain))))
                    ε))))

α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ nonempty.{1}
    (@subtype.{1} real
       (λ (ε : real),
          @gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ iff
    (@has_mem.mem.{u u}
       (set.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (filter.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@filter.has_mem.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       s
       (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@Exists.{1}
       (@subtype.{1} real
          (λ (ε : real),
             @gt.{0} real real.has_lt ε
               (@has_zero.zero.{0} real
                  (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))))
       (λ
        (i :
          @subtype.{1} real
            (λ (ε : real),
               @gt.{0} real real.has_lt ε
                 (@has_zero.zero.{0} real
                    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))),
          @has_mem.mem.{u u}
            (set.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (filter.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@filter.has_mem.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            s
            (@filter.principal.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
               (@set_of.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (λ
                   (p :
                     prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
                     @has_lt.lt.{0} real real.has_lt
                       (@has_dist.dist.{u}
                          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                          (@metric.has_dist.{u} α _inst_1)
                          (@prod.fst.{u u}
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             p)
                          (@prod.snd.{u u}
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             p))
                       (@subtype.val.{1} real
                          (λ (ε : real),
                             @gt.{0} real real.has_lt ε
                               (@has_zero.zero.{0} real
                                  (@no_zero_divisors.to_has_zero.{0} real
                                     (@domain.to_no_zero_divisors.{0} real real.domain))))
                          i))))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ @directed.{u 1}
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@ge.{u}
       (filter.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@preorder.to_has_le.{u}
          (filter.{u}
             (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
          (@partial_order.to_preorder.{u}
             (filter.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
             (@filter.partial_order.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))))
    (@subtype.{1} real
       (λ (ε : real),
          @gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))))
    (λ
     (ε :
       @subtype.{1} real
         (λ (ε : real),
            @gt.{0} real real.has_lt ε
              (@has_zero.zero.{0} real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))),
       @filter.principal.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
         (@set_of.{u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (λ
             (p :
               prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
               @has_lt.lt.{0} real real.has_lt
                 (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@metric.has_dist.{u} α _inst_1)
                    (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       p)
                    (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       p))
                 (@subtype.val.{1} real
                    (λ (ε : real),
                       @gt.{0} real real.has_lt ε
                         (@has_zero.zero.{0} real
                            (@no_zero_divisors.to_has_zero.{0} real
                               (@domain.to_no_zero_divisors.{0} real real.domain))))
                    ε))))

α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ nonempty.{1}
    (@subtype.{1} real
       (λ (ε : real),
          @gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>158    { rintro ⟨r, hr⟩ ⟨p, hp⟩, use ⟨min r p, lt_min hr hp⟩,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                 </code><font color='blue'><a title='min'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='r'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lt_min'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hr'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='hp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/rcases.lean&#x27;, &#x27;line&#x27;: 441, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 11, &#x27;column&#x27;: 11}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/functions.lean&#x27;, &#x27;line&#x27;: 121, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/interactive.lean&#x27;, &#x27;line&#x27;: 623, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat) (λ (a : sum.{0 0} (tactic.list_Pi.{0} tactic.rcases_patt) nat), @sum.has_reflect (tactic.list_Pi.{0} tactic.rcases_patt) (λ (a : tactic.list_Pi.{0} tactic.rcases_patt), @list.reflect tactic.rcases_patt (λ (a : tactic.rcases_patt), tactic.rcases_patt.has_reflect a) `(tactic.rcases_patt) a) nat (λ (a : nat), nat.reflect a) `(tactic.list_Pi.{0} tactic.rcases_patt) `(nat) a) tactic.rintro_parse → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type} [_inst_1 : decidable_linear_order.{0} α], α → α → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : decidable_linear_order.{0} α] {a b c : α}, @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α (@decidable_linear_order.to_linear_order.{0} α _inst_1)))) a b → @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α (@decidable_linear_order.to_linear_order.{0} α _inst_1)))) a c → @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@linear_order.to_partial_order.{0} α (@decidable_linear_order.to_linear_order.{0} α _inst_1)))) a (@min.{0} α _inst_1 b c)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@gt.{0} real real.has_lt r (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@gt.{0} real real.has_lt p (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (list.{0} pexpr) (λ (a : list.{0} pexpr), @list.reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) interactive.types.pexpr_list_or_texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `rintro` tactic is a combination of the `intros` tactic with `rcases` to
allow for destructuring patterns while introducing variables. See `rcases` for
a description of supported patterns. For example, `rintro (a | ⟨b, c⟩) ⟨d, e⟩`
will introduce two variables, and then do case splits on both of them producing
two subgoals, one with variables `a d e` and the other with `b c d e`.

`rintro?` will introduce and case split on variables in the same way as
`rintro`, but will also print the `rintro` invocation that would have the same
result. Like `rcases?`, `rintro? : n` allows for modifying the
depth of splitting; the default is 5.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Similar to `existsi`. `use x` will instantiate the first term of an `∃` or `Σ` goal with `x`.
It will then try to close the new goal using `triv`, or try to simplify it by applying `exists_prop`.
Unlike `existsi`, `x` is elaborated with respect to the expected type.
`use` will alternatively take a list of terms `[x0, ..., xn]`.

`use` will work with constructors of arbitrary inductive types.

Examples:

example (α : Type) : ∃ S : set α, S = S :=
by use ∅

example : ∃ x : ℤ, x = x :=
by use 42

example : ∃ n &gt; 0, n = n :=
begin
  use 1,
  -- goal is now 1 &gt; 0 ∧ 1 = 1, whereas it would be ∃ (H : 1 &gt; 0), 1 = 1 after existsi 1.
  exact ⟨zero_lt_one, rfl⟩,
end

example : ∃ a b c : ℤ, a + b + c = 6 :=
by use [1, 2, 3]

example : ∃ p : ℤ × ℤ, p.1 = 1 :=
by use ⟨1, 42⟩

example : Σ x y : ℤ, (ℤ × ℤ) × ℤ :=
by use [1, 2, 3, 4, 5]

inductive foo
| mk : ℕ → bool × ℕ → ℕ → foo

example : foo :=
by use [100, tt, 4, 3]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='rintro'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='use'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&quot;(&#x27;?&#x27; (: n)?) | patt_list&quot;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;([expr, ...] | expr)&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>     </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>      </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='2 goals
α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ @directed.{u 1}
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@ge.{u}
       (filter.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@preorder.to_has_le.{u}
          (filter.{u}
             (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
          (@partial_order.to_preorder.{u}
             (filter.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
             (@filter.partial_order.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))))
    (@subtype.{1} real
       (λ (ε : real),
          @gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))))
    (λ
     (ε :
       @subtype.{1} real
         (λ (ε : real),
            @gt.{0} real real.has_lt ε
              (@has_zero.zero.{0} real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))),
       @filter.principal.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
         (@set_of.{u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (λ
             (p :
               prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
               @has_lt.lt.{0} real real.has_lt
                 (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@metric.has_dist.{u} α _inst_1)
                    (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       p)
                    (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       p))
                 (@subtype.val.{1} real
                    (λ (ε : real),
                       @gt.{0} real real.has_lt ε
                         (@has_zero.zero.{0} real
                            (@no_zero_divisors.to_has_zero.{0} real
                               (@domain.to_no_zero_divisors.{0} real real.domain))))
                    ε))))

α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ nonempty.{1}
    (@subtype.{1} real
       (λ (ε : real),
          @gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>───┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ @directed.{u 1}
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@ge.{u}
       (filter.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@preorder.to_has_le.{u}
          (filter.{u}
             (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
          (@partial_order.to_preorder.{u}
             (filter.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
             (@filter.partial_order.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))))
    (@subtype.{1} real
       (λ (ε : real),
          @gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))))
    (λ
     (ε :
       @subtype.{1} real
         (λ (ε : real),
            @gt.{0} real real.has_lt ε
              (@has_zero.zero.{0} real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))),
       @filter.principal.{u}
         (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
         (@set_of.{u}
            (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
            (λ
             (p :
               prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                 (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
               @has_lt.lt.{0} real real.has_lt
                 (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@metric.has_dist.{u} α _inst_1)
                    (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       p)
                    (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       p))
                 (@subtype.val.{1} real
                    (λ (ε : real),
                       @gt.{0} real real.has_lt ε
                         (@has_zero.zero.{0} real
                            (@no_zero_divisors.to_has_zero.{0} real
                               (@domain.to_no_zero_divisors.{0} real real.domain))))
                    ε))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
r : real,
hr :
  @gt.{0} real real.has_lt r
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
p : real,
hp :
  @gt.{0} real real.has_lt p
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
⊢ @Exists.{1}
    (@subtype.{1} real
       (λ (ε : real),
          @gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))))
    (λ
     (z :
       @subtype.{1} real
         (λ (ε : real),
            @gt.{0} real real.has_lt ε
              (@has_zero.zero.{0} real
                 (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))),
       and
         (@ge.{u}
            (filter.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@preorder.to_has_le.{u}
               (filter.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
               (@partial_order.to_preorder.{u}
                  (filter.{u}
                     (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                  (@filter.partial_order.{u}
                     (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))))
            ((λ
              (ε :
                @subtype.{1} real
                  (λ (ε : real),
                     @gt.{0} real real.has_lt ε
                       (@has_zero.zero.{0} real
                          (@no_zero_divisors.to_has_zero.{0} real
                             (@domain.to_no_zero_divisors.{0} real real.domain))))),
                @filter.principal.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@set_of.{u}
                     (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                     (λ
                      (p :
                        prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
                        @has_lt.lt.{0} real real.has_lt
                          (@has_dist.dist.{u}
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             (@metric.has_dist.{u} α _inst_1)
                             (@prod.fst.{u u}
                                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                p)
                             (@prod.snd.{u u}
                                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                p))
                          (@subtype.val.{1} real
                             (λ (ε : real),
                                @gt.{0} real real.has_lt ε
                                  (@has_zero.zero.{0} real
                                     (@no_zero_divisors.to_has_zero.{0} real
                                        (@domain.to_no_zero_divisors.{0} real real.domain))))
                             ε))))
               (@subtype.mk.{1} real
                  (λ (ε : real),
                     @gt.{0} real real.has_lt ε
                       (@has_zero.zero.{0} real
                          (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
                  r
                  hr))
            ((λ
              (ε :
                @subtype.{1} real
                  (λ (ε : real),
                     @gt.{0} real real.has_lt ε
                       (@has_zero.zero.{0} real
                          (@no_zero_divisors.to_has_zero.{0} real
                             (@domain.to_no_zero_divisors.{0} real real.domain))))),
                @filter.principal.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@set_of.{u}
                     (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                     (λ
                      (p :
                        prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
                        @has_lt.lt.{0} real real.has_lt
                          (@has_dist.dist.{u}
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             (@metric.has_dist.{u} α _inst_1)
                             (@prod.fst.{u u}
                                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                p)
                             (@prod.snd.{u u}
                                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                p))
                          (@subtype.val.{1} real
                             (λ (ε : real),
                                @gt.{0} real real.has_lt ε
                                  (@has_zero.zero.{0} real
                                     (@no_zero_divisors.to_has_zero.{0} real
                                        (@domain.to_no_zero_divisors.{0} real real.domain))))
                             ε))))
               z))
         (@ge.{u}
            (filter.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@preorder.to_has_le.{u}
               (filter.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
               (@partial_order.to_preorder.{u}
                  (filter.{u}
                     (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                  (@filter.partial_order.{u}
                     (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))))
            ((λ
              (ε :
                @subtype.{1} real
                  (λ (ε : real),
                     @gt.{0} real real.has_lt ε
                       (@has_zero.zero.{0} real
                          (@no_zero_divisors.to_has_zero.{0} real
                             (@domain.to_no_zero_divisors.{0} real real.domain))))),
                @filter.principal.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@set_of.{u}
                     (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                     (λ
                      (p :
                        prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
                        @has_lt.lt.{0} real real.has_lt
                          (@has_dist.dist.{u}
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             (@metric.has_dist.{u} α _inst_1)
                             (@prod.fst.{u u}
                                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                p)
                             (@prod.snd.{u u}
                                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                p))
                          (@subtype.val.{1} real
                             (λ (ε : real),
                                @gt.{0} real real.has_lt ε
                                  (@has_zero.zero.{0} real
                                     (@no_zero_divisors.to_has_zero.{0} real
                                        (@domain.to_no_zero_divisors.{0} real real.domain))))
                             ε))))
               (@subtype.mk.{1} real
                  (λ (ε : real),
                     @gt.{0} real real.has_lt ε
                       (@has_zero.zero.{0} real
                          (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
                  p
                  hp))
            ((λ
              (ε :
                @subtype.{1} real
                  (λ (ε : real),
                     @gt.{0} real real.has_lt ε
                       (@has_zero.zero.{0} real
                          (@no_zero_divisors.to_has_zero.{0} real
                             (@domain.to_no_zero_divisors.{0} real real.domain))))),
                @filter.principal.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                  (@set_of.{u}
                     (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                     (λ
                      (p :
                        prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
                        @has_lt.lt.{0} real real.has_lt
                          (@has_dist.dist.{u}
                             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                             (@metric.has_dist.{u} α _inst_1)
                             (@prod.fst.{u u}
                                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                p)
                             (@prod.snd.{u u}
                                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                                p))
                          (@subtype.val.{1} real
                             (λ (ε : real),
                                @gt.{0} real real.has_lt ε
                                  (@has_zero.zero.{0} real
                                     (@no_zero_divisors.to_has_zero.{0} real
                                        (@domain.to_no_zero_divisors.{0} real real.domain))))
                             ε))))
               z)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
r : real,
hr :
  @gt.{0} real real.has_lt r
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
p : real,
hp :
  @gt.{0} real real.has_lt p
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
⊢ and
    (@ge.{u}
       (filter.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@preorder.to_has_le.{u}
          (filter.{u}
             (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
          (@partial_order.to_preorder.{u}
             (filter.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
             (@filter.partial_order.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))))
       ((λ
         (ε :
           @subtype.{1} real
             (λ (ε : real),
                @gt.{0} real real.has_lt ε
                  (@has_zero.zero.{0} real
                     (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))),
           @filter.principal.{u}
             (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             (@set_of.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (λ
                 (p :
                   prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
                   @has_lt.lt.{0} real real.has_lt
                     (@has_dist.dist.{u}
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (@metric.has_dist.{u} α _inst_1)
                        (@prod.fst.{u u}
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           p)
                        (@prod.snd.{u u}
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           p))
                     (@subtype.val.{1} real
                        (λ (ε : real),
                           @gt.{0} real real.has_lt ε
                             (@has_zero.zero.{0} real
                                (@no_zero_divisors.to_has_zero.{0} real
                                   (@domain.to_no_zero_divisors.{0} real real.domain))))
                        ε))))
          (@subtype.mk.{1} real
             (λ (ε : real),
                @gt.{0} real real.has_lt ε
                  (@has_zero.zero.{0} real
                     (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
             r
             hr))
       ((λ
         (ε :
           @subtype.{1} real
             (λ (ε : real),
                @gt.{0} real real.has_lt ε
                  (@has_zero.zero.{0} real
                     (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))),
           @filter.principal.{u}
             (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             (@set_of.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (λ
                 (p :
                   prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
                   @has_lt.lt.{0} real real.has_lt
                     (@has_dist.dist.{u}
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (@metric.has_dist.{u} α _inst_1)
                        (@prod.fst.{u u}
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           p)
                        (@prod.snd.{u u}
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           p))
                     (@subtype.val.{1} real
                        (λ (ε : real),
                           @gt.{0} real real.has_lt ε
                             (@has_zero.zero.{0} real
                                (@no_zero_divisors.to_has_zero.{0} real
                                   (@domain.to_no_zero_divisors.{0} real real.domain))))
                        ε))))
          (@subtype.mk.{1} real
             (λ (ε : real),
                @gt.{0} real real.has_lt ε
                  (@has_zero.zero.{0} real
                     (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
             (@min.{0} real real.decidable_linear_order r p)
             (@lt_min.{0} real real.decidable_linear_order
                (@has_zero.zero.{0} real
                   (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
                r
                p
                hr
                hp))))
    (@ge.{u}
       (filter.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@preorder.to_has_le.{u}
          (filter.{u}
             (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
          (@partial_order.to_preorder.{u}
             (filter.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
             (@filter.partial_order.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))))
       ((λ
         (ε :
           @subtype.{1} real
             (λ (ε : real),
                @gt.{0} real real.has_lt ε
                  (@has_zero.zero.{0} real
                     (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))),
           @filter.principal.{u}
             (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             (@set_of.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (λ
                 (p :
                   prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
                   @has_lt.lt.{0} real real.has_lt
                     (@has_dist.dist.{u}
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (@metric.has_dist.{u} α _inst_1)
                        (@prod.fst.{u u}
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           p)
                        (@prod.snd.{u u}
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           p))
                     (@subtype.val.{1} real
                        (λ (ε : real),
                           @gt.{0} real real.has_lt ε
                             (@has_zero.zero.{0} real
                                (@no_zero_divisors.to_has_zero.{0} real
                                   (@domain.to_no_zero_divisors.{0} real real.domain))))
                        ε))))
          (@subtype.mk.{1} real
             (λ (ε : real),
                @gt.{0} real real.has_lt ε
                  (@has_zero.zero.{0} real
                     (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
             p
             hp))
       ((λ
         (ε :
           @subtype.{1} real
             (λ (ε : real),
                @gt.{0} real real.has_lt ε
                  (@has_zero.zero.{0} real
                     (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))),
           @filter.principal.{u}
             (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             (@set_of.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (λ
                 (p :
                   prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
                   @has_lt.lt.{0} real real.has_lt
                     (@has_dist.dist.{u}
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (@metric.has_dist.{u} α _inst_1)
                        (@prod.fst.{u u}
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           p)
                        (@prod.snd.{u u}
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           p))
                     (@subtype.val.{1} real
                        (λ (ε : real),
                           @gt.{0} real real.has_lt ε
                             (@has_zero.zero.{0} real
                                (@no_zero_divisors.to_has_zero.{0} real
                                   (@domain.to_no_zero_divisors.{0} real real.domain))))
                        ε))))
          (@subtype.mk.{1} real
             (λ (ε : real),
                @gt.{0} real real.has_lt ε
                  (@has_zero.zero.{0} real
                     (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
             (@min.{0} real real.decidable_linear_order r p)
             (@lt_min.{0} real real.decidable_linear_order
                (@has_zero.zero.{0} real
                   (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
                r
                p
                hr
                hp))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>159      simp [lt_min_iff, (≥)] {contextual := tt} },</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='lt_min_iff'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='ge'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                   </code><font color='blue'><a title='bool.tt'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/algebra/order_functions.lean&#x27;, &#x27;line&#x27;: 110, &#x27;column&#x27;: 14}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 371, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 253, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 1209, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} [_inst_1 : decidable_linear_order.{?l_1} α] {a b c : α}, iff (@has_lt.lt.{?l_1} α (@preorder.to_has_lt.{?l_1} α (@partial_order.to_preorder.{?l_1} α (@lattice.semilattice_inf.to_partial_order.{?l_1} α (@lattice.lattice.to_semilattice_inf.{?l_1} α (@lattice.lattice_of_decidable_linear_order.{?l_1} α _inst_1))))) a (@min.{?l_1} α _inst_1 b c)) (and (@has_lt.lt.{?l_1} α (@preorder.to_has_lt.{?l_1} α (@partial_order.to_preorder.{?l_1} α (@lattice.semilattice_inf.to_partial_order.{?l_1} α (@lattice.lattice.to_semilattice_inf.{?l_1} α (@lattice.lattice_of_decidable_linear_order.{?l_1} α _inst_1))))) a b) (@has_lt.lt.{?l_1} α (@preorder.to_has_lt.{?l_1} α (@partial_order.to_preorder.{?l_1} α (@lattice.semilattice_inf.to_partial_order.{?l_1} α (@lattice.lattice.to_semilattice_inf.{?l_1} α (@lattice.lattice_of_decidable_linear_order.{?l_1} α _inst_1))))) a c))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α : Type ?l_1} [_inst_1 : has_le.{?l_1} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='bool'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse interactive.loc (λ (a : interactive.loc), interactive.loc.has_reflect a) interactive.types.location → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The `simp` tactic uses lemmas and hypotheses to simplify the main goal target or non-dependent hypotheses. It has many variants.

`simp` simplifies the main goal target using lemmas tagged with the attribute `[simp]`.

`simp [h₁ h₂ ... hₙ]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and the given `hᵢ`&#x27;s, where the `hᵢ`&#x27;s are expressions. If an `hᵢ` is a defined constant `f`, then the equational lemmas associated with `f` are used. This provides a convenient way to unfold `f`.

`simp [*]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]` and all hypotheses.

`simp *` is a shorthand for `simp [*]`.

`simp only [h₁ h₂ ... hₙ]` is like `simp [h₁ h₂ ... hₙ]` but does not use `[simp]` lemmas

`simp [-id_1, ... -id_n]` simplifies the main goal target using the lemmas tagged with the attribute `[simp]`, but removes the ones named `idᵢ`.

`simp at h₁ h₂ ... hₙ` simplifies the non-dependent hypotheses `h₁ : T₁` ... `hₙ : Tₙ`. The tactic fails if the target or another hypothesis depends on one of them. The token `⊢` or `|-` can be added to the list to include the target.

`simp at *` simplifies all the hypotheses and the target.

`simp * at *` simplifies target and all (non-dependent propositional) hypotheses using the other hypotheses.

`simp with attr₁ ... attrₙ` simplifies the main goal target using the lemmas tagged with any of the attributes `[attr₁]`, ..., `[attrₙ]` or `[simp]`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='simp'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(at (* | (⊢ | id)*))?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='6'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
r : real,
hr :
  @gt.{0} real real.has_lt r
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))),
p : real,
hp :
  @gt.{0} real real.has_lt p
    (@has_zero.zero.{0} real
       (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
⊢ and
    (@ge.{u}
       (filter.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@preorder.to_has_le.{u}
          (filter.{u}
             (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
          (@partial_order.to_preorder.{u}
             (filter.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
             (@filter.partial_order.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))))
       ((λ
         (ε :
           @subtype.{1} real
             (λ (ε : real),
                @gt.{0} real real.has_lt ε
                  (@has_zero.zero.{0} real
                     (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))),
           @filter.principal.{u}
             (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             (@set_of.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (λ
                 (p :
                   prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
                   @has_lt.lt.{0} real real.has_lt
                     (@has_dist.dist.{u}
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (@metric.has_dist.{u} α _inst_1)
                        (@prod.fst.{u u}
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           p)
                        (@prod.snd.{u u}
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           p))
                     (@subtype.val.{1} real
                        (λ (ε : real),
                           @gt.{0} real real.has_lt ε
                             (@has_zero.zero.{0} real
                                (@no_zero_divisors.to_has_zero.{0} real
                                   (@domain.to_no_zero_divisors.{0} real real.domain))))
                        ε))))
          (@subtype.mk.{1} real
             (λ (ε : real),
                @gt.{0} real real.has_lt ε
                  (@has_zero.zero.{0} real
                     (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
             r
             hr))
       ((λ
         (ε :
           @subtype.{1} real
             (λ (ε : real),
                @gt.{0} real real.has_lt ε
                  (@has_zero.zero.{0} real
                     (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))),
           @filter.principal.{u}
             (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             (@set_of.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (λ
                 (p :
                   prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
                   @has_lt.lt.{0} real real.has_lt
                     (@has_dist.dist.{u}
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (@metric.has_dist.{u} α _inst_1)
                        (@prod.fst.{u u}
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           p)
                        (@prod.snd.{u u}
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           p))
                     (@subtype.val.{1} real
                        (λ (ε : real),
                           @gt.{0} real real.has_lt ε
                             (@has_zero.zero.{0} real
                                (@no_zero_divisors.to_has_zero.{0} real
                                   (@domain.to_no_zero_divisors.{0} real real.domain))))
                        ε))))
          (@subtype.mk.{1} real
             (λ (ε : real),
                @gt.{0} real real.has_lt ε
                  (@has_zero.zero.{0} real
                     (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
             (@min.{0} real real.decidable_linear_order r p)
             (@lt_min.{0} real real.decidable_linear_order
                (@has_zero.zero.{0} real
                   (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
                r
                p
                hr
                hp))))
    (@ge.{u}
       (filter.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       (@preorder.to_has_le.{u}
          (filter.{u}
             (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
          (@partial_order.to_preorder.{u}
             (filter.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
             (@filter.partial_order.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))))
       ((λ
         (ε :
           @subtype.{1} real
             (λ (ε : real),
                @gt.{0} real real.has_lt ε
                  (@has_zero.zero.{0} real
                     (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))),
           @filter.principal.{u}
             (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             (@set_of.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (λ
                 (p :
                   prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
                   @has_lt.lt.{0} real real.has_lt
                     (@has_dist.dist.{u}
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (@metric.has_dist.{u} α _inst_1)
                        (@prod.fst.{u u}
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           p)
                        (@prod.snd.{u u}
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           p))
                     (@subtype.val.{1} real
                        (λ (ε : real),
                           @gt.{0} real real.has_lt ε
                             (@has_zero.zero.{0} real
                                (@no_zero_divisors.to_has_zero.{0} real
                                   (@domain.to_no_zero_divisors.{0} real real.domain))))
                        ε))))
          (@subtype.mk.{1} real
             (λ (ε : real),
                @gt.{0} real real.has_lt ε
                  (@has_zero.zero.{0} real
                     (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
             p
             hp))
       ((λ
         (ε :
           @subtype.{1} real
             (λ (ε : real),
                @gt.{0} real real.has_lt ε
                  (@has_zero.zero.{0} real
                     (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))),
           @filter.principal.{u}
             (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
             (@set_of.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                (λ
                 (p :
                   prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
                   @has_lt.lt.{0} real real.has_lt
                     (@has_dist.dist.{u}
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (@metric.has_dist.{u} α _inst_1)
                        (@prod.fst.{u u}
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           p)
                        (@prod.snd.{u u}
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                           p))
                     (@subtype.val.{1} real
                        (λ (ε : real),
                           @gt.{0} real real.has_lt ε
                             (@has_zero.zero.{0} real
                                (@no_zero_divisors.to_has_zero.{0} real
                                   (@domain.to_no_zero_divisors.{0} real real.domain))))
                        ε))))
          (@subtype.mk.{1} real
             (λ (ε : real),
                @gt.{0} real real.has_lt ε
                  (@has_zero.zero.{0} real
                     (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
             (@min.{0} real real.decidable_linear_order r p)
             (@lt_min.{0} real real.decidable_linear_order
                (@has_zero.zero.{0} real
                   (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))
                r
                p
                hr
                hp))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>─────────────────────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ nonempty.{1}
    (@subtype.{1} real
       (λ (ε : real),
          @gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>160    { exact ⟨⟨1, zero_lt_one⟩⟩ }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>               </code><font color='blue'><a title='zero_lt_one'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/algebra/ordered_ring.lean&#x27;, &#x27;line&#x27;: 95, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 266, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type} [_inst_1 : linear_ordered_semiring.{0} α], @has_lt.lt.{0} α (@preorder.to_has_lt.{0} α (@partial_order.to_preorder.{0} α (@ordered_cancel_comm_monoid.to_partial_order.{0} α (@ordered_semiring.to_ordered_cancel_comm_monoid.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1))))) (@has_zero.zero.{0} α (@mul_zero_class.to_has_zero.{0} α (@semiring.to_mul_zero_class.{0} α (@ordered_semiring.to_semiring.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1))))) (@has_one.one.{0} α (@monoid.to_has_one.{0} α (@semiring.to_monoid.{0} α (@ordered_semiring.to_semiring.{0} α (@linear_ordered_semiring.to_ordered_semiring.{0} α _inst_1)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse pexpr (λ (a : pexpr), @expr.reflect bool.ff a) interactive.types.texpr → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='orange'><a title='This tactic provides an exact proof term to solve the main goal. If `t` is the goal and `p` is a term of type `u` then `exact p` succeeds if and only if `t` and `u` can be unified.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='teal'><a title='exact'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='grey'><a title='[&#x27;expr&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>           </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='1'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α,
s :
  set.{u}
    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
⊢ nonempty.{1}
    (@subtype.{1} real
       (λ (ε : real),
          @gt.{0} real real.has_lt ε
            (@has_zero.zero.{0} real
               (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>────────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>161  end</code>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='no goals'><code style='font-family: menlo, "Source Code Pro", monospace;'>──┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>162  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>163  protected lemma completion.uniformity_dist :</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>164    uniformity (completion α) = (⨅ ε&gt;0, principal {p | dist p.1 p.2 &lt; ε}) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniformity'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_space.completion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lattice.infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='lattice.infi'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='filter.principal'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='set_of'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='has_dist.dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.fst'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='p'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='prod.snd'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='has_lt.lt'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='ε'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/basic.lean&#x27;, &#x27;line&#x27;: 155, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 322, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 145, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/filter/basic.lean&#x27;, &#x27;line&#x27;: 185, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/data/set.lean&#x27;, &#x27;line&#x27;: 13, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 45, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 166, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/core.lean&#x27;, &#x27;line&#x27;: 320, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u) [_inst_2 : uniform_space.{u} α], filter.{u} (prod.{u u} α α)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : uniform_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u}, α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {ι : Type} [_inst_1 : lattice.has_Inf.{u} α], (ι → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type u} {ι : Type} [_inst_1 : lattice.has_Inf.{u} α], (ι → α) → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, set.{u} α → filter.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Π {α : Type u}, (α → Prop) → set.{u} α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π {α : Type u_1} [c : has_dist.{u_1} α], α → α → real'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Π {α β : Type u}, prod.{u u} α β → β'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {α : Type} [c : has_lt.{0} α], α → α → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='real'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='The uniformity is a filter on α × α (inferred from an ambient uniform space
 structure on α).'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Hausdorff completion of `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='orange'><a title='Indexed infimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>    </code><font color='orange'><a title='Indexed infimum'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='The principal filter of `s` is the collection of all supersets of `s`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>165  by simpa [infi_subtype] using @completion.uniformity_dist&#x27; α _</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>          </code><font color='blue'><a title='lattice.infi_subtype'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>         </code><font color='blue'><a title='metric.completion.uniformity_dist&#x27;'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/order/complete_lattice.lean&#x27;, &#x27;line&#x27;: 657, &#x27;column&#x27;: 8}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;line&#x27;: 153, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α : Type ?l_1} {ι : Sort ?l_2} [_inst_1 : lattice.complete_lattice.{?l_1} α] {p : ι → Prop} {f : @subtype.{?l_2} ι p → α}, @eq.{?l_1+1} α (@lattice.infi.{?l_1 (max 1 ?l_2)} α (@subtype.{?l_2} ι p) (@lattice.complete_lattice.to_has_Inf.{?l_1} α _inst_1) (λ (x : @subtype.{?l_2} ι p), f x)) (@lattice.infi.{?l_1 ?l_2} α ι (@lattice.complete_lattice.to_has_Inf.{?l_1} α _inst_1) (λ (i : ι), @lattice.infi.{?l_1 0} α (p i) (@lattice.complete_lattice.to_has_Inf.{?l_1} α _inst_1) (λ (h : p i), f (@subtype.mk.{?l_2} ι p i h))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : metric_space.{u} α], @eq.{u+1} (filter.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@lattice.infi.{u 1} (filter.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@subtype.{1} real (λ (ε : real), @gt.{0} real real.has_lt ε (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))) (@lattice.conditionally_complete_lattice.to_has_Inf.{u} (filter.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@lattice.conditionally_complete_lattice_of_complete_lattice.{u} (filter.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@filter.lattice.complete_lattice.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))) (λ (ε : @subtype.{1} real (λ (ε : real), @gt.{0} real real.has_lt ε (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))), @filter.principal.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@set_of.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (λ (p : prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))), @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) p) (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) p)) (@subtype.val.{1} real (λ (ε : real), @gt.{0} real real.has_lt ε (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))) ε)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>        </code><font color='maroon'><a title='0'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='maroon'><a title='2'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='3'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                            </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='maroon'><a title='4'><code style='font-family: menlo, "Source Code Pro", monospace;'>└┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>└</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α
⊢ @eq.{u+1}
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@lattice.infi.{u 1}
       (filter.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       real
       (@lattice.conditionally_complete_lattice.to_has_Inf.{u}
          (filter.{u}
             (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{u}
             (filter.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
             (@filter.lattice.complete_lattice.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))))
       (λ (ε : real),
          @lattice.infi.{u 0}
            (filter.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@gt.{0} real real.has_lt ε
               (@has_zero.zero.{0} real
                  (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
            (@lattice.conditionally_complete_lattice.to_has_Inf.{u}
               (filter.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{u}
                  (filter.{u}
                     (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                  (@filter.lattice.complete_lattice.{u}
                     (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))))
            (λ
             (H :
               @gt.{0} real real.has_lt ε
                 (@has_zero.zero.{0} real
                    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))),
               @filter.principal.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                 (@set_of.{u}
                    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (λ
                     (p :
                       prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
                       @has_lt.lt.{0} real real.has_lt
                         (@has_dist.dist.{u}
                            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                            (@metric.has_dist.{u} α _inst_1)
                            (@prod.fst.{u u}
                               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                               p)
                            (@prod.snd.{u u}
                               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                               p))
                         ε)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────────────────────────────────────────</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>166  </code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/tactic/simpa.lean&#x27;, &#x27;line&#x27;: 21, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='@interactive.parse (option.{0} unit) (λ (a : option.{0} unit), @option.has_reflect unit (λ (a : unit), punit.reflect a) `(unit) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative unit (lean.parser.tk (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) → @interactive.parse bool (λ (a : bool), bool.has_reflect a) interactive.types.only_flag → @interactive.parse (list.{0} tactic.simp_arg_type) (λ (a : list.{0} tactic.simp_arg_type), @list.reflect tactic.simp_arg_type (λ (a : tactic.simp_arg_type), tactic.simp_arg_type.has_reflect a) `(tactic.simp_arg_type) a) tactic.simp_arg_list → @interactive.parse (list.{0} name) (λ (a : list.{0} name), @list.reflect name (λ (a : name), name.reflect a) `(name) a) interactive.types.with_ident_list → @interactive.parse (option.{0} pexpr) (λ (a : option.{0} pexpr), @option.has_reflect pexpr (λ (a : pexpr), @expr.reflect bool.ff a) `(pexpr) a) (@optional.{0 0} lean.parser.{0} lean.parser.alternative pexpr (@has_seq_right.seq_right.{0 0} lean.parser.{0} (@applicative.to_has_seq_right.{0 0} lean.parser.{0} (@monad.to_applicative.{0 0} lean.parser.{0} (@interaction_monad.monad.{0} lean.parser_state))) unit pexpr (lean.parser.tk (string.str (string.str (string.str (string.str (string.str string.empty (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one))))))))) (char.of_nat (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@bit0.{0} nat nat.has_add (@bit0.{0} nat nat.has_add (@bit1.{0} nat nat.has_one nat.has_add (@has_one.one.{0} nat nat.has_one)))))))))) interactive.types.texpr)) → opt_param.{1} tactic.simp_config_ext {to_simp_config := {max_steps := simp.default_max_steps, contextual := bool.ff, lift_eq := bool.tt, canonize_instances := bool.tt, canonize_proofs := bool.ff, use_axioms := bool.tt, zeta := bool.tt, beta := bool.tt, eta := bool.tt, proj := bool.tt, iota := bool.tt, iota_eqn := bool.ff, constructor_eq := bool.tt, single_pass := bool.ff, fail_if_unchanged := bool.tt, memoize := bool.tt}, discharger := @tactic.failed unit} → tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='This is a &quot;finishing&quot; tactic modification of `simp`.

* `simpa [rules, ...] using e` will simplify the goal and the type of
  `e` using `rules`, then try to close the goal using `e`.

* `simpa [rules, ...]` will simplify the goal using `rules`, then try
  to close it using `assumption`.'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='teal'><a title='simpa'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='grey'><a title='[&#x27;!?&#x27;, &#x27;only?&#x27;, &#x27;(* | [(* | (- id | expr)), ...]?)&#x27;, &#x27;(with id*)?&#x27;, &#x27;(using expr)?&#x27;, &#x27;tactic.simp_config_ext?&#x27;]'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='tactic_param_idx'><code style='font-family: menlo, "Source Code Pro", monospace;'>pid  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='maroon'><a title='5'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α
⊢ @eq.{u+1}
    (filter.{u}
       (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
          (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
    (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
       (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
    (@lattice.infi.{u 1}
       (filter.{u}
          (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
             (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
       real
       (@lattice.conditionally_complete_lattice.to_has_Inf.{u}
          (filter.{u}
             (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
          (@lattice.conditionally_complete_lattice_of_complete_lattice.{u}
             (filter.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
             (@filter.lattice.complete_lattice.{u}
                (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                   (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))))
       (λ (ε : real),
          @lattice.infi.{u 0}
            (filter.{u}
               (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                  (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
            (@gt.{0} real real.has_lt ε
               (@has_zero.zero.{0} real
                  (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))))
            (@lattice.conditionally_complete_lattice.to_has_Inf.{u}
               (filter.{u}
                  (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                     (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
               (@lattice.conditionally_complete_lattice_of_complete_lattice.{u}
                  (filter.{u}
                     (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))
                  (@filter.lattice.complete_lattice.{u}
                     (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                        (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))))))
            (λ
             (H :
               @gt.{0} real real.has_lt ε
                 (@has_zero.zero.{0} real
                    (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))),
               @filter.principal.{u}
                 (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                    (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                 (@set_of.{u}
                    (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                       (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))
                    (λ
                     (p :
                       prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                         (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))),
                       @has_lt.lt.{0} real real.has_lt
                         (@has_dist.dist.{u}
                            (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                            (@metric.has_dist.{u} α _inst_1)
                            (@prod.fst.{u u}
                               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                               p)
                            (@prod.snd.{u u}
                               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                               (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))
                               p))
                         ε)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>167  /-- Metric space structure on the completion of a metric space. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>168  instance completion.metric_space : metric_space (completion α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='blue'><a title='metric_space'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='uniform_space.completion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/basic.lean&#x27;, &#x27;line&#x27;: 63, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 322, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='green'><a title='Type u → Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : uniform_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                   </code><font color='orange'><a title=' Metric space

Each metric space induces a canonical `uniform_space` and hence a canonical `topological_space`.
This is enforced in the type class definition, by extending the `uniform_space` structure. When
instantiating a `metric_space` structure, the uniformity fields are not necessary, they will be
filled in by default. In the same way, each metric space induces an emetric space structure.
It is included in the structure, but filled in by default.

When one instantiates a metric space structure, for instance a product structure,
this makes it possible to use a uniform structure and an edistance that are exactly
the ones for the uniform spaces product and the emetric spaces products, thereby
ensuring that everything in defeq in diamonds.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='orange'><a title='Hausdorff completion of `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>169  { dist_self          := completion.dist_self,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='control_laws_tac'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='blue'><a title='metric.completion.dist_self'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/category/lawful.lean&#x27;, &#x27;line&#x27;: 14, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='red'><a title='{&#x27;line&#x27;: 42, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                       </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : metric_space.{u} α] (x : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)), @eq.{1} real (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) x x) (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>170    eq_of_dist_eq_zero := completion.eq_of_dist_eq_zero,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='metric.completion.eq_of_dist_eq_zero'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;line&#x27;: 140, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : metric_space.{u} α] (x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)), @eq.{1} real (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) x y) (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain))) → @eq.{u+1} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) x y'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='orange'><a title='If two points are at distance 0, then they coincide.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└───────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>171    dist_comm          := completion.dist_comm,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='metric.completion.dist_comm'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;line&#x27;: 52, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : metric_space.{u} α] (x y : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)), @eq.{1} real (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) x y) (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) y x)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>172    dist_triangle      := completion.dist_triangle,</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='metric.completion.dist_triangle'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;line&#x27;: 61, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : metric_space.{u} α] (x y z : @uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)), @has_le.le.{0} real real.has_le (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) x z) (@has_add.add.{0} real (@distrib.to_has_add.{0} real (@ring.to_distrib.{0} real real.ring)) (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) x y) (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) y z))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>173    to_uniform_space   := by apply_instance,</code>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/meta/interactive.lean&#x27;, &#x27;line&#x27;: 213, &#x27;column&#x27;: 9}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='green'><a title='tactic.{0} unit'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='orange'><a title='This tactic tries to close the main goal `... ⊢ t` by generating a term of type `t` using type class resolution.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='text'><code style='font-family: menlo, "Source Code Pro", monospace;'>txt  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='teal'><a title='apply_instance'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='tactic_params'><code style='font-family: menlo, "Source Code Pro", monospace;'>par  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                           </code><font color='grey'><a title='[]'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────┘</code></a></font>
<font color='grey'><a title='state'><code style='font-family: menlo, "Source Code Pro", monospace;'>st   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                          </code><font color='lime'><a title='α : Type u,
_inst_1 : metric_space.{u} α
⊢ uniform_space.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>174    uniformity_dist    := completion.uniformity_dist }</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='blue'><a title='metric.completion.uniformity_dist'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='red'><a title='{&#x27;line&#x27;: 163, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                        </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : metric_space.{u} α], @eq.{u+1} (filter.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@uniformity.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.uniform_space.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@lattice.infi.{u 1} (filter.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) real (@lattice.conditionally_complete_lattice.to_has_Inf.{u} (filter.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@lattice.conditionally_complete_lattice_of_complete_lattice.{u} (filter.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@filter.lattice.complete_lattice.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))) (λ (ε : real), @lattice.infi.{u 0} (filter.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@gt.{0} real real.has_lt ε (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))) (@lattice.conditionally_complete_lattice.to_has_Inf.{u} (filter.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@lattice.conditionally_complete_lattice_of_complete_lattice.{u} (filter.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))) (@filter.lattice.complete_lattice.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)))))) (λ (H : @gt.{0} real real.has_lt ε (@has_zero.zero.{0} real (@no_zero_divisors.to_has_zero.{0} real (@domain.to_no_zero_divisors.{0} real real.domain)))), @filter.principal.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (@set_of.{u} (prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) (λ (p : prod.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))), @has_lt.lt.{0} real real.has_lt (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) (@prod.fst.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) p) (@prod.snd.{u u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) p)) ε)))))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>175  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>176  /-- The embedding of a metric space in its completion is an isometry. -/</code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>177  lemma completion.coe_isometry : isometry (coe : α → completion α) :=</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='blue'><a title='isometry'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='coe'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='blue'><a title='uniform_space.completion'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='blue'><a title='α'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/isometry.lean&#x27;, &#x27;line&#x27;: 28, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/coe.lean&#x27;, &#x27;line&#x27;: 67, &#x27;column&#x27;: 17}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>       </code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/uniform_space/completion.lean&#x27;, &#x27;line&#x27;: 322, &#x27;column&#x27;: 4}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='green'><a title='Π {α : Type u} {β : Type v} [_inst_1 : emetric_space.{u} α] [_inst_2 : emetric_space.{v} β], (α → β) → Prop'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='Π {a : Sort u} {b : Sort v} [_inst_1 : has_lift_t.{u v} a b], a → b'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='green'><a title='Π (α : Type u_1) [_inst_1 : uniform_space.{u_1} α], Type u_1'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'> </code><font color='green'><a title='Type u'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>                                </code><font color='orange'><a title=' An isometry (also known as isometric embedding) is a map preserving the edistance
between emetric spaces, or equivalently the distance between metric space.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└──────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>            </code><font color='orange'><a title='Hausdorff completion of `α`'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>178  isometry_emetric_iff_metric.2 completion.dist_eq</code>
<font color='grey'><a title='full-id'><code style='font-family: menlo, "Source Code Pro", monospace;'>id   </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='isometry_emetric_iff_metric'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='blue'><a title='iff.mpr'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='blue'><a title='metric.completion.dist_eq'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='source'><code style='font-family: menlo, "Source Code Pro", monospace;'>src  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/lean_info_scrapper/_target/deps/mathlib/src/topology/metric_space/isometry.lean&#x27;, &#x27;line&#x27;: 32, &#x27;column&#x27;: 6}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='red'><a title='{&#x27;file&#x27;: &#x27;/home/ec2-user/.elan/toolchains/3.4.2/lib/lean/library/init/logic.lean&#x27;, &#x27;line&#x27;: 223, &#x27;column&#x27;: 10}'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='red'><a title='{&#x27;line&#x27;: 37, &#x27;column&#x27;: 16}'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='type'><code style='font-family: menlo, "Source Code Pro", monospace;'>typ  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {α β : Type u} [_inst_1 : metric_space.{u} α] [_inst_2 : metric_space.{u} β] {f : α → β}, iff (@isometry.{u u} α β (@metric_space.to_emetric_space.{u} α _inst_1) (@metric_space.to_emetric_space.{u} β _inst_2) f) (∀ (x y : α), @eq.{1} real (@has_dist.dist.{u} β (@metric_space.to_has_dist.{u} β _inst_2) (f x) (f y)) (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y))'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='green'><a title='∀ {a b : Prop}, iff a b → b → a'><code style='font-family: menlo, "Source Code Pro", monospace;'>┴</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>  </code><font color='green'><a title='∀ {α : Type u} [_inst_1 : metric_space.{u} α] (x y : α), @eq.{1} real (@has_dist.dist.{u} (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@metric.has_dist.{u} α _inst_1) (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) x) (@coe.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@coe_to_lift.{u+1 u+1} α (@uniform_space.completion.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1)) (@uniform_space.completion.has_coe_t.{u} α (@metric_space.to_uniform_space&#x27;.{u} α _inst_1))) y)) (@has_dist.dist.{u} α (@metric_space.to_has_dist.{u} α _inst_1) x y)'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<font color='grey'><a title='doc'><code style='font-family: menlo, "Source Code Pro", monospace;'>doc  </code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'></code><font color='orange'><a title='On metric spaces, a map is an isometry if and only if it preserves distances.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└─────────────────────────┘</code></a></font><code style='font-family: menlo, "Source Code Pro", monospace;'>   </code><font color='orange'><a title='The new distance is an extension of the original distance.'><code style='font-family: menlo, "Source Code Pro", monospace;'>└────────────────┘</code></a></font>
<code style='font-family: menlo, "Source Code Pro", monospace;'>179  </code>
<code style='font-family: menlo, "Source Code Pro", monospace;'>180  end metric</code></pre>
</body>